{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/bg.jpg","path":"images/bg.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/touxiang.JPG","path":"images/touxiang.JPG","modified":0,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/anime.min.js","path":"lib/anime.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","path":"lib/font-awesome/css/all.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","path":"lib/font-awesome/webfonts/fa-brands-400.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","path":"lib/font-awesome/webfonts/fa-regular-400.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","path":"lib/font-awesome/webfonts/fa-solid-900.woff2","modified":0,"renderable":1},{"_id":"source/images/1.png","path":"images/1.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/_data/styles.styl","hash":"d867508a72f0c0eba5e42372aaef704a18b5a1b6","modified":1636087784796},{"_id":"source/_data/variables.styl","hash":"d2023cd6ef249aaa0c5a2bca993b76e0ae1d6074","modified":1636087784797},{"_id":"source/_posts/1.png","hash":"f523f6a0dbcd669796e0fca215a48ec148fc4d6c","modified":1636090923362},{"_id":"source/_posts/MIT6.S081 Lab4.md","hash":"a202f1c73e9c125337cfa10e7a8c36df09df4058","modified":1636087784799},{"_id":"source/_posts/MIT6.S081 Lab3.md","hash":"5cc5cca3d7149431e6b3021c14c40f78ed80505e","modified":1636087784798},{"_id":"source/_posts/MIT6.S081 Lab5.md","hash":"2b96cf025939739e71d65c1a76d56bbd35ddc7ff","modified":1636087784799},{"_id":"source/_posts/MIT6.S081 Lab7.md","hash":"ca957e3b5c6acc053f34e2b79d1344149e71ce16","modified":1636087784801},{"_id":"source/_posts/MIT6.S081 Lab9.md","hash":"7c9a9d528922c00838144a5f41b051ad8a5c2dbc","modified":1636091101695},{"_id":"source/_posts/MIT6.S081 Lab8.md","hash":"f72aed862c379fcdc25e156b91089fed7881312c","modified":1636087784801},{"_id":"source/_posts/MIT6.S081 Lab6.md","hash":"ed61fa8a3763fed6904c4d374c87279a7e5a35fe","modified":1636087784800},{"_id":"themes/next/.editorconfig","hash":"731c650ddad6eb0fc7c3d4a91cad1698fe7ad311","modified":1636023802136},{"_id":"themes/next/.eslintrc.json","hash":"d3c11de434171d55d70daadd3914bc33544b74b8","modified":1636023802137},{"_id":"themes/next/.gitattributes","hash":"3e00e1fb043438cd820d94ee3dc9ffb6718996f3","modified":1636023802138},{"_id":"themes/next/.gitignore","hash":"83418530da80e6a78501e1d62a89c3bf5cbaec3d","modified":1636023802149},{"_id":"themes/next/.travis.yml","hash":"379f31a140ce41e441442add6f673bf397d863ea","modified":1636023802151},{"_id":"themes/next/.stylintrc","hash":"6259e2a0b65d46865ab89564b88fc67638668295","modified":1636023802150},{"_id":"themes/next/README.md","hash":"7d56751b580d042559b2acf904fca4b42bcb30a7","modified":1636023802152},{"_id":"themes/next/LICENSE.md","hash":"0a9c7399f102b4eb0a6950dd31264be421557c7d","modified":1636023802151},{"_id":"themes/next/crowdin.yml","hash":"4a53f5985e545c635cb56b2a57ed290cb8cf8942","modified":1636023802153},{"_id":"themes/next/package.json","hash":"b099e7cea4406e209130410d13de87988ba37b2a","modified":1636023802236},{"_id":"themes/next/_config.yml","hash":"e8c5637e449786fd2cf9c59ffbe8566c13ed05e2","modified":1636041367828},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"778b7e052993ed59f21ed266ba7119ee2e5253fb","modified":1636023802139},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"d2f8e6b65783e31787feb05d2ccea86151f53f35","modified":1636023802144},{"_id":"themes/next/gulpfile.js","hash":"0c76a1ac610ee8cbe8e2cc9cca1c925ffd0edf98","modified":1636023802169},{"_id":"themes/next/.github/mergeable.yml","hash":"1c1cb77a62df1e3654b151c2da34b4a10d351170","modified":1636023802147},{"_id":"themes/next/.github/issue-close-app.yml","hash":"b14756e65546eb9ecc9d4393f0c9a84a3dac1824","modified":1636023802145},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"533fbe6b2f87d7e7ec6949063bb7ea7eb4fbe52d","modified":1636023802146},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5ddde54fb50d11dc08cec899a3588addb56aa386","modified":1636023802140},{"_id":"themes/next/.github/release-drafter.yml","hash":"09c3352b2d643acdc6839601ceb38abc38ab97c5","modified":1636023802148},{"_id":"themes/next/.github/config.yml","hash":"df3d970700e6b409edc3d23be8d553db78d5ba3f","modified":1636023802144},{"_id":"themes/next/.github/lock.yml","hash":"3ce3d0a26030a1cd52b273cc6a6d444d7c8d85c2","modified":1636023802146},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"60c7e9ef0c578deebad43e9395c958fa61096baf","modified":1636023802155},{"_id":"themes/next/.github/stale.yml","hash":"590b65aca710e0fba75d3cf5361a64d13b6b0f63","modified":1636023802148},{"_id":"themes/next/docs/AGPL3.md","hash":"f463f95b169d64983f59fa6f3e4b6760290a0e6b","modified":1636023802154},{"_id":"themes/next/docs/DATA-FILES.md","hash":"980fb8d37701f7fd96b30bb911519de3bbb473d1","modified":1636023802156},{"_id":"themes/next/docs/AUTHORS.md","hash":"cde7cc095ac31b421a573042cf61060f90d9ad0d","modified":1636023802156},{"_id":"themes/next/docs/INSTALLATION.md","hash":"07ea00bee149a1bdc9073e903ee6b411e9f2f818","modified":1636023802157},{"_id":"themes/next/.github/support.yml","hash":"7ce2722d6904c31a086444c422dc49b6aa310651","modified":1636023802149},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"6cc663db5e99fd86bb993c10d446ad26ada88e58","modified":1636023802158},{"_id":"themes/next/docs/LICENSE.txt","hash":"ae5ad07e4f4106bad55535dba042221539e6c7f9","modified":1636023802158},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"1e86d32063b490d204baa9d45d8d3cb22c24a37d","modified":1636023802159},{"_id":"themes/next/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1636023802172},{"_id":"themes/next/languages/de.yml","hash":"15078b7ede1b084e8a6a15d271f0db9c325bd698","modified":1636023802171},{"_id":"themes/next/languages/ar.yml","hash":"abcf220bd615cec0dd50e4d98da56580169d77e1","modified":1636023802170},{"_id":"themes/next/languages/en.yml","hash":"dbb64776f9c001c54d0058256c415a9a0724ed5d","modified":1636023802172},{"_id":"themes/next/docs/MATH.md","hash":"f56946053ade0915ff7efa74d43c38b8dd9e63bb","modified":1636023802159},{"_id":"themes/next/languages/fr.yml","hash":"3e2f89d4bb4441d33ecc7b5a4ee114f627603391","modified":1636023802174},{"_id":"themes/next/languages/fa.yml","hash":"6c0a7d5bcc26eb45a9f3e02f13117c668e77fffd","modified":1636023802174},{"_id":"themes/next/languages/es.yml","hash":"f064c793d56a5e0f20cda93b6f0e355044efc7d8","modified":1636023802173},{"_id":"themes/next/languages/hu.yml","hash":"0ea89ffaefd02a10494995f05a2a59d5e5679a28","modified":1636023802175},{"_id":"themes/next/languages/ja.yml","hash":"bf279d0eb1911806d01a12f27261fbc76a3bb3f9","modified":1636023802176},{"_id":"themes/next/languages/it.yml","hash":"46222f468e66789e9ba13095809eb5e5b63edf30","modified":1636023802176},{"_id":"themes/next/languages/ko.yml","hash":"af4be6cb394abd4e2e9a728418897d2ed4cc5315","modified":1636023802177},{"_id":"themes/next/languages/pt-BR.yml","hash":"69aa3bef5710b61dc9a0f3b3a8f52f88c4d08c00","modified":1636023802178},{"_id":"themes/next/languages/nl.yml","hash":"9749cf90b250e631dd550a4f32ada3bb20f66dd0","modified":1636023802178},{"_id":"themes/next/languages/id.yml","hash":"7599bb0ecf278beb8fde3d17bfc148a3241aef82","modified":1636023802175},{"_id":"themes/next/languages/pt.yml","hash":"f6606dd0b916a465c233f24bd9a70adce34dc8d6","modified":1636023802179},{"_id":"themes/next/languages/ru.yml","hash":"012abc694cf9de281a0610f95f79c594f0a16562","modified":1636023802179},{"_id":"themes/next/languages/tr.yml","hash":"c4e9ab7e047ae13a19f147c6bec163c3ba2c6898","modified":1636023802180},{"_id":"themes/next/languages/uk.yml","hash":"69ef00b1b8225920fcefff6a6b6f2f3aad00b4ce","modified":1636023802180},{"_id":"themes/next/languages/vi.yml","hash":"6a578cc28773bd764f4418110500478f185d6efa","modified":1636023802181},{"_id":"themes/next/languages/zh-CN.yml","hash":"81d73e21402dad729053a3041390435f43136a68","modified":1636023802181},{"_id":"themes/next/languages/zh-HK.yml","hash":"92ccee40c234626bf0142152949811ebe39fcef2","modified":1636023802182},{"_id":"themes/next/layout/_layout.swig","hash":"9554bd0f5c5a0438aa7b64065be5561c374d260e","modified":1636023802183},{"_id":"themes/next/layout/archive.swig","hash":"d9bca77f6dcfef71e300a294f731bead11ce199f","modified":1636023802232},{"_id":"themes/next/layout/category.swig","hash":"c546b017a956faaa5f5643c7c8a363af7ac9d6b9","modified":1636023802233},{"_id":"themes/next/languages/zh-TW.yml","hash":"cf0740648725983fb88409d6501876f8b79db41d","modified":1636023802182},{"_id":"themes/next/layout/index.swig","hash":"8dfd96fb6f833dd5d037de800813105654e8e8e6","modified":1636023802233},{"_id":"themes/next/layout/post.swig","hash":"5f0b5ba2e0a5b763be5e7e96611865e33bba24d7","modified":1636023802235},{"_id":"themes/next/scripts/renderer.js","hash":"e3658eea97b1183ee2e9f676231e53f7994741f6","modified":1636023802251},{"_id":"themes/next/layout/tag.swig","hash":"d44ff8755727f6532e86fc9fc8dc631200ffe161","modified":1636023802235},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"e67146befddec3a0dc47dc80d1109070c71d5d04","modified":1636023802141},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"d5aa1a3323639a36bcd9a401484b67537043cd3c","modified":1636023802142},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"6beeca0f45a429cd932b6e648617f548ff64c27c","modified":1636023802142},{"_id":"themes/next/.github/ISSUE_TEMPLATE/question.md","hash":"59275aa0582f793fee7be67904dcf52ad33a7181","modified":1636023802143},{"_id":"themes/next/layout/page.swig","hash":"357d916694d4c9a0fd1140fa56d3d17e067d8b52","modified":1636023802234},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"54e6a067ed95268eab6be2ba040a7e9b1907928e","modified":1636023802160},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"cb8e39c377fc4a14aaf133b4d1338a48560e9e65","modified":1636023802162},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"a9cfe5ac9ef727a8650b2b6584482751a26b1460","modified":1636023802161},{"_id":"themes/next/docs/ru/README.md","hash":"1e5ddb26ad6f931f8c06ce2120f257ff38b74fdf","modified":1636023802162},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"7e6f227f2aaf30f400d4c065650a4e3d0d61b9e1","modified":1636023802164},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"611f2930c2b281b80543531b1bf33d082531456a","modified":1636023802165},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"3202be9a8d31986caac640e7a4c7ce22e99917eb","modified":1636023802164},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"2d868cd271d78b08775e28c5b976de8836da4455","modified":1636023802166},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"50ab381c27611d5bf97bb3907b5ca9998f28187d","modified":1636023802167},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"716111dd36d276f463c707dfcc9937fea2a1cf7a","modified":1636023802166},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"b3201934b966bc731eaf8a4dad4ba4bdcd300c10","modified":1636023802169},{"_id":"themes/next/docs/zh-CN/README.md","hash":"8f7c0d0b766024152591d4ccfac715c8e18b37f3","modified":1636023802168},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"30ade8c806d7826cc50a4a3e46a9e6213fddf333","modified":1636023802185},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"0d46f9f50cf2e4183970adce705d1041155b0d37","modified":1636023802168},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"5bffdb1448caca7db7b1f84e1693e6657a106d50","modified":1636023802186},{"_id":"themes/next/layout/_macro/post.swig","hash":"c3fd56bac90ce45a0c79ddfe68beb223ad0d72b4","modified":1636023802185},{"_id":"themes/next/layout/_partials/comments.swig","hash":"142efb4c6b73d8f736f6784804b40d5871333172","modified":1636023802187},{"_id":"themes/next/layout/_partials/languages.swig","hash":"c3ea82604a5853fb44c5f4e4663cbe912aa5dcf8","modified":1636023802193},{"_id":"themes/next/layout/_partials/footer.swig","hash":"e031914c98f082d918ece4c35fdd0a5be1c4e845","modified":1636023802187},{"_id":"themes/next/layout/_scripts/index.swig","hash":"1822eaf55bbb4bec88871c324fc18ad95580ccb4","modified":1636023802204},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"7b9e0f776a5be6c3f95bc7f394e1424ba02ba93b","modified":1636023802204},{"_id":"themes/next/layout/_partials/widgets.swig","hash":"5392dcbb504266f0f61d5b8219914068ef9cdc25","modified":1636023802203},{"_id":"themes/next/layout/_scripts/three.swig","hash":"6b092c6d882b2dfa5273e1b3f60b244cb7c29fcd","modified":1636023802209},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"2de77d533c91532a8a4052000244d0c1693370df","modified":1636023802195},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"244ca2d74ee0d497c87572c6a26b43c62a952673","modified":1636023802210},{"_id":"themes/next/layout/_scripts/pjax.swig","hash":"ccff5a773644d33ff22f6b45b6734f52b048f22b","modified":1636023802206},{"_id":"themes/next/layout/_third-party/index.swig","hash":"c6b63cbc80938e6e09578b8c67e01adf13a9e3bd","modified":1636023802220},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"269102fc5e46bd1ce75abdcce161f0570ae70e2f","modified":1636023802224},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"5ae5adcd6f63ed98b2071e4f7e5e38c4d7d24e1b","modified":1636023802224},{"_id":"themes/next/source/css/_mixins.styl","hash":"072a3fa473c19b20ccd7536a656cda044dbdae0a","modified":1636023802304},{"_id":"themes/next/source/css/_colors.styl","hash":"11aef31a8e76f0f332a274a8bfd4537b73d4f88f","modified":1636023802259},{"_id":"themes/next/scripts/events/index.js","hash":"5c355f10fe8c948a7f7cd28bd8120adb7595ebde","modified":1636023802237},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"28b0a7e843ec4365db1963646659a153753cd746","modified":1636023802214},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1636023802325},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1636023802325},{"_id":"themes/next/source/css/main.styl","hash":"87e36f17c45d68cfbadec90d4354b6151eb45f22","modified":1636037433358},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1636023802327},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1636023802326},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1636023802327},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1636023802328},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1636023802329},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1636023802332},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1636023802331},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1636023802329},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1636023802330},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1636023802332},{"_id":"themes/next/source/js/algolia-search.js","hash":"6a813410e33824d7acc65a369a2983912bb3420c","modified":1636023802334},{"_id":"themes/next/source/js/bookmark.js","hash":"9f05fd3672789311dc0cf5b37e40dc654cb04a2a","modified":1636023802335},{"_id":"themes/next/source/js/local-search.js","hash":"cfa6a0f3f9c2bc759ee507668a21f4e8f250f42a","modified":1636023802335},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"ad321db012cea520066deb0639335e9bc0dcc343","modified":1636023802245},{"_id":"themes/next/source/js/motion.js","hash":"d5aa1a08cdf3c8d1d8d550fb1801274cc41e5874","modified":1636023802336},{"_id":"themes/next/source/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1636023802333},{"_id":"themes/next/source/js/next-boot.js","hash":"250d8dcd6322e69e3fbadd0f3e37081c97b47c52","modified":1636023802336},{"_id":"themes/next/scripts/helpers/engine.js","hash":"eb6b8bbc1dce4846cd5e0fac0452dbff56d07b5d","modified":1636023802249},{"_id":"themes/next/source/lib/anime.min.js","hash":"960be51132134acd65c2017cc8a5d69cb419a0cd","modified":1636023802340},{"_id":"themes/next/scripts/filters/minify.js","hash":"21196a48cb127bf476ce598f25f24e8a53ef50c2","modified":1636023802247},{"_id":"themes/next/scripts/filters/locals.js","hash":"a5e7d05d3bd2ae6dcffad5a8ea0f72c6e55dbd02","modified":1636023802247},{"_id":"themes/next/scripts/filters/post.js","hash":"57f2d817578dd97e206942604365e936a49854de","modified":1636023802248},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"b8d7ddfa4baa9b8d6b9066a634aa81c6243beec9","modified":1636023802250},{"_id":"themes/next/scripts/helpers/font.js","hash":"8fb1c0fc745df28e20b96222974402aab6d13a79","modified":1636023802250},{"_id":"themes/next/scripts/filters/front-matter.js","hash":"305d03c1e45782988809298c3e3b3c5d5ee438aa","modified":1636023802246},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"4044129368d0e2811859a9661cad8ab47118bc32","modified":1636023802251},{"_id":"themes/next/scripts/tags/button.js","hash":"bb0e8abbc0a6d5b3a1a75a23976f2ac3075aab31","modified":1636023802252},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"840536754121e0da5968f5ad235f29200fc5d769","modified":1636023802253},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"e2d0184bc4a557e1017395b80ff46880078d8537","modified":1636023802254},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"93ccd3f99d3cb42674f29183c756df63acb5d7f8","modified":1636023802254},{"_id":"themes/next/scripts/tags/label.js","hash":"fc83f4e1be2c34e81cb79938f4f99973eba1ea60","modified":1636023802255},{"_id":"themes/next/scripts/tags/pdf.js","hash":"37b53661ad00a01a2ca7d2e4a5ad3a926073f8e2","modified":1636023802257},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"81134494ff0134c0dae1b3815caf6606fccd4e46","modified":1636023802255},{"_id":"themes/next/scripts/tags/video.js","hash":"944293fec96e568d9b09bc1280d5dbc9ee1bbd17","modified":1636023802258},{"_id":"themes/next/scripts/tags/note.js","hash":"1fdf4f95810fdb983bfd5ad4c4f13fedd4ea2f8d","modified":1636023802256},{"_id":"themes/next/source/js/utils.js","hash":"26a82e46fdcadc7c3c2c56a7267284b61a26f7f3","modified":1636023802339},{"_id":"themes/next/scripts/tags/tabs.js","hash":"c70a4a66fd0c28c98ccb6c5d5f398972e5574d28","modified":1636023802257},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"7d638e413f2548fc990c4a467dd03de6c81fc960","modified":1636023802188},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"0dd316f153c492c0a03bd0273d50fa322bc81f11","modified":1636023802191},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"91056a6c98cca63ff8cc6956e531ee3faf4b8ad9","modified":1636023802190},{"_id":"themes/next/layout/_partials/header/menu-item.swig","hash":"4baa86ca631168fc6388d27f4b1b501b40c877a8","modified":1636023802191},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"bed6cc2b48cf2655036ba39c9bae73a295228a4d","modified":1636023802192},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"90d3eaba6fbe69bee465ddd67c467fd2c0239dc4","modified":1636023802192},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"91c0addb33006619faa4c32e5d66874e25f1e9b3","modified":1636023802194},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"90cce9f407e9490756ba99580e3eb09f55b05eaa","modified":1636023802189},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"8d4e3dd0d3631ce0b21bc15c259f6ac886de631d","modified":1636023802194},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"98fd1f5df044f4534e1d4ca9ab092ba5761739a9","modified":1636023802200},{"_id":"themes/next/layout/_partials/post/post-footer.swig","hash":"ce712c110b5ce8aacba7a86b0558ff89700675c9","modified":1636023802198},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"a6c761d5193cb6f22e9422dbbcf209e05471b0ed","modified":1636023802201},{"_id":"themes/next/layout/_partials/post/post-followme.swig","hash":"d8f785c062c6b0763a778bd4a252e6f5fee0e432","modified":1636023802197},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"128f7d679bb4d53b29203d598d217f029a66dee7","modified":1636023802201},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"bc7b047a6246df07767373644b1637d91c3a88b1","modified":1636023802199},{"_id":"themes/next/layout/_partials/post/post-reward.swig","hash":"f349a226e5370075bb6924e60da8b0170c7cfcc1","modified":1636023802199},{"_id":"themes/next/layout/_partials/sidebar/site-overview.swig","hash":"7b2ef5db9615267a24b884388925de1e9b447c1f","modified":1636023802202},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"84adaadd83ce447fa9da2cff19006334c9fcbff9","modified":1636023802211},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"f2eb455c8bf13533427254f0c9b4b17b2498168b","modified":1636023802196},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"91c2cb900c76224c5814eeb842d1d5f517f9bf05","modified":1636023802213},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"34495d408e8467555afee489500b8aad98c52079","modified":1636023802207},{"_id":"themes/next/layout/_scripts/pages/schedule.swig","hash":"34c05e9d73b0f081db70990c296b6d6a0f8ea2ca","modified":1636023802205},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"b8819bd056f8a580c5556d4415836a906ed5d7a4","modified":1636023802212},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"0b44f400ec00d2b5add5ee96c11d22465c432376","modified":1636023802207},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"34495d408e8467555afee489500b8aad98c52079","modified":1636023802209},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"0b44f400ec00d2b5add5ee96c11d22465c432376","modified":1636023802208},{"_id":"themes/next/layout/_third-party/chat/tidio.swig","hash":"fb94ee487d75e484e59b7fba96e989f699ff8a83","modified":1636023802216},{"_id":"themes/next/layout/_third-party/chat/chatra.swig","hash":"2642e8aef5afbe23a2a76efdc955dab2ee04ed48","modified":1636023802215},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"9298e6d6c4a62a0862fc0f4060ed99779d7b68cb","modified":1636023802217},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"1b29b99fa921f12c25d3dc95facdf84ef7bb1b5c","modified":1636023802217},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"85b60e222712ca3b2c4dc2039de2dc36b8d82940","modified":1636023802213},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"a42f97eda3748583bac2253c47fe5dfa54f07b8f","modified":1636023802218},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"3d91899ca079e84d95087b882526d291e6f53918","modified":1636023802219},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"276f523e414d4aa7f350a8f2fd3df8a3d8ea9656","modified":1636023802222},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"fd726aad77a57b288f07d6998ec29291c67c7cbb","modified":1636023802225},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"59df21fcfe9d0ada8cee3188cb1075529c1c3eb8","modified":1636023802221},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"ae2707d6e47582bb470c075649ec7bad86a6d5a9","modified":1636023802220},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"58296a5c1883f26464c2a5ccf734c19f5fbf395a","modified":1636023802226},{"_id":"themes/next/layout/_third-party/statistics/cnzz-analytics.swig","hash":"53a0760c75d5aaabb3ce8e8aa8e003510d59807f","modified":1636023802228},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.swig","hash":"d2f0e4c598410ec33785abe302c7ea7492bb791a","modified":1636023802228},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"606ad14a29320157df9b8f33738282c51bb393d9","modified":1636023802219},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"1f34b2d3c753a3589ab6c462880bd4eb7df09914","modified":1636023802223},{"_id":"themes/next/layout/_third-party/search/swiftype.swig","hash":"aa6ab95b8b76611694613defb4bf25003d1b927f","modified":1636023802226},{"_id":"themes/next/layout/_third-party/tags/mermaid.swig","hash":"619338ddacf01e3df812e66a997e778f672f4726","modified":1636023802231},{"_id":"themes/next/layout/_third-party/statistics/firestore.swig","hash":"01d94354d07e72cad47100482068b6be69fcc033","modified":1636023802229},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.swig","hash":"c171ea94e9afbba97f06856904264da331559463","modified":1636023802230},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"c22b58af3327236ec54d5706501aa5a20e15012e","modified":1636023802322},{"_id":"themes/next/layout/_third-party/tags/pdf.swig","hash":"5a223b60406cee7438cfe3a5e41d1284425aa7a5","modified":1636023802232},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"583ff1e7a2ca889f1f54eb0ca793894466823c7c","modified":1636023802320},{"_id":"themes/next/layout/_third-party/statistics/index.swig","hash":"964cd6bac668cf6d211a2624fbef3948cfdece55","modified":1636023802230},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"5980abbbbeacd8541121f436fa414d24ad5e97c2","modified":1636023802321},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"4e33774b1fe6d0a51f3a428c54c5e600e83bf154","modified":1636037360969},{"_id":"themes/next/scripts/events/lib/config.js","hash":"aefe3b38a22bc155d485e39187f23e4f2ee5680a","modified":1636023802238},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"e73f697bb160b223fdde783237148be5f41c1d78","modified":1636023802240},{"_id":"themes/next/source/css/_variables/base.styl","hash":"ad680efdfb2f86546182bf3f59886efbcf3c1b2d","modified":1636037095270},{"_id":"themes/next/scripts/events/lib/injects-point.js","hash":"08496b71c9939718e7955704d219e44d7109247b","modified":1636023802239},{"_id":"themes/next/source/js/schemes/muse.js","hash":"a18559a9c332199efad0100cf84bb0c23fc0f17a","modified":1636023802337},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"2f22f48f7370470cef78561a47c2a47c78035385","modified":1636023802241},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"713056d33dbcd8e9748205c5680b456c21174f4e","modified":1636023802242},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"b85a6e2af1387fe64b51e7cd3e2da8616e6f5a3f","modified":1636023802338},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"3a80559df0b670ccb065ea9d3bb587d0b61be3a4","modified":1636023802243},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"0c3bea89d64bc12c1bbe6f208a83773c6fb5375a","modified":1636023802242},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"67cf90d9a2428c14eb113a64bdd213c22a019aef","modified":1636023802243},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1636023802346},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"323a47df6ded894944a2647db44556d6163e67c4","modified":1636023802244},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"851359f5ff90f733a9bd7fe677edbee8b8ac714c","modified":1636023802245},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1636023802345},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"a4f3153ac76a7ffdf6cc70f52f1b2cc218ed393e","modified":1636023802244},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"510a6f0ba7485dd54ce347cca890ab52c4957081","modified":1636023802261},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"c52648a7b09f9fe37858f5694fcc1ffc709ad147","modified":1636023802274},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"d17236df3b4d6def1e4e81133ef4729c390de3ac","modified":1636023802262},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"7a95c27762e1303bf06ee808c63f616cb192fcaf","modified":1636023802284},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"a2ee16cac29a82cfce26804c160286fcbee94161","modified":1636023802284},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"0534b329d279a6f255112b3305ff92c810f31724","modified":1636023802261},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5540c9259cb7895a5f10a289c7937e5470a7c134","modified":1636023802292},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"45f4badac6ec45cf24355f6157aece1d4d3f1134","modified":1636023802292},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"43045d115f8fe95732c446aa45bf1c97609ff2a5","modified":1636023802298},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"4b068d0d898f4e624937503f0e1428993050bd65","modified":1636023802293},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"b619f39e18398422e0ac4999d8f042a5eaebe9cd","modified":1636023802298},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"6d740699fb6a7640647a8fd77c4ea4992d8d6437","modified":1636023802297},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"f317d2e3886e94f5fbb8781c2e68edd19669ff58","modified":1636023802299},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"e342b8f8e11a3a6aa5a029912c9778c25bf5d135","modified":1636023802306},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"b9e87d32da24264bda247c1526afe140c858b0ef","modified":1636023802307},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"20e0e3e3eba384930c022e21511214d244b4c9e7","modified":1636023802304},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"12b265f82840f27112ca2b1be497677f20f87545","modified":1636023802307},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"716e8b0f056bf6393e6bc6969ac84598ab8e7a6f","modified":1636023802308},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"8674bd88df076a1dfe4023ed6750ded1f5b00223","modified":1636023802310},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"c5142739e01e9f25c8b32b2209af85c787bb2b42","modified":1636023802309},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"49c76bc723d3952abb613d9d68398ed7305da999","modified":1636023802311},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"e1c29b81a32273a0dedd926cda199a71aea72624","modified":1636023802309},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"25c2a7930da14f023329df20f38df2728057fb4d","modified":1636023802313},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"2d3e05015796a790abd9d68957a5c698c0c9f9b6","modified":1636023802313},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"558794fced306339b98dc2b0ee7f0576802f1355","modified":1636023802315},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"4b7f057dbb53efd7cbe7eac7835a793ab3cbb135","modified":1636023802312},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"9898323ee5a7ac2a5d4f633c653112280beb2643","modified":1636023802312},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5de34e1d8a290751641ae456c942410852d5e809","modified":1636023802315},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"dc9318992ce2eb086ebaa2fe56b325e56d24098b","modified":1636023802317},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"b69ac38b9da8c9c1b7de696fdeea7f9d7705213a","modified":1636023802317},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"0a9f0d9eb042595502d200fb8c65efb0e6c89aa9","modified":1636023802316},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"25c2a7930da14f023329df20f38df2728057fb4d","modified":1636023802318},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1636023802343},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","hash":"82e34d28f8a1169b20b60101d5bb0446deba3514","modified":1636023802342},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"236a039b0900f4267de566b46f62314ad967d30f","modified":1636023802263},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"18edddb2ffb3f85a68e4367f81e06c461e07bc25","modified":1636023802263},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"6cf78a379bb656cc0abb4ab80fcae60152ce41ad","modified":1636023802264},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"97974c231b4659b8aa5e9321c4d54db5c816d0db","modified":1636023802265},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"b87f4a06c0db893df4f756f24be182e1a4751f24","modified":1636023802275},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"7eeb22c5696f8e0c95161dc57703973cf81c8c12","modified":1636023802279},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"f6f05f02d50f742c84ee5122016c0563a8bb2cf9","modified":1636023802265},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"d83102771df652769e51ddfd041cf5f4ca1a041d","modified":1636023802275},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"8ed7a9d5dfac592de703421b543978095129aa5b","modified":1636023802276},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1f6b0d3ab227697ca115e57fd61122ea7950e19d","modified":1636023802277},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"9af620eba5ccceea21a0e3bc69f6f1fa7637c2f3","modified":1636023802267},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"bad99f4cccb93b3cefe990a2c85124e60698d32e","modified":1636023802277},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"70b3eb9d36543ab92796ac163544e9cf51b7c1e6","modified":1636023802267},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"a52f8cae599099231866298ed831fdf76c9b6717","modified":1636023802266},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"0dfb97703a519d9438f64f9e41ab1dd37381f733","modified":1636023802269},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"97dec98d0403097d66822f1c90b50b2890c84698","modified":1636023802268},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"57b9a179675f1536e017cba457b6ac575e397c4f","modified":1636023802268},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"93ba8172c0d2c37d738e6dbd44fcd5a2e23b92f3","modified":1636023802269},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"09dda2667628d1f91b2e37d8fc6df1413f961b64","modified":1636023802272},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"2c24829d95c742eb9e8316ebf2fbe9f2c168b59a","modified":1636023802270},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5cc9e7394c927065c688cba5edd6e0a27587f1d8","modified":1636023802272},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"66fc406796b6efe6cea76550573b7a632112406a","modified":1636023802271},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"b4f4bae437d4f994af93cf142494ffcd86bae46b","modified":1636023802280},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"fcd64c23d17775b3635325f6758b648d932e79b5","modified":1636023802273},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"b266d2ce5e2b117be01537889e839a69004dc0bb","modified":1636023802273},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"b31c86d1a4f89837f9187bed646bda96b2cd286c","modified":1636023802281},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"300058ca12e81013e77ba01fe66ac210525768b6","modified":1636023802281},{"_id":"themes/next/source/css/_common/outline/header/headerband.styl","hash":"6d5f26646e2914474f295de8bf6dc327d4acd529","modified":1636023802282},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"b8c816fba0a9b4a35fbae03ba5b1b2da96ba2687","modified":1636023802283},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"7a3a56b10ab714c0e2ed240d0939deeecdcad167","modified":1636023802282},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"3d16ac0f4ccaeed868c246d4d49bde543d1f62cb","modified":1636023802283},{"_id":"themes/next/source/css/_common/scaffolding/highlight/diff.styl","hash":"83bd737f663a8461e66985af8ddbfc0a731fc939","modified":1636023802295},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"49722d555a2edb18094bb2cb3d7336dd72051b93","modified":1636023802285},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"4079e616fbf36112dec0674c1e0713d1d9769068","modified":1636023802294},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"80488259271bcfe38031f4c2e902463daba9336b","modified":1636023802296},{"_id":"themes/next/source/css/_common/scaffolding/highlight/theme.styl","hash":"c911045b2ce9a66e38d9dd30c7ed078abbc10cbf","modified":1636023802296},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"096f908c08ce553e482aadfd3e767a0145191093","modified":1636023802287},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"525242ce9e912c4adfe5134347c67dbdb9e98e3d","modified":1636023802287},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"12f7eaf6b56624cbc411528562d6bb848ff97039","modified":1636023802288},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"357f825f0a649b2e28cba1481d4c9a0cb402e43a","modified":1636023802286},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"098b4bdf49c7300490f959386d5d1185a32543f6","modified":1636023802290},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"b11b04737a1a0fea3bd9f0081d96ee6c015358d4","modified":1636023802289},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"fa0a2ea57b7b4ce75b5d18c264af2d92ea3192f9","modified":1636023802289},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"ceacfa6218f6084c71a230b086e5d2708d29927e","modified":1636023802300},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"aca7bb220fc14ef2a8f96282d2a95a96a9238d46","modified":1636023802301},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"8b7aafb911850c73074cdb6cc87abe4ac8c12e99","modified":1636023802301},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"67a1fcb33535122d41acd24f1f49cf02c89b88fa","modified":1636023802291},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"5d540f683018745a5ed1d6f635df28ea610c1244","modified":1636023802290},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"03a5bcecc0b12231462ef6ffe432fa77ee71beff","modified":1636023802302},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"51d46fa3c7c6b691c61a2c2b0ac005c97cfbf72b","modified":1636023802303},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"adaf0f580fccf4158169eeaf534a18005b39a760","modified":1636023802302},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"3256e39f281f06751a1c0145d9806a0e56d68170","modified":1636023802303},{"_id":"themes/next/source/images/touxiang.JPG","hash":"df82dce443427f210a2fd3200ac149025c638ea4","modified":1636036374721},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1636023802343},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1636023802344},{"_id":"themes/next/source/images/bg.jpg","hash":"4d98578c225d06796255dc611acd754dc557a861","modified":1636039544642},{"_id":"public/archives/index.html","hash":"1f75016febd168cdb4197e3f74ec23d72ea33fe3","modified":1636091003213},{"_id":"public/archives/2021/index.html","hash":"b0174c7d4e6e7ad436c2ce206f75b656efe49182","modified":1636091003213},{"_id":"public/archives/2021/04/index.html","hash":"43b95ff55ad713aa7621c560279ace166c187a07","modified":1636090943588},{"_id":"public/archives/2021/10/index.html","hash":"bc5378ba47369772dfe67e33e9bb3113e3b3b0c3","modified":1636090943588},{"_id":"public/archives/2021/11/index.html","hash":"42c5fc86f252b8d80023a79936e71acf9e495aff","modified":1636091003213},{"_id":"public/2021/11/05/MIT6.S081 Lab9/index.html","hash":"7cb16f0d098341c2c2054c8229e98e82db97579e","modified":1636091105285},{"_id":"public/2021/10/14/MIT6.S081 Lab8/index.html","hash":"8bf81dbdac3e693a1e54ebcd18e5c92da3e10fb1","modified":1636091003213},{"_id":"public/2021/10/12/MIT6.S081 Lab7/index.html","hash":"400406dd1139ff3144e465ae3b3e09ec4ab677c5","modified":1636090943588},{"_id":"public/2021/10/09/MIT6.S081 Lab6/index.html","hash":"650af396ca140ea477faf5b720695632e70d31b7","modified":1636090943588},{"_id":"public/2021/04/24/MIT6.S081 Lab5/index.html","hash":"71c5f8cbe457283ff8a2706f5706f31444d3d317","modified":1636090943588},{"_id":"public/2021/04/16/MIT6.S081 Lab4/index.html","hash":"3c6133bbf37b34f39a63072c2c3c93870245e605","modified":1636090943588},{"_id":"public/2021/04/03/MIT6.S081 Lab3/index.html","hash":"976cca7ea551a10f694028b2eeff9e76696e07b7","modified":1636090943588},{"_id":"public/tags/6-S081/index.html","hash":"73c742a683088f01be16ad6a4a1e2cd2971eb495","modified":1636091003213},{"_id":"public/index.html","hash":"463db140314b0a634cb8f16ad9273f34c8e47257","modified":1636091105285},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1636090943588},{"_id":"public/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1636090943588},{"_id":"public/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1636090943588},{"_id":"public/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1636090943588},{"_id":"public/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1636090943588},{"_id":"public/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1636090943588},{"_id":"public/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1636090943588},{"_id":"public/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1636090943588},{"_id":"public/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1636090943588},{"_id":"public/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1636090943588},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1636090943588},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1636090943588},{"_id":"public/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1636090943588},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1636090943588},{"_id":"public/images/touxiang.JPG","hash":"df82dce443427f210a2fd3200ac149025c638ea4","modified":1636090943588},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1636090943588},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1636090943588},{"_id":"public/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1636090943588},{"_id":"public/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1636090943588},{"_id":"public/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1636090943588},{"_id":"public/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1636090943588},{"_id":"public/js/utils.js","hash":"730cca7f164eaf258661a61ff3f769851ff1e5da","modified":1636090943588},{"_id":"public/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1636090943588},{"_id":"public/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1636090943588},{"_id":"public/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1636090943588},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1636090943588},{"_id":"public/css/main.css","hash":"4da3833ce2b5ba9ae2dfa5abcf0fa8bb0059efe3","modified":1636090943588},{"_id":"public/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1636090943588},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1636090943588},{"_id":"public/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1636090943588},{"_id":"public/images/bg.jpg","hash":"4d98578c225d06796255dc611acd754dc557a861","modified":1636090943588},{"_id":"source/images/1.png","hash":"f523f6a0dbcd669796e0fca215a48ec148fc4d6c","modified":1636091092794},{"_id":"public/images/1.png","hash":"f523f6a0dbcd669796e0fca215a48ec148fc4d6c","modified":1636091105285}],"Category":[],"Data":[{"_id":"styles","data":"body {\n  background: url(\"/images/bg.jpg\");\n  background-repeat: no-repeat;\n  background-size: cover;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.9;\n}\n.header-inner {\n  background: rgba(255,255,255,0.85);\n}\n.popup {\n  opacity: 0.85;\n}\n.sidebar {\n  background-color: transparent;\n}\n"},{"_id":"variables","data":""}],"Page":[],"Post":[{"title":"MIT6.S081 Lab4 Traps","date":"2021-04-16T04:00:00.000Z","_content":"\n## 实验前准备\n\n> 阅读trap.c，trampoline.s\n\n## RISC-V assembly\n\n回答几个问题，阅读call.c和它的汇编代码理解函数的calling conventions即可\n\n> call.c\n\n```c\n#include \"kernel/param.h\"\n#include \"kernel/types.h\"\n#include \"kernel/stat.h\"\n#include \"user/user.h\"\n\nint g(int x) {\n  return x+3;\n}\n\nint f(int x) {\n  return g(x);\n}\n\nvoid main(void) {\n  printf(\"%d %d\\n\", f(8)+1, 13);\n  exit(0);\n}\n```\n\n> call.asm\n\n```jasmin\nint g(int x) {\n   0:\t1141                \taddi\tsp,sp,-16\n   2:\te422                \tsd\ts0,8(sp)\n   4:\t0800                \taddi\ts0,sp,16\n  return x+3;\n}\n   6:\t250d                \taddiw\ta0,a0,3\n   8:\t6422                \tld\ts0,8(sp)\n   a:\t0141                \taddi\tsp,sp,16\n   c:\t8082                \tret\n\n000000000000000e <f>:\n\nint f(int x) {\n   e:\t1141                \taddi\tsp,sp,-16\n  10:\te422                \tsd\ts0,8(sp)\n  12:\t0800                \taddi\ts0,sp,16\n  return g(x);\n}\n  14:\t250d                \taddiw\ta0,a0,3\n  16:\t6422                \tld\ts0,8(sp)\n  18:\t0141                \taddi\tsp,sp,16\n  1a:\t8082                \tret\n\n000000000000001c <main>:\n\nvoid main(void) {\n  1c:\t1141                \taddi\tsp,sp,-16\n  1e:\te406                \tsd\tra,8(sp)\n  20:\te022                \tsd\ts0,0(sp)\n  22:\t0800                \taddi\ts0,sp,16\n  printf(\"%d %d\\n\", f(8)+1, 13);\n  24:\t4635                \tli\ta2,13\n  26:\t45b1                \tli\ta1,12\n  28:\t00000517          \tauipc\ta0,0x0\n  2c:\t7b850513          \taddi\ta0,a0,1976 # 7e0 <malloc+0xea>\n  30:\t00000097          \tauipc\tra,0x0\n  34:\t608080e7          \tjalr\t1544(ra) # 638 <printf>\n  exit(0);\n  38:\t4501                \tli\ta0,0\n  3a:\t00000097          \tauipc\tra,0x0\n  3e:\t276080e7          \tjalr\t630(ra) # 2b0 <exit>\n```\n\n> Q1.哪个寄存器保存函数参数，例如哪个保存参数13?\n\nA：a0，a1，a2...保存传入的参数，13保存在a2中\n\n> Q2.哪里调用了函数f和g？\n\nA：没有调用，编译器把两个函数内联了。\n\n> Q3.函数printf的地址？\n\nA：观察汇编代码有\n\n```text\n  30:\t00000097          \tauipc\tra,0x0\n  34:\t608080e7          \tjalr\t1544(ra) # 638 <printf>\n```\n\nauipc的作用是把立即数左移12位，低12位补0，和pc相加赋给指定寄存器。这里立即数是0，指定寄存器是ra，即ra=pc=0x30=48。jalr作用是跳转到立即数+指定寄存器处并且把ra的值+8。因此jalr会跳转到1544+48=1592=0x638处，观察汇编代码发现：\n\n```text\n0000000000000638 <printf>:\n\nvoid\nprintf(const char *fmt, ...)\n{\n 638:\t711d                \taddi\tsp,sp,-96\n 63a:\tec06                \tsd\tra,24(sp)\n 63c:\te822                \tsd\ts0,16(sp)\n 63e:\t1000                \taddi\ts0,sp,32\n 640:\te40c                \tsd\ta1,8(s0)\n 642:\te810                \tsd\ta2,16(s0)\n```\n\n确实在0x638\n\n> Q4.在printf之后ra的值？\n\nA.如上述，为0x30+8=0x38，用gdb也可以看到\n\n![img](https://pic1.zhimg.com/80/v2-7f3932002f682a177fe484725656a190_720w.jpg)\n\n执行完jalr后ra从0x30变为0x38\n\n> Q5.运行以下代码，输出是什么？这个输出基于riscv是小端保存，如果是大端保存，怎么设置i才能获得相同输出？\n\n```c\nunsigned int i = 0x00646c72;\nprintf(\"H%x Wo%s\", 57616, &i);\n```\n\nA：输出为HE110 World\n\n因为riscv为小端存储，从&i开始字节分别为0x72，0x6c，0x64， 0x00.分别对应'r','l','d'，'0'的ascii码，0x00作为字符串结束标志。\n\n57616=0xE110\n\ni应该设置为0x726c6400\n\n> Q6.运行printf(\"x=%d y=%d\", 3);在y=后面输出什么？为什么会这样？\n\nA：输出y=1。取决于寄存器a2（第3个参数）的值。\n\n\n\n## Backtrace\n\n要求完成一个backtrace函数，在系统调用sys_sleep里调用这个函数，使其从下往上逐一输出内核栈各个stackframe的ra的值。\n\n主要是弄懂调用函数的stack frame的结构，如下图：\n\n![img](https://pic4.zhimg.com/80/v2-4351f298147c4da1f1b72aef8db25093_720w.jpg)\n\nsp指向当前frame底部（栈是从上往下增长），fp指向当前frame顶部。栈顶部保存了函数返回地址ra以及上个frame的fp。具体可以看任意一个函数的汇编代码：\n\n![img](https://pic4.zhimg.com/80/v2-03e9232fd2cdaa8b6cae56499e39ac6b_720w.jpg)\n\n一个函数在开始执行时会把ra，s0（即fp）的值压栈，然后保存一些寄存器的值，如果参数过多也会把参数保存在栈里，还会保存局部变量。\n\nbacktrace的实现比较简单，模拟函数返回的步骤，输出ra（fp-8），然后找到上一个frame的fp（fp-16），以此类推。注意要求只输出内核态的frame信息，fp如果跳出内核栈的范围到了用户空间循环就要停止了。\n\n> backtrace()\n\n```c\nvoid backtrace(void) {\n  uint64 fp = r_fp();\n  struct proc *p = myproc();\n  \n  while (1) {\n    uint64 *ra_addr = (uint64*)(fp - 8);\n    uint64 *fp_addr = (uint64*)(fp - 16);\n    fp = *fp_addr;\n    //printf(\"fp=%p\\n\", *fp_addr);\n    if (PGROUNDUP(fp) != p->kstack+PGSIZE) \n      break;\n    printf(\"%p\\n\", *ra_addr);\n  }\n  return ;\n}\n```\n\n## Alarm\n\n实现系统调用sigalarm(n, fn)，执行这个系统调用之后，用户程序在执行的时候能够每隔n个ticks执行一次用户态函数fn。\n\nriscv收到timer trap的情况有两种，在用户态收到trap和在内核态收到trap，分别会执行usertrap和kerneltrap处理函数。实验要求是在用户态收到n个ticks后执行函数，不用修改kerneltrap的代码。\n\n实验分两个步骤。test0要求程序执行了fn即可，不用管控制流有没有正常返回以及寄存器的值是否变动，test1和test2要求程序在执行fn后能够通过编写的系统调用sigreturn返回到产生trap的用户代码处，并且程序上下文没有改变。\n\n> proc.h\n> 给struct添加几个部分，包括需要执行的用户态函数p->handler，执行函数的间隔p->interval，距离上一次执行handler后已经产生的tick数p->tick（在allocproc处初始化为0）。\n> 然后是用户态产生trap时的所有寄存器的值。由于执行handler时可能改变某些寄存器，再返回到原先的代码处时需要恢复现场。\n> p->flag用于判断当前时钟中断是否是在执行handler时产生的，如果是，则不需要执行handler。\n\n```as3\nstruct proc {\n  struct spinlock lock;\n\n  // p->lock must be held when using these:\n  enum procstate state;        // Process state\n  struct proc *parent;         // Parent process\n  void *chan;                  // If non-zero, sleeping on chan\n  int killed;                  // If non-zero, have been killed\n  int xstate;                  // Exit status to be returned to parent's wait\n  int pid;                     // Process ID\n\n  // these are private to the process, so p->lock need not be held.\n  uint64 kstack;               // Virtual address of kernel stack\n  uint64 sz;                   // Size of process memory (bytes)\n  pagetable_t pagetable;       // User page table\n  struct trapframe *trapframe; // data page for trampoline.S\n  struct context context;      // swtch() here to run process\n  struct file *ofile[NOFILE];  // Open files\n  struct inode *cwd;           // Current directory\n  char name[16];               // Process name (debugging)\n  int interval;\n  uint64 handler;\n  int tick;\n  uint64 u_epc;\n  uint64 u_ra;\n  uint64 u_sp;\n  uint64 u_gp;\n  uint64 u_tp;\n  uint64 u_t0;\n  uint64 u_t1;\n  uint64 u_t2;\n  uint64 u_s0;\n  uint64 u_s1;\n  uint64 u_a0;\n  uint64 u_a1;\n  uint64 u_a2;\n  uint64 u_a3;\n  uint64 u_a4;\n  uint64 u_a5;\n  uint64 u_a6;\n  uint64 u_a7;\n  uint64 u_s2;\n  uint64 u_s3;\n  uint64 u_s4;\n  uint64 u_s5;\n  uint64 u_s6;\n  uint64 u_s7;\n  uint64 u_s8;\n  uint64 u_s9;\n  uint64 u_s10;\n  uint64 u_s11;\n  uint64 u_t3;\n  uint64 u_t4;\n  uint64 u_t5;\n  uint64 u_t6;\n  uint64 flag;\n};\n```\n\n> 在kernel目录新建alarm.c用于编写所需的两个系统调用。\n> sigalarm在调用时设置好proc的inteval以及handler的值，注意传入的函数地址也可以为0（因为在用户空间，代码段从虚拟地址0开始）。\n\n```c\nuint64 sys_sigalarm(void) {\n    int itv;\n    uint64 handler;\n    struct proc* p = myproc();\n    argint(0, &itv);\n    argaddr(1, &handler);\n    p->interval = itv;\n    p->handler = handler;\n    p->flag = 0;\n    return 0;\n}\n```\n\n> usertrap()：\n> 在每次产生时钟中断时p->tick加1，然后判断是否等于intervel。如果不等于就当成普通的时钟中断处理，如果等于并且当前用户态代码不在执行handler（flag==0）则执行以下操作：\n> 把所有寄存器的值保存，把trampframe->epc的值设置为handler，这样一来在usertrapret时就会把epc设置为handler的第一句代码处，userret（trampoline.S）时执行sret就会返回到handler，从而执行handler。记住把flag设为1.\n\n```c\nif(which_dev == 2) {\n    //printf(\"ticks=%d\\n\", ticks);\n    p->tick++;\n    if (p->tick == p->interval) {\n      if (p->flag == 0) {\n        p->u_epc = p->trapframe->epc;\n        p->u_ra = p->trapframe->ra;\n        p->u_sp = p->trapframe->sp;\n        p->u_gp = p->trapframe->gp;\n        p->u_tp = p->trapframe->tp;\n        p->u_t0 = p->trapframe->t0;\n        p->u_t1 = p->trapframe->t1;\n        p->u_t2 = p->trapframe->t2;\n        p->u_s0 = p->trapframe->s0;\n        p->u_s1 = p->trapframe->s1;\n        p->u_a0 = p->trapframe->a0;\n        p->u_a1 = p->trapframe->a1;\n        p->u_a2 = p->trapframe->a2;\n        p->u_a3 = p->trapframe->a3;\n        p->u_a4 = p->trapframe->a4;\n        p->u_a5 = p->trapframe->a5;\n        p->u_a6 = p->trapframe->a6;\n        p->u_a7 = p->trapframe->a7;\n        p->u_s2 = p->trapframe->s2;\n        p->u_s3 = p->trapframe->s3;\n        p->u_s4 = p->trapframe->s4;\n        p->u_s5 = p->trapframe->s5;\n        p->u_s6 = p->trapframe->s6;\n        p->u_s7 = p->trapframe->s7;\n        p->u_s8 = p->trapframe->s8;\n        p->u_s9 = p->trapframe->s9;\n        p->u_s10 = p->trapframe->s10;\n        p->u_s11 = p->trapframe->s11;\n        p->u_t3 = p->trapframe->t3;\n        p->u_t4 = p->trapframe->t4;\n        p->u_t5 = p->trapframe->t5;\n        p->u_t6 = p->trapframe->t6;\n      \n        p->trapframe->epc = (uint64)p->handler;\n        p->flag = 1;\n      }\n      p->tick = 0;\n    }\n    yield();\n  }\n```\n\n> sigreturn()：在handler最后调用，保证控制流返回到产生trap的那句用户态代码处。\n> 把trapframe->epc设置为time trap时保存的epc值，这样保证返回到正确的代码处。\n> 恢复所有保存的寄存器。\n> handler里也会执行系统调用从而陷入内核态，trapframe会重新进行保存，所以不能保证handler函数的执行过程中进程的trampframe不会产生改变，但p->u_只有在时钟中断时并且tick=interval时（即进入handler之前）才会进行修改，因此可以保证返回到正确的上下文。\n\n```c\nuint64 sys_sigreturn(void) {\n    struct proc* p = myproc();\n    p->trapframe->epc = p->u_epc;\n    p->trapframe->ra = p->u_ra;\n    p->trapframe->sp = p->u_sp;\n    p->trapframe->gp = p->u_gp;\n    p->trapframe->tp = p->u_tp;\n    p->trapframe->t0 = p->u_t0;\n    p->trapframe->t1 = p->u_t1;\n    p->trapframe->t2 = p->u_t2;\n    p->trapframe->s0 = p->u_s0;\n    p->trapframe->s1 = p->u_s1;\n    p->trapframe->a0 = p->u_a0;\n    p->trapframe->a1 = p->u_a1;\n    p->trapframe->a2 = p->u_a2;\n    p->trapframe->a3 = p->u_a3;\n    p->trapframe->a4 = p->u_a4;\n    p->trapframe->a5 = p->u_a5;\n    p->trapframe->a6 = p->u_a6;\n    p->trapframe->a7 = p->u_a7;\n    p->trapframe->s2 = p->u_s2;\n    p->trapframe->s3 = p->u_s3;\n    p->trapframe->s4 = p->u_s4;\n    p->trapframe->s5 = p->u_s5;\n    p->trapframe->s6 = p->u_s6;\n    p->trapframe->s7 = p->u_s7;\n    p->trapframe->s8 = p->u_s8;\n    p->trapframe->s9 = p->u_s9;\n    p->trapframe->s10 = p->u_s10;\n    p->trapframe->s11 = p->u_s11;\n    p->trapframe->t3 = p->u_t3;\n    p->trapframe->t4 = p->u_t4;\n    p->trapframe->t5 = p->u_t5;\n    p->trapframe->t6 = p->u_t6;\n    p->flag = 0;\n    return 0;\n}\n```\n\n这是部分核心代码，其他的就是把sigalarm和sigreturn注册成系统调用，编写makefile等，不再赘述。","source":"_posts/MIT6.S081 Lab4.md","raw":"---\ntitle: MIT6.S081 Lab4 traps\ndate: 2021-04-16 12:00:00\ntags: 6.S081\n---\n\n## 实验前准备\n\n> 阅读trap.c，trampoline.s\n\n## RISC-V assembly\n\n回答几个问题，阅读call.c和它的汇编代码理解函数的calling conventions即可\n\n> call.c\n\n```c\n#include \"kernel/param.h\"\n#include \"kernel/types.h\"\n#include \"kernel/stat.h\"\n#include \"user/user.h\"\n\nint g(int x) {\n  return x+3;\n}\n\nint f(int x) {\n  return g(x);\n}\n\nvoid main(void) {\n  printf(\"%d %d\\n\", f(8)+1, 13);\n  exit(0);\n}\n```\n\n> call.asm\n\n```jasmin\nint g(int x) {\n   0:\t1141                \taddi\tsp,sp,-16\n   2:\te422                \tsd\ts0,8(sp)\n   4:\t0800                \taddi\ts0,sp,16\n  return x+3;\n}\n   6:\t250d                \taddiw\ta0,a0,3\n   8:\t6422                \tld\ts0,8(sp)\n   a:\t0141                \taddi\tsp,sp,16\n   c:\t8082                \tret\n\n000000000000000e <f>:\n\nint f(int x) {\n   e:\t1141                \taddi\tsp,sp,-16\n  10:\te422                \tsd\ts0,8(sp)\n  12:\t0800                \taddi\ts0,sp,16\n  return g(x);\n}\n  14:\t250d                \taddiw\ta0,a0,3\n  16:\t6422                \tld\ts0,8(sp)\n  18:\t0141                \taddi\tsp,sp,16\n  1a:\t8082                \tret\n\n000000000000001c <main>:\n\nvoid main(void) {\n  1c:\t1141                \taddi\tsp,sp,-16\n  1e:\te406                \tsd\tra,8(sp)\n  20:\te022                \tsd\ts0,0(sp)\n  22:\t0800                \taddi\ts0,sp,16\n  printf(\"%d %d\\n\", f(8)+1, 13);\n  24:\t4635                \tli\ta2,13\n  26:\t45b1                \tli\ta1,12\n  28:\t00000517          \tauipc\ta0,0x0\n  2c:\t7b850513          \taddi\ta0,a0,1976 # 7e0 <malloc+0xea>\n  30:\t00000097          \tauipc\tra,0x0\n  34:\t608080e7          \tjalr\t1544(ra) # 638 <printf>\n  exit(0);\n  38:\t4501                \tli\ta0,0\n  3a:\t00000097          \tauipc\tra,0x0\n  3e:\t276080e7          \tjalr\t630(ra) # 2b0 <exit>\n```\n\n> Q1.哪个寄存器保存函数参数，例如哪个保存参数13?\n\nA：a0，a1，a2...保存传入的参数，13保存在a2中\n\n> Q2.哪里调用了函数f和g？\n\nA：没有调用，编译器把两个函数内联了。\n\n> Q3.函数printf的地址？\n\nA：观察汇编代码有\n\n```text\n  30:\t00000097          \tauipc\tra,0x0\n  34:\t608080e7          \tjalr\t1544(ra) # 638 <printf>\n```\n\nauipc的作用是把立即数左移12位，低12位补0，和pc相加赋给指定寄存器。这里立即数是0，指定寄存器是ra，即ra=pc=0x30=48。jalr作用是跳转到立即数+指定寄存器处并且把ra的值+8。因此jalr会跳转到1544+48=1592=0x638处，观察汇编代码发现：\n\n```text\n0000000000000638 <printf>:\n\nvoid\nprintf(const char *fmt, ...)\n{\n 638:\t711d                \taddi\tsp,sp,-96\n 63a:\tec06                \tsd\tra,24(sp)\n 63c:\te822                \tsd\ts0,16(sp)\n 63e:\t1000                \taddi\ts0,sp,32\n 640:\te40c                \tsd\ta1,8(s0)\n 642:\te810                \tsd\ta2,16(s0)\n```\n\n确实在0x638\n\n> Q4.在printf之后ra的值？\n\nA.如上述，为0x30+8=0x38，用gdb也可以看到\n\n![img](https://pic1.zhimg.com/80/v2-7f3932002f682a177fe484725656a190_720w.jpg)\n\n执行完jalr后ra从0x30变为0x38\n\n> Q5.运行以下代码，输出是什么？这个输出基于riscv是小端保存，如果是大端保存，怎么设置i才能获得相同输出？\n\n```c\nunsigned int i = 0x00646c72;\nprintf(\"H%x Wo%s\", 57616, &i);\n```\n\nA：输出为HE110 World\n\n因为riscv为小端存储，从&i开始字节分别为0x72，0x6c，0x64， 0x00.分别对应'r','l','d'，'0'的ascii码，0x00作为字符串结束标志。\n\n57616=0xE110\n\ni应该设置为0x726c6400\n\n> Q6.运行printf(\"x=%d y=%d\", 3);在y=后面输出什么？为什么会这样？\n\nA：输出y=1。取决于寄存器a2（第3个参数）的值。\n\n\n\n## Backtrace\n\n要求完成一个backtrace函数，在系统调用sys_sleep里调用这个函数，使其从下往上逐一输出内核栈各个stackframe的ra的值。\n\n主要是弄懂调用函数的stack frame的结构，如下图：\n\n![img](https://pic4.zhimg.com/80/v2-4351f298147c4da1f1b72aef8db25093_720w.jpg)\n\nsp指向当前frame底部（栈是从上往下增长），fp指向当前frame顶部。栈顶部保存了函数返回地址ra以及上个frame的fp。具体可以看任意一个函数的汇编代码：\n\n![img](https://pic4.zhimg.com/80/v2-03e9232fd2cdaa8b6cae56499e39ac6b_720w.jpg)\n\n一个函数在开始执行时会把ra，s0（即fp）的值压栈，然后保存一些寄存器的值，如果参数过多也会把参数保存在栈里，还会保存局部变量。\n\nbacktrace的实现比较简单，模拟函数返回的步骤，输出ra（fp-8），然后找到上一个frame的fp（fp-16），以此类推。注意要求只输出内核态的frame信息，fp如果跳出内核栈的范围到了用户空间循环就要停止了。\n\n> backtrace()\n\n```c\nvoid backtrace(void) {\n  uint64 fp = r_fp();\n  struct proc *p = myproc();\n  \n  while (1) {\n    uint64 *ra_addr = (uint64*)(fp - 8);\n    uint64 *fp_addr = (uint64*)(fp - 16);\n    fp = *fp_addr;\n    //printf(\"fp=%p\\n\", *fp_addr);\n    if (PGROUNDUP(fp) != p->kstack+PGSIZE) \n      break;\n    printf(\"%p\\n\", *ra_addr);\n  }\n  return ;\n}\n```\n\n## Alarm\n\n实现系统调用sigalarm(n, fn)，执行这个系统调用之后，用户程序在执行的时候能够每隔n个ticks执行一次用户态函数fn。\n\nriscv收到timer trap的情况有两种，在用户态收到trap和在内核态收到trap，分别会执行usertrap和kerneltrap处理函数。实验要求是在用户态收到n个ticks后执行函数，不用修改kerneltrap的代码。\n\n实验分两个步骤。test0要求程序执行了fn即可，不用管控制流有没有正常返回以及寄存器的值是否变动，test1和test2要求程序在执行fn后能够通过编写的系统调用sigreturn返回到产生trap的用户代码处，并且程序上下文没有改变。\n\n> proc.h\n> 给struct添加几个部分，包括需要执行的用户态函数p->handler，执行函数的间隔p->interval，距离上一次执行handler后已经产生的tick数p->tick（在allocproc处初始化为0）。\n> 然后是用户态产生trap时的所有寄存器的值。由于执行handler时可能改变某些寄存器，再返回到原先的代码处时需要恢复现场。\n> p->flag用于判断当前时钟中断是否是在执行handler时产生的，如果是，则不需要执行handler。\n\n```as3\nstruct proc {\n  struct spinlock lock;\n\n  // p->lock must be held when using these:\n  enum procstate state;        // Process state\n  struct proc *parent;         // Parent process\n  void *chan;                  // If non-zero, sleeping on chan\n  int killed;                  // If non-zero, have been killed\n  int xstate;                  // Exit status to be returned to parent's wait\n  int pid;                     // Process ID\n\n  // these are private to the process, so p->lock need not be held.\n  uint64 kstack;               // Virtual address of kernel stack\n  uint64 sz;                   // Size of process memory (bytes)\n  pagetable_t pagetable;       // User page table\n  struct trapframe *trapframe; // data page for trampoline.S\n  struct context context;      // swtch() here to run process\n  struct file *ofile[NOFILE];  // Open files\n  struct inode *cwd;           // Current directory\n  char name[16];               // Process name (debugging)\n  int interval;\n  uint64 handler;\n  int tick;\n  uint64 u_epc;\n  uint64 u_ra;\n  uint64 u_sp;\n  uint64 u_gp;\n  uint64 u_tp;\n  uint64 u_t0;\n  uint64 u_t1;\n  uint64 u_t2;\n  uint64 u_s0;\n  uint64 u_s1;\n  uint64 u_a0;\n  uint64 u_a1;\n  uint64 u_a2;\n  uint64 u_a3;\n  uint64 u_a4;\n  uint64 u_a5;\n  uint64 u_a6;\n  uint64 u_a7;\n  uint64 u_s2;\n  uint64 u_s3;\n  uint64 u_s4;\n  uint64 u_s5;\n  uint64 u_s6;\n  uint64 u_s7;\n  uint64 u_s8;\n  uint64 u_s9;\n  uint64 u_s10;\n  uint64 u_s11;\n  uint64 u_t3;\n  uint64 u_t4;\n  uint64 u_t5;\n  uint64 u_t6;\n  uint64 flag;\n};\n```\n\n> 在kernel目录新建alarm.c用于编写所需的两个系统调用。\n> sigalarm在调用时设置好proc的inteval以及handler的值，注意传入的函数地址也可以为0（因为在用户空间，代码段从虚拟地址0开始）。\n\n```c\nuint64 sys_sigalarm(void) {\n    int itv;\n    uint64 handler;\n    struct proc* p = myproc();\n    argint(0, &itv);\n    argaddr(1, &handler);\n    p->interval = itv;\n    p->handler = handler;\n    p->flag = 0;\n    return 0;\n}\n```\n\n> usertrap()：\n> 在每次产生时钟中断时p->tick加1，然后判断是否等于intervel。如果不等于就当成普通的时钟中断处理，如果等于并且当前用户态代码不在执行handler（flag==0）则执行以下操作：\n> 把所有寄存器的值保存，把trampframe->epc的值设置为handler，这样一来在usertrapret时就会把epc设置为handler的第一句代码处，userret（trampoline.S）时执行sret就会返回到handler，从而执行handler。记住把flag设为1.\n\n```c\nif(which_dev == 2) {\n    //printf(\"ticks=%d\\n\", ticks);\n    p->tick++;\n    if (p->tick == p->interval) {\n      if (p->flag == 0) {\n        p->u_epc = p->trapframe->epc;\n        p->u_ra = p->trapframe->ra;\n        p->u_sp = p->trapframe->sp;\n        p->u_gp = p->trapframe->gp;\n        p->u_tp = p->trapframe->tp;\n        p->u_t0 = p->trapframe->t0;\n        p->u_t1 = p->trapframe->t1;\n        p->u_t2 = p->trapframe->t2;\n        p->u_s0 = p->trapframe->s0;\n        p->u_s1 = p->trapframe->s1;\n        p->u_a0 = p->trapframe->a0;\n        p->u_a1 = p->trapframe->a1;\n        p->u_a2 = p->trapframe->a2;\n        p->u_a3 = p->trapframe->a3;\n        p->u_a4 = p->trapframe->a4;\n        p->u_a5 = p->trapframe->a5;\n        p->u_a6 = p->trapframe->a6;\n        p->u_a7 = p->trapframe->a7;\n        p->u_s2 = p->trapframe->s2;\n        p->u_s3 = p->trapframe->s3;\n        p->u_s4 = p->trapframe->s4;\n        p->u_s5 = p->trapframe->s5;\n        p->u_s6 = p->trapframe->s6;\n        p->u_s7 = p->trapframe->s7;\n        p->u_s8 = p->trapframe->s8;\n        p->u_s9 = p->trapframe->s9;\n        p->u_s10 = p->trapframe->s10;\n        p->u_s11 = p->trapframe->s11;\n        p->u_t3 = p->trapframe->t3;\n        p->u_t4 = p->trapframe->t4;\n        p->u_t5 = p->trapframe->t5;\n        p->u_t6 = p->trapframe->t6;\n      \n        p->trapframe->epc = (uint64)p->handler;\n        p->flag = 1;\n      }\n      p->tick = 0;\n    }\n    yield();\n  }\n```\n\n> sigreturn()：在handler最后调用，保证控制流返回到产生trap的那句用户态代码处。\n> 把trapframe->epc设置为time trap时保存的epc值，这样保证返回到正确的代码处。\n> 恢复所有保存的寄存器。\n> handler里也会执行系统调用从而陷入内核态，trapframe会重新进行保存，所以不能保证handler函数的执行过程中进程的trampframe不会产生改变，但p->u_只有在时钟中断时并且tick=interval时（即进入handler之前）才会进行修改，因此可以保证返回到正确的上下文。\n\n```c\nuint64 sys_sigreturn(void) {\n    struct proc* p = myproc();\n    p->trapframe->epc = p->u_epc;\n    p->trapframe->ra = p->u_ra;\n    p->trapframe->sp = p->u_sp;\n    p->trapframe->gp = p->u_gp;\n    p->trapframe->tp = p->u_tp;\n    p->trapframe->t0 = p->u_t0;\n    p->trapframe->t1 = p->u_t1;\n    p->trapframe->t2 = p->u_t2;\n    p->trapframe->s0 = p->u_s0;\n    p->trapframe->s1 = p->u_s1;\n    p->trapframe->a0 = p->u_a0;\n    p->trapframe->a1 = p->u_a1;\n    p->trapframe->a2 = p->u_a2;\n    p->trapframe->a3 = p->u_a3;\n    p->trapframe->a4 = p->u_a4;\n    p->trapframe->a5 = p->u_a5;\n    p->trapframe->a6 = p->u_a6;\n    p->trapframe->a7 = p->u_a7;\n    p->trapframe->s2 = p->u_s2;\n    p->trapframe->s3 = p->u_s3;\n    p->trapframe->s4 = p->u_s4;\n    p->trapframe->s5 = p->u_s5;\n    p->trapframe->s6 = p->u_s6;\n    p->trapframe->s7 = p->u_s7;\n    p->trapframe->s8 = p->u_s8;\n    p->trapframe->s9 = p->u_s9;\n    p->trapframe->s10 = p->u_s10;\n    p->trapframe->s11 = p->u_s11;\n    p->trapframe->t3 = p->u_t3;\n    p->trapframe->t4 = p->u_t4;\n    p->trapframe->t5 = p->u_t5;\n    p->trapframe->t6 = p->u_t6;\n    p->flag = 0;\n    return 0;\n}\n```\n\n这是部分核心代码，其他的就是把sigalarm和sigreturn注册成系统调用，编写makefile等，不再赘述。","slug":"MIT6.S081 Lab4","published":1,"updated":"2021-11-05T04:49:44.799Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckvlyb075000004v671br5m5j","content":"<h2 id=\"实验前准备\"><a href=\"#实验前准备\" class=\"headerlink\" title=\"实验前准备\"></a>实验前准备</h2><blockquote>\n<p>阅读trap.c，trampoline.s</p>\n</blockquote>\n<h2 id=\"RISC-V-assembly\"><a href=\"#RISC-V-assembly\" class=\"headerlink\" title=\"RISC-V assembly\"></a>RISC-V assembly</h2><p>回答几个问题，阅读call.c和它的汇编代码理解函数的calling conventions即可</p>\n<blockquote>\n<p>call.c</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;kernel/param.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;kernel/types.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;kernel/stat.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;user/user.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">g</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x+<span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> g(x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d %d\\n&quot;</span>, f(<span class=\"number\">8</span>)+<span class=\"number\">1</span>, <span class=\"number\">13</span>);</span><br><span class=\"line\">  <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>call.asm</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int g(int x) &#123;</span><br><span class=\"line\">   0:\t1141                \taddi\tsp,sp,-16</span><br><span class=\"line\">   2:\te422                \tsd\ts0,8(sp)</span><br><span class=\"line\">   4:\t0800                \taddi\ts0,sp,16</span><br><span class=\"line\">  return x+3;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">   6:\t250d                \taddiw\ta0,a0,3</span><br><span class=\"line\">   8:\t6422                \tld\ts0,8(sp)</span><br><span class=\"line\">   a:\t0141                \taddi\tsp,sp,16</span><br><span class=\"line\">   c:\t8082                \tret</span><br><span class=\"line\"></span><br><span class=\"line\">000000000000000e &lt;f&gt;:</span><br><span class=\"line\"></span><br><span class=\"line\">int f(int x) &#123;</span><br><span class=\"line\">   e:\t1141                \taddi\tsp,sp,-16</span><br><span class=\"line\">  10:\te422                \tsd\ts0,8(sp)</span><br><span class=\"line\">  12:\t0800                \taddi\ts0,sp,16</span><br><span class=\"line\">  return g(x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  14:\t250d                \taddiw\ta0,a0,3</span><br><span class=\"line\">  16:\t6422                \tld\ts0,8(sp)</span><br><span class=\"line\">  18:\t0141                \taddi\tsp,sp,16</span><br><span class=\"line\">  1a:\t8082                \tret</span><br><span class=\"line\"></span><br><span class=\"line\">000000000000001c &lt;main&gt;:</span><br><span class=\"line\"></span><br><span class=\"line\">void main(void) &#123;</span><br><span class=\"line\">  1c:\t1141                \taddi\tsp,sp,-16</span><br><span class=\"line\">  1e:\te406                \tsd\tra,8(sp)</span><br><span class=\"line\">  20:\te022                \tsd\ts0,0(sp)</span><br><span class=\"line\">  22:\t0800                \taddi\ts0,sp,16</span><br><span class=\"line\">  printf(&quot;%d %d\\n&quot;, f(8)+1, 13);</span><br><span class=\"line\">  24:\t4635                \tli\ta2,13</span><br><span class=\"line\">  26:\t45b1                \tli\ta1,12</span><br><span class=\"line\">  28:\t00000517          \tauipc\ta0,0x0</span><br><span class=\"line\">  2c:\t7b850513          \taddi\ta0,a0,1976 # 7e0 &lt;malloc+0xea&gt;</span><br><span class=\"line\">  30:\t00000097          \tauipc\tra,0x0</span><br><span class=\"line\">  34:\t608080e7          \tjalr\t1544(ra) # 638 &lt;printf&gt;</span><br><span class=\"line\">  exit(0);</span><br><span class=\"line\">  38:\t4501                \tli\ta0,0</span><br><span class=\"line\">  3a:\t00000097          \tauipc\tra,0x0</span><br><span class=\"line\">  3e:\t276080e7          \tjalr\t630(ra) # 2b0 &lt;exit&gt;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Q1.哪个寄存器保存函数参数，例如哪个保存参数13?</p>\n</blockquote>\n<p>A：a0，a1，a2…保存传入的参数，13保存在a2中</p>\n<blockquote>\n<p>Q2.哪里调用了函数f和g？</p>\n</blockquote>\n<p>A：没有调用，编译器把两个函数内联了。</p>\n<blockquote>\n<p>Q3.函数printf的地址？</p>\n</blockquote>\n<p>A：观察汇编代码有</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">30:\t00000097          \tauipc\tra,0x0</span><br><span class=\"line\">34:\t608080e7          \tjalr\t1544(ra) # 638 &lt;printf&gt;</span><br></pre></td></tr></table></figure>\n\n<p>auipc的作用是把立即数左移12位，低12位补0，和pc相加赋给指定寄存器。这里立即数是0，指定寄存器是ra，即ra=pc=0x30=48。jalr作用是跳转到立即数+指定寄存器处并且把ra的值+8。因此jalr会跳转到1544+48=1592=0x638处，观察汇编代码发现：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0000000000000638 &lt;printf&gt;:</span><br><span class=\"line\"></span><br><span class=\"line\">void</span><br><span class=\"line\">printf(const char *fmt, ...)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> 638:\t711d                \taddi\tsp,sp,-96</span><br><span class=\"line\"> 63a:\tec06                \tsd\tra,24(sp)</span><br><span class=\"line\"> 63c:\te822                \tsd\ts0,16(sp)</span><br><span class=\"line\"> 63e:\t1000                \taddi\ts0,sp,32</span><br><span class=\"line\"> 640:\te40c                \tsd\ta1,8(s0)</span><br><span class=\"line\"> 642:\te810                \tsd\ta2,16(s0)</span><br></pre></td></tr></table></figure>\n\n<p>确实在0x638</p>\n<blockquote>\n<p>Q4.在printf之后ra的值？</p>\n</blockquote>\n<p>A.如上述，为0x30+8=0x38，用gdb也可以看到</p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-7f3932002f682a177fe484725656a190_720w.jpg\" alt=\"img\"></p>\n<p>执行完jalr后ra从0x30变为0x38</p>\n<blockquote>\n<p>Q5.运行以下代码，输出是什么？这个输出基于riscv是小端保存，如果是大端保存，怎么设置i才能获得相同输出？</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> i = <span class=\"number\">0x00646c72</span>;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;H%x Wo%s&quot;</span>, <span class=\"number\">57616</span>, &amp;i);</span><br></pre></td></tr></table></figure>\n\n<p>A：输出为HE110 World</p>\n<p>因为riscv为小端存储，从&amp;i开始字节分别为0x72，0x6c，0x64， 0x00.分别对应’r’,’l’,’d’，’0’的ascii码，0x00作为字符串结束标志。</p>\n<p>57616=0xE110</p>\n<p>i应该设置为0x726c6400</p>\n<blockquote>\n<p>Q6.运行printf(“x=%d y=%d”, 3);在y=后面输出什么？为什么会这样？</p>\n</blockquote>\n<p>A：输出y=1。取决于寄存器a2（第3个参数）的值。</p>\n<h2 id=\"Backtrace\"><a href=\"#Backtrace\" class=\"headerlink\" title=\"Backtrace\"></a>Backtrace</h2><p>要求完成一个backtrace函数，在系统调用sys_sleep里调用这个函数，使其从下往上逐一输出内核栈各个stackframe的ra的值。</p>\n<p>主要是弄懂调用函数的stack frame的结构，如下图：</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-4351f298147c4da1f1b72aef8db25093_720w.jpg\" alt=\"img\"></p>\n<p>sp指向当前frame底部（栈是从上往下增长），fp指向当前frame顶部。栈顶部保存了函数返回地址ra以及上个frame的fp。具体可以看任意一个函数的汇编代码：</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-03e9232fd2cdaa8b6cae56499e39ac6b_720w.jpg\" alt=\"img\"></p>\n<p>一个函数在开始执行时会把ra，s0（即fp）的值压栈，然后保存一些寄存器的值，如果参数过多也会把参数保存在栈里，还会保存局部变量。</p>\n<p>backtrace的实现比较简单，模拟函数返回的步骤，输出ra（fp-8），然后找到上一个frame的fp（fp-16），以此类推。注意要求只输出内核态的frame信息，fp如果跳出内核栈的范围到了用户空间循环就要停止了。</p>\n<blockquote>\n<p>backtrace()</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">backtrace</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">  uint64 fp = r_fp();</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">proc</span> *<span class=\"title\">p</span> =</span> myproc();</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    uint64 *ra_addr = (uint64*)(fp - <span class=\"number\">8</span>);</span><br><span class=\"line\">    uint64 *fp_addr = (uint64*)(fp - <span class=\"number\">16</span>);</span><br><span class=\"line\">    fp = *fp_addr;</span><br><span class=\"line\">    <span class=\"comment\">//printf(&quot;fp=%p\\n&quot;, *fp_addr);</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (PGROUNDUP(fp) != p-&gt;kstack+PGSIZE) </span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%p\\n&quot;</span>, *ra_addr);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Alarm\"><a href=\"#Alarm\" class=\"headerlink\" title=\"Alarm\"></a>Alarm</h2><p>实现系统调用sigalarm(n, fn)，执行这个系统调用之后，用户程序在执行的时候能够每隔n个ticks执行一次用户态函数fn。</p>\n<p>riscv收到timer trap的情况有两种，在用户态收到trap和在内核态收到trap，分别会执行usertrap和kerneltrap处理函数。实验要求是在用户态收到n个ticks后执行函数，不用修改kerneltrap的代码。</p>\n<p>实验分两个步骤。test0要求程序执行了fn即可，不用管控制流有没有正常返回以及寄存器的值是否变动，test1和test2要求程序在执行fn后能够通过编写的系统调用sigreturn返回到产生trap的用户代码处，并且程序上下文没有改变。</p>\n<blockquote>\n<p>proc.h<br>给struct添加几个部分，包括需要执行的用户态函数p-&gt;handler，执行函数的间隔p-&gt;interval，距离上一次执行handler后已经产生的tick数p-&gt;tick（在allocproc处初始化为0）。<br>然后是用户态产生trap时的所有寄存器的值。由于执行handler时可能改变某些寄存器，再返回到原先的代码处时需要恢复现场。<br>p-&gt;flag用于判断当前时钟中断是否是在执行handler时产生的，如果是，则不需要执行handler。</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct proc &#123;</span><br><span class=\"line\">  struct spinlock lock;</span><br><span class=\"line\"></span><br><span class=\"line\">  // p-&gt;lock must be held when using these:</span><br><span class=\"line\">  enum procstate state;        // Process state</span><br><span class=\"line\">  struct proc *parent;         // Parent process</span><br><span class=\"line\">  void *chan;                  // If non-zero, sleeping on chan</span><br><span class=\"line\">  int killed;                  // If non-zero, have been killed</span><br><span class=\"line\">  int xstate;                  // Exit status to be returned to parent&#x27;s wait</span><br><span class=\"line\">  int pid;                     // Process ID</span><br><span class=\"line\"></span><br><span class=\"line\">  // these are private to the process, so p-&gt;lock need not be held.</span><br><span class=\"line\">  uint64 kstack;               // Virtual address of kernel stack</span><br><span class=\"line\">  uint64 sz;                   // Size of process memory (bytes)</span><br><span class=\"line\">  pagetable_t pagetable;       // User page table</span><br><span class=\"line\">  struct trapframe *trapframe; // data page for trampoline.S</span><br><span class=\"line\">  struct context context;      // swtch() here to run process</span><br><span class=\"line\">  struct file *ofile[NOFILE];  // Open files</span><br><span class=\"line\">  struct inode *cwd;           // Current directory</span><br><span class=\"line\">  char name[16];               // Process name (debugging)</span><br><span class=\"line\">  int interval;</span><br><span class=\"line\">  uint64 handler;</span><br><span class=\"line\">  int tick;</span><br><span class=\"line\">  uint64 u_epc;</span><br><span class=\"line\">  uint64 u_ra;</span><br><span class=\"line\">  uint64 u_sp;</span><br><span class=\"line\">  uint64 u_gp;</span><br><span class=\"line\">  uint64 u_tp;</span><br><span class=\"line\">  uint64 u_t0;</span><br><span class=\"line\">  uint64 u_t1;</span><br><span class=\"line\">  uint64 u_t2;</span><br><span class=\"line\">  uint64 u_s0;</span><br><span class=\"line\">  uint64 u_s1;</span><br><span class=\"line\">  uint64 u_a0;</span><br><span class=\"line\">  uint64 u_a1;</span><br><span class=\"line\">  uint64 u_a2;</span><br><span class=\"line\">  uint64 u_a3;</span><br><span class=\"line\">  uint64 u_a4;</span><br><span class=\"line\">  uint64 u_a5;</span><br><span class=\"line\">  uint64 u_a6;</span><br><span class=\"line\">  uint64 u_a7;</span><br><span class=\"line\">  uint64 u_s2;</span><br><span class=\"line\">  uint64 u_s3;</span><br><span class=\"line\">  uint64 u_s4;</span><br><span class=\"line\">  uint64 u_s5;</span><br><span class=\"line\">  uint64 u_s6;</span><br><span class=\"line\">  uint64 u_s7;</span><br><span class=\"line\">  uint64 u_s8;</span><br><span class=\"line\">  uint64 u_s9;</span><br><span class=\"line\">  uint64 u_s10;</span><br><span class=\"line\">  uint64 u_s11;</span><br><span class=\"line\">  uint64 u_t3;</span><br><span class=\"line\">  uint64 u_t4;</span><br><span class=\"line\">  uint64 u_t5;</span><br><span class=\"line\">  uint64 u_t6;</span><br><span class=\"line\">  uint64 flag;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>在kernel目录新建alarm.c用于编写所需的两个系统调用。<br>sigalarm在调用时设置好proc的inteval以及handler的值，注意传入的函数地址也可以为0（因为在用户空间，代码段从虚拟地址0开始）。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">uint64 <span class=\"title\">sys_sigalarm</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> itv;</span><br><span class=\"line\">    uint64 handler;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">proc</span>* <span class=\"title\">p</span> =</span> myproc();</span><br><span class=\"line\">    argint(<span class=\"number\">0</span>, &amp;itv);</span><br><span class=\"line\">    argaddr(<span class=\"number\">1</span>, &amp;handler);</span><br><span class=\"line\">    p-&gt;interval = itv;</span><br><span class=\"line\">    p-&gt;handler = handler;</span><br><span class=\"line\">    p-&gt;flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>usertrap()：<br>在每次产生时钟中断时p-&gt;tick加1，然后判断是否等于intervel。如果不等于就当成普通的时钟中断处理，如果等于并且当前用户态代码不在执行handler（flag==0）则执行以下操作：<br>把所有寄存器的值保存，把trampframe-&gt;epc的值设置为handler，这样一来在usertrapret时就会把epc设置为handler的第一句代码处，userret（trampoline.S）时执行sret就会返回到handler，从而执行handler。记住把flag设为1.</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(which_dev == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//printf(&quot;ticks=%d\\n&quot;, ticks);</span></span><br><span class=\"line\">    p-&gt;tick++;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p-&gt;tick == p-&gt;interval) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (p-&gt;flag == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        p-&gt;u_epc = p-&gt;trapframe-&gt;epc;</span><br><span class=\"line\">        p-&gt;u_ra = p-&gt;trapframe-&gt;ra;</span><br><span class=\"line\">        p-&gt;u_sp = p-&gt;trapframe-&gt;sp;</span><br><span class=\"line\">        p-&gt;u_gp = p-&gt;trapframe-&gt;gp;</span><br><span class=\"line\">        p-&gt;u_tp = p-&gt;trapframe-&gt;tp;</span><br><span class=\"line\">        p-&gt;u_t0 = p-&gt;trapframe-&gt;t0;</span><br><span class=\"line\">        p-&gt;u_t1 = p-&gt;trapframe-&gt;t1;</span><br><span class=\"line\">        p-&gt;u_t2 = p-&gt;trapframe-&gt;t2;</span><br><span class=\"line\">        p-&gt;u_s0 = p-&gt;trapframe-&gt;s0;</span><br><span class=\"line\">        p-&gt;u_s1 = p-&gt;trapframe-&gt;s1;</span><br><span class=\"line\">        p-&gt;u_a0 = p-&gt;trapframe-&gt;a0;</span><br><span class=\"line\">        p-&gt;u_a1 = p-&gt;trapframe-&gt;a1;</span><br><span class=\"line\">        p-&gt;u_a2 = p-&gt;trapframe-&gt;a2;</span><br><span class=\"line\">        p-&gt;u_a3 = p-&gt;trapframe-&gt;a3;</span><br><span class=\"line\">        p-&gt;u_a4 = p-&gt;trapframe-&gt;a4;</span><br><span class=\"line\">        p-&gt;u_a5 = p-&gt;trapframe-&gt;a5;</span><br><span class=\"line\">        p-&gt;u_a6 = p-&gt;trapframe-&gt;a6;</span><br><span class=\"line\">        p-&gt;u_a7 = p-&gt;trapframe-&gt;a7;</span><br><span class=\"line\">        p-&gt;u_s2 = p-&gt;trapframe-&gt;s2;</span><br><span class=\"line\">        p-&gt;u_s3 = p-&gt;trapframe-&gt;s3;</span><br><span class=\"line\">        p-&gt;u_s4 = p-&gt;trapframe-&gt;s4;</span><br><span class=\"line\">        p-&gt;u_s5 = p-&gt;trapframe-&gt;s5;</span><br><span class=\"line\">        p-&gt;u_s6 = p-&gt;trapframe-&gt;s6;</span><br><span class=\"line\">        p-&gt;u_s7 = p-&gt;trapframe-&gt;s7;</span><br><span class=\"line\">        p-&gt;u_s8 = p-&gt;trapframe-&gt;s8;</span><br><span class=\"line\">        p-&gt;u_s9 = p-&gt;trapframe-&gt;s9;</span><br><span class=\"line\">        p-&gt;u_s10 = p-&gt;trapframe-&gt;s10;</span><br><span class=\"line\">        p-&gt;u_s11 = p-&gt;trapframe-&gt;s11;</span><br><span class=\"line\">        p-&gt;u_t3 = p-&gt;trapframe-&gt;t3;</span><br><span class=\"line\">        p-&gt;u_t4 = p-&gt;trapframe-&gt;t4;</span><br><span class=\"line\">        p-&gt;u_t5 = p-&gt;trapframe-&gt;t5;</span><br><span class=\"line\">        p-&gt;u_t6 = p-&gt;trapframe-&gt;t6;</span><br><span class=\"line\">      </span><br><span class=\"line\">        p-&gt;trapframe-&gt;epc = (uint64)p-&gt;handler;</span><br><span class=\"line\">        p-&gt;flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      p-&gt;tick = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    yield();</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>sigreturn()：在handler最后调用，保证控制流返回到产生trap的那句用户态代码处。<br>把trapframe-&gt;epc设置为time trap时保存的epc值，这样保证返回到正确的代码处。<br>恢复所有保存的寄存器。<br>handler里也会执行系统调用从而陷入内核态，trapframe会重新进行保存，所以不能保证handler函数的执行过程中进程的trampframe不会产生改变，但p-&gt;u_只有在时钟中断时并且tick=interval时（即进入handler之前）才会进行修改，因此可以保证返回到正确的上下文。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">uint64 <span class=\"title\">sys_sigreturn</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">proc</span>* <span class=\"title\">p</span> =</span> myproc();</span><br><span class=\"line\">    p-&gt;trapframe-&gt;epc = p-&gt;u_epc;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;ra = p-&gt;u_ra;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;sp = p-&gt;u_sp;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;gp = p-&gt;u_gp;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;tp = p-&gt;u_tp;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;t0 = p-&gt;u_t0;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;t1 = p-&gt;u_t1;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;t2 = p-&gt;u_t2;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;s0 = p-&gt;u_s0;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;s1 = p-&gt;u_s1;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;a0 = p-&gt;u_a0;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;a1 = p-&gt;u_a1;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;a2 = p-&gt;u_a2;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;a3 = p-&gt;u_a3;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;a4 = p-&gt;u_a4;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;a5 = p-&gt;u_a5;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;a6 = p-&gt;u_a6;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;a7 = p-&gt;u_a7;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;s2 = p-&gt;u_s2;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;s3 = p-&gt;u_s3;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;s4 = p-&gt;u_s4;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;s5 = p-&gt;u_s5;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;s6 = p-&gt;u_s6;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;s7 = p-&gt;u_s7;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;s8 = p-&gt;u_s8;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;s9 = p-&gt;u_s9;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;s10 = p-&gt;u_s10;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;s11 = p-&gt;u_s11;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;t3 = p-&gt;u_t3;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;t4 = p-&gt;u_t4;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;t5 = p-&gt;u_t5;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;t6 = p-&gt;u_t6;</span><br><span class=\"line\">    p-&gt;flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这是部分核心代码，其他的就是把sigalarm和sigreturn注册成系统调用，编写makefile等，不再赘述。</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/bg.jpg\");\n  background-repeat: no-repeat;\n  background-size: cover;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.9;\n}\n.header-inner {\n  background: rgba(255,255,255,0.85);\n}\n.popup {\n  opacity: 0.85;\n}\n.sidebar {\n  background-color: transparent;\n}\n","variables":""}},"excerpt":"","more":"<h2 id=\"实验前准备\"><a href=\"#实验前准备\" class=\"headerlink\" title=\"实验前准备\"></a>实验前准备</h2><blockquote>\n<p>阅读trap.c，trampoline.s</p>\n</blockquote>\n<h2 id=\"RISC-V-assembly\"><a href=\"#RISC-V-assembly\" class=\"headerlink\" title=\"RISC-V assembly\"></a>RISC-V assembly</h2><p>回答几个问题，阅读call.c和它的汇编代码理解函数的calling conventions即可</p>\n<blockquote>\n<p>call.c</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;kernel/param.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;kernel/types.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;kernel/stat.h&quot;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;user/user.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">g</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x+<span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> g(x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d %d\\n&quot;</span>, f(<span class=\"number\">8</span>)+<span class=\"number\">1</span>, <span class=\"number\">13</span>);</span><br><span class=\"line\">  <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>call.asm</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int g(int x) &#123;</span><br><span class=\"line\">   0:\t1141                \taddi\tsp,sp,-16</span><br><span class=\"line\">   2:\te422                \tsd\ts0,8(sp)</span><br><span class=\"line\">   4:\t0800                \taddi\ts0,sp,16</span><br><span class=\"line\">  return x+3;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">   6:\t250d                \taddiw\ta0,a0,3</span><br><span class=\"line\">   8:\t6422                \tld\ts0,8(sp)</span><br><span class=\"line\">   a:\t0141                \taddi\tsp,sp,16</span><br><span class=\"line\">   c:\t8082                \tret</span><br><span class=\"line\"></span><br><span class=\"line\">000000000000000e &lt;f&gt;:</span><br><span class=\"line\"></span><br><span class=\"line\">int f(int x) &#123;</span><br><span class=\"line\">   e:\t1141                \taddi\tsp,sp,-16</span><br><span class=\"line\">  10:\te422                \tsd\ts0,8(sp)</span><br><span class=\"line\">  12:\t0800                \taddi\ts0,sp,16</span><br><span class=\"line\">  return g(x);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  14:\t250d                \taddiw\ta0,a0,3</span><br><span class=\"line\">  16:\t6422                \tld\ts0,8(sp)</span><br><span class=\"line\">  18:\t0141                \taddi\tsp,sp,16</span><br><span class=\"line\">  1a:\t8082                \tret</span><br><span class=\"line\"></span><br><span class=\"line\">000000000000001c &lt;main&gt;:</span><br><span class=\"line\"></span><br><span class=\"line\">void main(void) &#123;</span><br><span class=\"line\">  1c:\t1141                \taddi\tsp,sp,-16</span><br><span class=\"line\">  1e:\te406                \tsd\tra,8(sp)</span><br><span class=\"line\">  20:\te022                \tsd\ts0,0(sp)</span><br><span class=\"line\">  22:\t0800                \taddi\ts0,sp,16</span><br><span class=\"line\">  printf(&quot;%d %d\\n&quot;, f(8)+1, 13);</span><br><span class=\"line\">  24:\t4635                \tli\ta2,13</span><br><span class=\"line\">  26:\t45b1                \tli\ta1,12</span><br><span class=\"line\">  28:\t00000517          \tauipc\ta0,0x0</span><br><span class=\"line\">  2c:\t7b850513          \taddi\ta0,a0,1976 # 7e0 &lt;malloc+0xea&gt;</span><br><span class=\"line\">  30:\t00000097          \tauipc\tra,0x0</span><br><span class=\"line\">  34:\t608080e7          \tjalr\t1544(ra) # 638 &lt;printf&gt;</span><br><span class=\"line\">  exit(0);</span><br><span class=\"line\">  38:\t4501                \tli\ta0,0</span><br><span class=\"line\">  3a:\t00000097          \tauipc\tra,0x0</span><br><span class=\"line\">  3e:\t276080e7          \tjalr\t630(ra) # 2b0 &lt;exit&gt;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>Q1.哪个寄存器保存函数参数，例如哪个保存参数13?</p>\n</blockquote>\n<p>A：a0，a1，a2…保存传入的参数，13保存在a2中</p>\n<blockquote>\n<p>Q2.哪里调用了函数f和g？</p>\n</blockquote>\n<p>A：没有调用，编译器把两个函数内联了。</p>\n<blockquote>\n<p>Q3.函数printf的地址？</p>\n</blockquote>\n<p>A：观察汇编代码有</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">30:\t00000097          \tauipc\tra,0x0</span><br><span class=\"line\">34:\t608080e7          \tjalr\t1544(ra) # 638 &lt;printf&gt;</span><br></pre></td></tr></table></figure>\n\n<p>auipc的作用是把立即数左移12位，低12位补0，和pc相加赋给指定寄存器。这里立即数是0，指定寄存器是ra，即ra=pc=0x30=48。jalr作用是跳转到立即数+指定寄存器处并且把ra的值+8。因此jalr会跳转到1544+48=1592=0x638处，观察汇编代码发现：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0000000000000638 &lt;printf&gt;:</span><br><span class=\"line\"></span><br><span class=\"line\">void</span><br><span class=\"line\">printf(const char *fmt, ...)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> 638:\t711d                \taddi\tsp,sp,-96</span><br><span class=\"line\"> 63a:\tec06                \tsd\tra,24(sp)</span><br><span class=\"line\"> 63c:\te822                \tsd\ts0,16(sp)</span><br><span class=\"line\"> 63e:\t1000                \taddi\ts0,sp,32</span><br><span class=\"line\"> 640:\te40c                \tsd\ta1,8(s0)</span><br><span class=\"line\"> 642:\te810                \tsd\ta2,16(s0)</span><br></pre></td></tr></table></figure>\n\n<p>确实在0x638</p>\n<blockquote>\n<p>Q4.在printf之后ra的值？</p>\n</blockquote>\n<p>A.如上述，为0x30+8=0x38，用gdb也可以看到</p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-7f3932002f682a177fe484725656a190_720w.jpg\" alt=\"img\"></p>\n<p>执行完jalr后ra从0x30变为0x38</p>\n<blockquote>\n<p>Q5.运行以下代码，输出是什么？这个输出基于riscv是小端保存，如果是大端保存，怎么设置i才能获得相同输出？</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> i = <span class=\"number\">0x00646c72</span>;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;H%x Wo%s&quot;</span>, <span class=\"number\">57616</span>, &amp;i);</span><br></pre></td></tr></table></figure>\n\n<p>A：输出为HE110 World</p>\n<p>因为riscv为小端存储，从&amp;i开始字节分别为0x72，0x6c，0x64， 0x00.分别对应’r’,’l’,’d’，’0’的ascii码，0x00作为字符串结束标志。</p>\n<p>57616=0xE110</p>\n<p>i应该设置为0x726c6400</p>\n<blockquote>\n<p>Q6.运行printf(“x=%d y=%d”, 3);在y=后面输出什么？为什么会这样？</p>\n</blockquote>\n<p>A：输出y=1。取决于寄存器a2（第3个参数）的值。</p>\n<h2 id=\"Backtrace\"><a href=\"#Backtrace\" class=\"headerlink\" title=\"Backtrace\"></a>Backtrace</h2><p>要求完成一个backtrace函数，在系统调用sys_sleep里调用这个函数，使其从下往上逐一输出内核栈各个stackframe的ra的值。</p>\n<p>主要是弄懂调用函数的stack frame的结构，如下图：</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-4351f298147c4da1f1b72aef8db25093_720w.jpg\" alt=\"img\"></p>\n<p>sp指向当前frame底部（栈是从上往下增长），fp指向当前frame顶部。栈顶部保存了函数返回地址ra以及上个frame的fp。具体可以看任意一个函数的汇编代码：</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-03e9232fd2cdaa8b6cae56499e39ac6b_720w.jpg\" alt=\"img\"></p>\n<p>一个函数在开始执行时会把ra，s0（即fp）的值压栈，然后保存一些寄存器的值，如果参数过多也会把参数保存在栈里，还会保存局部变量。</p>\n<p>backtrace的实现比较简单，模拟函数返回的步骤，输出ra（fp-8），然后找到上一个frame的fp（fp-16），以此类推。注意要求只输出内核态的frame信息，fp如果跳出内核栈的范围到了用户空间循环就要停止了。</p>\n<blockquote>\n<p>backtrace()</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">backtrace</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">  uint64 fp = r_fp();</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">proc</span> *<span class=\"title\">p</span> =</span> myproc();</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    uint64 *ra_addr = (uint64*)(fp - <span class=\"number\">8</span>);</span><br><span class=\"line\">    uint64 *fp_addr = (uint64*)(fp - <span class=\"number\">16</span>);</span><br><span class=\"line\">    fp = *fp_addr;</span><br><span class=\"line\">    <span class=\"comment\">//printf(&quot;fp=%p\\n&quot;, *fp_addr);</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (PGROUNDUP(fp) != p-&gt;kstack+PGSIZE) </span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%p\\n&quot;</span>, *ra_addr);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Alarm\"><a href=\"#Alarm\" class=\"headerlink\" title=\"Alarm\"></a>Alarm</h2><p>实现系统调用sigalarm(n, fn)，执行这个系统调用之后，用户程序在执行的时候能够每隔n个ticks执行一次用户态函数fn。</p>\n<p>riscv收到timer trap的情况有两种，在用户态收到trap和在内核态收到trap，分别会执行usertrap和kerneltrap处理函数。实验要求是在用户态收到n个ticks后执行函数，不用修改kerneltrap的代码。</p>\n<p>实验分两个步骤。test0要求程序执行了fn即可，不用管控制流有没有正常返回以及寄存器的值是否变动，test1和test2要求程序在执行fn后能够通过编写的系统调用sigreturn返回到产生trap的用户代码处，并且程序上下文没有改变。</p>\n<blockquote>\n<p>proc.h<br>给struct添加几个部分，包括需要执行的用户态函数p-&gt;handler，执行函数的间隔p-&gt;interval，距离上一次执行handler后已经产生的tick数p-&gt;tick（在allocproc处初始化为0）。<br>然后是用户态产生trap时的所有寄存器的值。由于执行handler时可能改变某些寄存器，再返回到原先的代码处时需要恢复现场。<br>p-&gt;flag用于判断当前时钟中断是否是在执行handler时产生的，如果是，则不需要执行handler。</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct proc &#123;</span><br><span class=\"line\">  struct spinlock lock;</span><br><span class=\"line\"></span><br><span class=\"line\">  // p-&gt;lock must be held when using these:</span><br><span class=\"line\">  enum procstate state;        // Process state</span><br><span class=\"line\">  struct proc *parent;         // Parent process</span><br><span class=\"line\">  void *chan;                  // If non-zero, sleeping on chan</span><br><span class=\"line\">  int killed;                  // If non-zero, have been killed</span><br><span class=\"line\">  int xstate;                  // Exit status to be returned to parent&#x27;s wait</span><br><span class=\"line\">  int pid;                     // Process ID</span><br><span class=\"line\"></span><br><span class=\"line\">  // these are private to the process, so p-&gt;lock need not be held.</span><br><span class=\"line\">  uint64 kstack;               // Virtual address of kernel stack</span><br><span class=\"line\">  uint64 sz;                   // Size of process memory (bytes)</span><br><span class=\"line\">  pagetable_t pagetable;       // User page table</span><br><span class=\"line\">  struct trapframe *trapframe; // data page for trampoline.S</span><br><span class=\"line\">  struct context context;      // swtch() here to run process</span><br><span class=\"line\">  struct file *ofile[NOFILE];  // Open files</span><br><span class=\"line\">  struct inode *cwd;           // Current directory</span><br><span class=\"line\">  char name[16];               // Process name (debugging)</span><br><span class=\"line\">  int interval;</span><br><span class=\"line\">  uint64 handler;</span><br><span class=\"line\">  int tick;</span><br><span class=\"line\">  uint64 u_epc;</span><br><span class=\"line\">  uint64 u_ra;</span><br><span class=\"line\">  uint64 u_sp;</span><br><span class=\"line\">  uint64 u_gp;</span><br><span class=\"line\">  uint64 u_tp;</span><br><span class=\"line\">  uint64 u_t0;</span><br><span class=\"line\">  uint64 u_t1;</span><br><span class=\"line\">  uint64 u_t2;</span><br><span class=\"line\">  uint64 u_s0;</span><br><span class=\"line\">  uint64 u_s1;</span><br><span class=\"line\">  uint64 u_a0;</span><br><span class=\"line\">  uint64 u_a1;</span><br><span class=\"line\">  uint64 u_a2;</span><br><span class=\"line\">  uint64 u_a3;</span><br><span class=\"line\">  uint64 u_a4;</span><br><span class=\"line\">  uint64 u_a5;</span><br><span class=\"line\">  uint64 u_a6;</span><br><span class=\"line\">  uint64 u_a7;</span><br><span class=\"line\">  uint64 u_s2;</span><br><span class=\"line\">  uint64 u_s3;</span><br><span class=\"line\">  uint64 u_s4;</span><br><span class=\"line\">  uint64 u_s5;</span><br><span class=\"line\">  uint64 u_s6;</span><br><span class=\"line\">  uint64 u_s7;</span><br><span class=\"line\">  uint64 u_s8;</span><br><span class=\"line\">  uint64 u_s9;</span><br><span class=\"line\">  uint64 u_s10;</span><br><span class=\"line\">  uint64 u_s11;</span><br><span class=\"line\">  uint64 u_t3;</span><br><span class=\"line\">  uint64 u_t4;</span><br><span class=\"line\">  uint64 u_t5;</span><br><span class=\"line\">  uint64 u_t6;</span><br><span class=\"line\">  uint64 flag;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>在kernel目录新建alarm.c用于编写所需的两个系统调用。<br>sigalarm在调用时设置好proc的inteval以及handler的值，注意传入的函数地址也可以为0（因为在用户空间，代码段从虚拟地址0开始）。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">uint64 <span class=\"title\">sys_sigalarm</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> itv;</span><br><span class=\"line\">    uint64 handler;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">proc</span>* <span class=\"title\">p</span> =</span> myproc();</span><br><span class=\"line\">    argint(<span class=\"number\">0</span>, &amp;itv);</span><br><span class=\"line\">    argaddr(<span class=\"number\">1</span>, &amp;handler);</span><br><span class=\"line\">    p-&gt;interval = itv;</span><br><span class=\"line\">    p-&gt;handler = handler;</span><br><span class=\"line\">    p-&gt;flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>usertrap()：<br>在每次产生时钟中断时p-&gt;tick加1，然后判断是否等于intervel。如果不等于就当成普通的时钟中断处理，如果等于并且当前用户态代码不在执行handler（flag==0）则执行以下操作：<br>把所有寄存器的值保存，把trampframe-&gt;epc的值设置为handler，这样一来在usertrapret时就会把epc设置为handler的第一句代码处，userret（trampoline.S）时执行sret就会返回到handler，从而执行handler。记住把flag设为1.</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(which_dev == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//printf(&quot;ticks=%d\\n&quot;, ticks);</span></span><br><span class=\"line\">    p-&gt;tick++;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p-&gt;tick == p-&gt;interval) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (p-&gt;flag == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        p-&gt;u_epc = p-&gt;trapframe-&gt;epc;</span><br><span class=\"line\">        p-&gt;u_ra = p-&gt;trapframe-&gt;ra;</span><br><span class=\"line\">        p-&gt;u_sp = p-&gt;trapframe-&gt;sp;</span><br><span class=\"line\">        p-&gt;u_gp = p-&gt;trapframe-&gt;gp;</span><br><span class=\"line\">        p-&gt;u_tp = p-&gt;trapframe-&gt;tp;</span><br><span class=\"line\">        p-&gt;u_t0 = p-&gt;trapframe-&gt;t0;</span><br><span class=\"line\">        p-&gt;u_t1 = p-&gt;trapframe-&gt;t1;</span><br><span class=\"line\">        p-&gt;u_t2 = p-&gt;trapframe-&gt;t2;</span><br><span class=\"line\">        p-&gt;u_s0 = p-&gt;trapframe-&gt;s0;</span><br><span class=\"line\">        p-&gt;u_s1 = p-&gt;trapframe-&gt;s1;</span><br><span class=\"line\">        p-&gt;u_a0 = p-&gt;trapframe-&gt;a0;</span><br><span class=\"line\">        p-&gt;u_a1 = p-&gt;trapframe-&gt;a1;</span><br><span class=\"line\">        p-&gt;u_a2 = p-&gt;trapframe-&gt;a2;</span><br><span class=\"line\">        p-&gt;u_a3 = p-&gt;trapframe-&gt;a3;</span><br><span class=\"line\">        p-&gt;u_a4 = p-&gt;trapframe-&gt;a4;</span><br><span class=\"line\">        p-&gt;u_a5 = p-&gt;trapframe-&gt;a5;</span><br><span class=\"line\">        p-&gt;u_a6 = p-&gt;trapframe-&gt;a6;</span><br><span class=\"line\">        p-&gt;u_a7 = p-&gt;trapframe-&gt;a7;</span><br><span class=\"line\">        p-&gt;u_s2 = p-&gt;trapframe-&gt;s2;</span><br><span class=\"line\">        p-&gt;u_s3 = p-&gt;trapframe-&gt;s3;</span><br><span class=\"line\">        p-&gt;u_s4 = p-&gt;trapframe-&gt;s4;</span><br><span class=\"line\">        p-&gt;u_s5 = p-&gt;trapframe-&gt;s5;</span><br><span class=\"line\">        p-&gt;u_s6 = p-&gt;trapframe-&gt;s6;</span><br><span class=\"line\">        p-&gt;u_s7 = p-&gt;trapframe-&gt;s7;</span><br><span class=\"line\">        p-&gt;u_s8 = p-&gt;trapframe-&gt;s8;</span><br><span class=\"line\">        p-&gt;u_s9 = p-&gt;trapframe-&gt;s9;</span><br><span class=\"line\">        p-&gt;u_s10 = p-&gt;trapframe-&gt;s10;</span><br><span class=\"line\">        p-&gt;u_s11 = p-&gt;trapframe-&gt;s11;</span><br><span class=\"line\">        p-&gt;u_t3 = p-&gt;trapframe-&gt;t3;</span><br><span class=\"line\">        p-&gt;u_t4 = p-&gt;trapframe-&gt;t4;</span><br><span class=\"line\">        p-&gt;u_t5 = p-&gt;trapframe-&gt;t5;</span><br><span class=\"line\">        p-&gt;u_t6 = p-&gt;trapframe-&gt;t6;</span><br><span class=\"line\">      </span><br><span class=\"line\">        p-&gt;trapframe-&gt;epc = (uint64)p-&gt;handler;</span><br><span class=\"line\">        p-&gt;flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      p-&gt;tick = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    yield();</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>sigreturn()：在handler最后调用，保证控制流返回到产生trap的那句用户态代码处。<br>把trapframe-&gt;epc设置为time trap时保存的epc值，这样保证返回到正确的代码处。<br>恢复所有保存的寄存器。<br>handler里也会执行系统调用从而陷入内核态，trapframe会重新进行保存，所以不能保证handler函数的执行过程中进程的trampframe不会产生改变，但p-&gt;u_只有在时钟中断时并且tick=interval时（即进入handler之前）才会进行修改，因此可以保证返回到正确的上下文。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">uint64 <span class=\"title\">sys_sigreturn</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">proc</span>* <span class=\"title\">p</span> =</span> myproc();</span><br><span class=\"line\">    p-&gt;trapframe-&gt;epc = p-&gt;u_epc;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;ra = p-&gt;u_ra;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;sp = p-&gt;u_sp;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;gp = p-&gt;u_gp;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;tp = p-&gt;u_tp;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;t0 = p-&gt;u_t0;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;t1 = p-&gt;u_t1;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;t2 = p-&gt;u_t2;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;s0 = p-&gt;u_s0;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;s1 = p-&gt;u_s1;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;a0 = p-&gt;u_a0;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;a1 = p-&gt;u_a1;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;a2 = p-&gt;u_a2;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;a3 = p-&gt;u_a3;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;a4 = p-&gt;u_a4;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;a5 = p-&gt;u_a5;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;a6 = p-&gt;u_a6;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;a7 = p-&gt;u_a7;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;s2 = p-&gt;u_s2;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;s3 = p-&gt;u_s3;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;s4 = p-&gt;u_s4;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;s5 = p-&gt;u_s5;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;s6 = p-&gt;u_s6;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;s7 = p-&gt;u_s7;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;s8 = p-&gt;u_s8;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;s9 = p-&gt;u_s9;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;s10 = p-&gt;u_s10;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;s11 = p-&gt;u_s11;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;t3 = p-&gt;u_t3;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;t4 = p-&gt;u_t4;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;t5 = p-&gt;u_t5;</span><br><span class=\"line\">    p-&gt;trapframe-&gt;t6 = p-&gt;u_t6;</span><br><span class=\"line\">    p-&gt;flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这是部分核心代码，其他的就是把sigalarm和sigreturn注册成系统调用，编写makefile等，不再赘述。</p>\n"},{"title":"MIT6.S081 Lab3 Pgtbl","date":"2021-04-03T04:00:00.000Z","_content":"### 实验前准备\n\n> 阅读vm.c,proc.c,exec.c,看明白xv6怎么初始化内核页表以及怎么实现内存isolation的.阅读trap.c,trampoline.S,明白用户程序陷入内核态以及从内核态返回用户态的过程.\n> 阅读xv6book chapter3&chapter4.\n\n### Print a page table\n\n第一个实验要求实现一个函数vmprint(pagetable_t pagetable),输出页表的内容.其实就是仿照walk模拟硬件翻译的过程,中间把页表项的值输出就可以了.比较简单:\n\n```c\nvoid _vmprint(pagetable_t pagetable, uint64 depth) {\n  if (depth == 1) \n    printf(\"page table %p\\n\", pagetable);\n  if (depth == 4) return;\n  for (int i = 0; i < 512; i++) {\n    pte_t pte = pagetable[i];\n    if (pte & PTE_V) {\n      printf(\"..\");\n      for (int j = 1; j < depth; j++)\n        printf(\" ..\");\n      printf(\"%d: pte %p pa %p\\n\", i, pte, PTE2PA(pte));\n      _vmprint((pagetable_t)PTE2PA(pte), depth+1);\n    }\n  }\n}\n\nvoid vmprint(pagetable_t pagetable) {\n  _vmprint(pagetable, 1);\n}\n```\n\n这个实验主要是为了后面实验debug用.\n\n### A kernel page table per process\n\nxv6为每个进程分配了一个用户页表,在用户态时使用的是当前进程的pagetable,当陷入内核态时会把satp切换为全局的内核页表kernel_pagetable (trampoline.S 78行).kernel_pagetable使用了direct map,把虚拟内存直接map到物理内存,同时也初始化了一些设备地址(kvminit()).如下图\n\n![img](https://pic1.zhimg.com/80/v2-d992e535c19abc307ea2230979f5c53c_720w.jpg)\n\n当用户程序调用系统调用传入一个地址时需要在内核态进行翻译获得物理地址.举个例子,程序使用write系统调用传入一个buf,这个buf本质是一个地址,假设为a,它对应的物理地址是b.那么系统陷入到内核态后,由于此时的页表是kernel_pagetable而不是用户的pagetable,kernel_pagetable并没有地址a的对应关系,因此需要通过walk模拟MMU来获得a在用户pagetable中的物理地址即b.\n\n这个实验和下一个实验就是要求为每个进程分配一个kpagetable,当用户陷入内核态时切换到kpagetable而不是全局的kernel_pagetable.这个kpagetable的内容要求有3个:\n\n1.内容和kernel_pagetable基本一样使得在内核态时能够使用内核的代码和数据\n\n2.在trampoline下面是进程的内核栈,kpagetable只能把本进程对应的内核栈map好.其他进程的不能map\n\n3.最重要的一点,由于进程的va从0开始且连续增长,我们在kpagetable中也要保存进程va和pa的对应关系,这样在内核态时可以直接使用用户空间的虚拟地址.以上述例子来说,内核态可以直接使用地址a,因为硬件会自动把a翻译为物理地址b.\n\n这个实验要求完成前两点,下个实验要求完成第3点.\n\n> proc.h\n\n```c\npagetable_t kpagetable;\n```\n\n> allocproc() 加入初始化kpagetable的过程,proc_kernel_kvminit()类似kvminit把物理内存和设备以及trampoline的地址map好.\n> kprocinit()用来map本进程的内核栈\n\n```c\n...\n// An empty user page table.\n  p->pagetable = proc_pagetable(p);\n  if(p->pagetable == 0){\n    freeproc(p);\n    release(&p->lock);\n    return 0;\n  }\n  //lab3 step2\n\n  p->kpagetable = proc_kernel_kvminit(p);\n  if(p->kpagetable == 0){\n    freeproc(p);\n    release(&p->lock);\n    return 0;\n  }\n  kprocinit(p);\n...\n```\n\n> proc_kernel_kvminit()\n> 这里面的proc_kvmmap和kvmmap一样,只不过加了参数指定pagetable\n\n```c\npagetable_t\nproc_kernel_kvminit(struct proc *p)\n{\n  pagetable_t pagetable;\n  pagetable = (pagetable_t) kalloc();\n  memset(pagetable, 0, PGSIZE);\n  // uart registers\n  proc_kvmmap(pagetable, UART0, UART0, PGSIZE, PTE_R | PTE_W);\n  // virtio mmio disk interface\n  proc_kvmmap(pagetable, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);\n\n  // CLINT\n  proc_kvmmap(pagetable, CLINT, CLINT, 0x10000, PTE_R | PTE_W);\n\n  // PLIC\n  proc_kvmmap(pagetable, PLIC, PLIC, 0x400000, PTE_R | PTE_W);\n\n  // map kernel text executable and read-only.\n  proc_kvmmap(pagetable, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);\n\n  // map kernel data and the physical RAM we'll make use of.\n  proc_kvmmap(pagetable, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);\n  // map the trampoline for trap entry/exit to\n  // the highest virtual address in the kernel.\n  proc_kvmmap(pagetable, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);\n  return pagetable;\n}\n```\n\n> void kprocinit(struct proc *p)\n> 内核栈物理内存在procinit()时就已经alloc好了,所以只要在页表里map一下就行\n\n```c\nvoid kprocinit(struct proc *p) {\n  uint64 va = KSTACK((int) (p - proc));\n  uint64 pa = kvmpa(va);\n  //printf(\"p->kstack = %p\\n\", KSTACK((int) (p - proc)));\n  proc_kvmmap(p->kpagetable, (uint64)va, (uint64)pa, PGSIZE, PTE_R | PTE_W);\n  p->kstack = va;\n}\n```\n\n> freeproc()\n> 加入free kpagetable的过程,首先把用户空间的地址都unmap掉(这是第三个实验要做的),然后proc_free_kpagetable用来free页表.\n\n```c\nstatic void\nfreeproc(struct proc *p)\n{\n  if(p->trapframe)\n    kfree((void*)p->trapframe);\n  p->trapframe = 0;\n  if(p->pagetable)\n    proc_freepagetable(p->pagetable, p->sz);\n\n  uvmunmap(p->kpagetable, 0, PGROUNDUP(p->sz) / PGSIZE, 0);\n  //lab3 step2\n  if (p->kpagetable)\n    proc_free_kpagetable(p);\n  p->pagetable = 0;\n  p->kpagetable = 0;\n  p->sz = 0;\n  p->pid = 0;\n  p->parent = 0;\n  p->name[0] = 0;\n  p->chan = 0;\n  p->killed = 0;\n  p->xstate = 0;\n  p->state = UNUSED;\n}\n```\n\n> kuvmunmap和uvmunmap相比去掉了panic,这是因为第三个实验map用户地址时会把底层某些地址覆盖掉,然后如果再unmap掉部分虚拟地址,就会导致中间有的地址unmap.比如UART0是0x1000000,如果用户虚拟地址增长到了0x1001000,再sbrk(-1000)删除一页,这样0x1000000->0x1001000这部分页表是空的,此时freeproc执行kuvmunmap(p->kpagetable, UART0, 1, 0)时就会出现not mapped的panic.\n\n```c\nvoid proc_free_kpagetable(struct proc *p)\n{\n  kuvmunmap(p->kpagetable, TRAMPOLINE, 1, 0);\n  kuvmunmap(p->kpagetable, KSTACK((int) (p - proc)), 1, 0);\n  kuvmunmap(p->kpagetable, UART0, 1, 0);\n  kuvmunmap(p->kpagetable, VIRTIO0, 1, 0);\n  kuvmunmap(p->kpagetable, CLINT, 0x10000 / PGSIZE, 0);\n  kuvmunmap(p->kpagetable, PLIC, 0x400000 / PGSIZE, 0);\n  kuvmunmap(p->kpagetable, KERNBASE, (uint64)(etext-KERNBASE) / PGSIZE, 0);\n  kuvmunmap(p->kpagetable, (uint64)etext, (PHYSTOP-(uint64)etext) / PGSIZE, 0);\n  freewalk(p->kpagetable);\n}\n```\n\n> scheduler()\n> 切换进程前切换到对应的kpagetable,某进程退出后回到scheduler使用全局kernel_pagetable\n\n```c\nfor(p = proc; p < &proc[NPROC]; p++) {\n      acquire(&p->lock);\n      if(p->state == RUNNABLE) {\n        // Switch to chosen process.  It is the process's job\n        // to release its lock and then reacquire it\n        // before jumping back to us.\n        p->state = RUNNING;\n        c->proc = p;\n        //lab3 step2\n        w_satp(MAKE_SATP(p->kpagetable));\n        sfence_vma();\n\n        swtch(&c->context, &p->context);\n\n        // Process is done running for now.\n        // It should have changed its p->state before coming back.\n\n        //lab3 step2\n        w_satp(MAKE_SATP(kernel_pagetable));\n        sfence_vma();\n\n        c->proc = 0;\n\n        found = 1;\n      }\n      release(&p->lock);\n    }\n```\n\n### Simplify copyin/copyinstr\n\n这个实验要完成第3个条件,在kpagetable把用户空间的虚拟地址也map好.hints已经告诉我们在exec(),fork(),growproc()里修改kpagetable就可以了,因为只有这些函数会修改用户pagetable.\n\n> exec()\n> 这里的逻辑就是把kpagetable底部用户空间的部分先全部unmap掉,再把用户pagetable的内容通过kuvmcopy复制到kpagetable里\n> 之所以unmap时不需要free掉物理内存,是因为下面proc_freepagetable(oldpagetable, oldsz)把原先的pagetable释放掉同时free了对应的物理内存.\n\n```c\n...\noldpagetable = p->pagetable;\n  p->pagetable = pagetable;\n  p->sz = sz;\n  p->trapframe->epc = elf.entry;  // initial program counter = main\n  p->trapframe->sp = sp; // initial stack pointer\n  //lab3 step3\n  uvmunmap(p->kpagetable, 0, PGROUNDUP(oldsz) / PGSIZE, 0);\n  if (kuvmcopy(p, sz, PTE_R|PTE_W|PTE_X) != 0) {\n    panic(\"kuvmcopy\");\n  }\n  w_satp(MAKE_SATP(p->kpagetable));\n  sfence_vma();\n  proc_freepagetable(oldpagetable, oldsz);\n...\n```\n\n> kuvmcopy()\n> 把进程new的pagetable底部(即不包含trampoline和trapframe)复制给kpagetable\n> 函数mappages_remap和mappages相比去掉了remap的panic,理由在step2里提到了,kpagetable在map时可能需要覆盖某些设备的地址.\n\n```c\nint kuvmcopy(struct proc *new, uint64 sz, int perm) {\n  pte_t *pte;\n  uint64 pa, i;\n  pagetable_t newpg = new->pagetable;\n  for(i = 0; i < sz; i += PGSIZE){\n    if((pte = walk(newpg, i, 0)) == 0)\n      panic(\"uvmcopy: pte should exist\");\n    if((*pte & PTE_V) == 0)\n      panic(\"uvmcopy: page not present\");\n    pa = PTE2PA(*pte);\n    if(mappages_remap(new->kpagetable, i, PGSIZE, pa, perm) != 0){\n      goto err;\n    }\n  }\n  return 0;\n\n err:\n  uvmunmap(new->kpagetable, 0, i / PGSIZE, 1);\n  return -1;\n}\n```\n\n> fork()\n> 同理把fork出来的子进程的用户pagetable复制给kpagetable,注意flag不能有PTE_U,因为cpu在suprivisor模式时不能访问设置PTE_U的页\n\n```c\n...\n// Copy user memory from parent to child.\n  if(uvmcopy(p->pagetable, np->pagetable, p->sz) < 0){\n    freeproc(np);\n    release(&np->lock);\n    return -1;\n  }\n  if(kuvmcopy(np, p->sz, PTE_R|PTE_W|PTE_X) < 0){\n    freeproc(np);\n    release(&np->lock);\n    return -1;\n...\n```\n\n> growproc()\n> 这个稍微麻烦一点,用户空间增长n时要同时在pagetable和kpagetable进行map,同理n<0也要.\n\n```c\nint\ngrowproc(int n)\n{\n  uint sz;\n  struct proc *p = myproc();\n  //lab3 step3\n\n  uint oldsz;\n  oldsz = sz = p->sz;\n  if(n > 0){\n    sz = kuvmalloc(p, sz, sz + n);\n    if( sz == 0 ) {\n      return -1;\n    }\n    if (sz > PLIC) {\n      kuvmdealloc(p, sz, oldsz);\n      return -1;\n    }\n  } else if(n < 0){\n      sz = kuvmdealloc(p, sz, sz + n);\n  } \n  p->sz = sz;\n  return 0;\n}\n```\n\n> kuvmalloc()\n> 和uvmalloc相比加入了给kpagetable进行map的过程,注意在mappages_remap返回-1的时候要不仅要free物理内存,还要把之前mappages()时用户pagetable给unmap掉,一直过不去sbrkfail这个test的原因就是这个.\n> 具体来说,比如内存还剩100,kuvmalloc分配第99页后不会触发mem=0,但是执行mappages会把物理内存剩的最后一页用于分配页表,此时执行mappages_remap就会失败(因为没有物理内存了),在这个逻辑下是不应该分配这个第99页的.如果直接执行kuvmdealloc会把用户pagetable第99页的map关系保留下来,导致最后freeproc时panic leaf map.\n\n```c\nuint64\nkuvmalloc(struct proc *p, uint64 oldsz, uint64 newsz)\n{\n  char *mem;\n  uint64 a;\n  pagetable_t pagetable = p->pagetable;\n  pagetable_t kpagetable = p->kpagetable;\n  if(newsz < oldsz)\n    return oldsz;\n  oldsz = PGROUNDUP(oldsz);\n  for(a = oldsz; a < newsz; a += PGSIZE){\n    mem = kalloc();\n    if(mem == 0){\n      kuvmdealloc(p, a, oldsz);    \n      return 0;\n    }\n    memset(mem, 0, PGSIZE);    \n    if(mappages(pagetable, a, PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != 0){\n      kfree(mem);\n      kuvmdealloc(p, a, oldsz);\n      return 0;\n    }\n    if (mappages_remap(kpagetable, a, PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R) != 0) {\n      kfree(mem);\n      uvmunmap(pagetable, a, 1, 0);\n      kuvmdealloc(p, a, oldsz);\n      return 0;\n    }    \n  }\n  return newsz;\n}\n```\n\n> kuvmdealloc()\n> 仿照uvmdealloc就行\n\n```c\nuint64\nkuvmdealloc(struct proc *p, uint64 oldsz, uint64 newsz)\n{\n  pagetable_t pagetable = p->pagetable;\n  pagetable_t kpagetable = p->kpagetable;\n  if(newsz >= oldsz)\n    return oldsz;\n\n  if(PGROUNDUP(newsz) < PGROUNDUP(oldsz)){\n    int npages = (PGROUNDUP(oldsz) - PGROUNDUP(newsz)) / PGSIZE;\n    uvmunmap(pagetable, PGROUNDUP(newsz), npages, 1);\n    kuvmunmap(kpagetable, PGROUNDUP(newsz), npages, 0);\n  }\n  return newsz;\n}\n```\n\n### 实验结果\n\n![img](https://pic3.zhimg.com/80/v2-d0566e3093b15954bdaedd4d1fcdf192_720w.jpg)\n\n### 心得\n\n主要是要先看懂几个重要函数的作用,弄懂陷入内核态和返回用户态的过程,理解内核页表和用户页表的内存分布,搞清楚实验目的是什么.接下来就是耐心debug了,如果usertests某些测试一直通不过可以看一下这个test做了些什么,以此定位哪里的代码可能出错.","source":"_posts/MIT6.S081 Lab3.md","raw":"---\ntitle: MIT6.S081 Lab3 pgtbl\ndate: 2021-04-03 12:00:00\ntags: 6.S081\n---\n### 实验前准备\n\n> 阅读vm.c,proc.c,exec.c,看明白xv6怎么初始化内核页表以及怎么实现内存isolation的.阅读trap.c,trampoline.S,明白用户程序陷入内核态以及从内核态返回用户态的过程.\n> 阅读xv6book chapter3&chapter4.\n\n### Print a page table\n\n第一个实验要求实现一个函数vmprint(pagetable_t pagetable),输出页表的内容.其实就是仿照walk模拟硬件翻译的过程,中间把页表项的值输出就可以了.比较简单:\n\n```c\nvoid _vmprint(pagetable_t pagetable, uint64 depth) {\n  if (depth == 1) \n    printf(\"page table %p\\n\", pagetable);\n  if (depth == 4) return;\n  for (int i = 0; i < 512; i++) {\n    pte_t pte = pagetable[i];\n    if (pte & PTE_V) {\n      printf(\"..\");\n      for (int j = 1; j < depth; j++)\n        printf(\" ..\");\n      printf(\"%d: pte %p pa %p\\n\", i, pte, PTE2PA(pte));\n      _vmprint((pagetable_t)PTE2PA(pte), depth+1);\n    }\n  }\n}\n\nvoid vmprint(pagetable_t pagetable) {\n  _vmprint(pagetable, 1);\n}\n```\n\n这个实验主要是为了后面实验debug用.\n\n### A kernel page table per process\n\nxv6为每个进程分配了一个用户页表,在用户态时使用的是当前进程的pagetable,当陷入内核态时会把satp切换为全局的内核页表kernel_pagetable (trampoline.S 78行).kernel_pagetable使用了direct map,把虚拟内存直接map到物理内存,同时也初始化了一些设备地址(kvminit()).如下图\n\n![img](https://pic1.zhimg.com/80/v2-d992e535c19abc307ea2230979f5c53c_720w.jpg)\n\n当用户程序调用系统调用传入一个地址时需要在内核态进行翻译获得物理地址.举个例子,程序使用write系统调用传入一个buf,这个buf本质是一个地址,假设为a,它对应的物理地址是b.那么系统陷入到内核态后,由于此时的页表是kernel_pagetable而不是用户的pagetable,kernel_pagetable并没有地址a的对应关系,因此需要通过walk模拟MMU来获得a在用户pagetable中的物理地址即b.\n\n这个实验和下一个实验就是要求为每个进程分配一个kpagetable,当用户陷入内核态时切换到kpagetable而不是全局的kernel_pagetable.这个kpagetable的内容要求有3个:\n\n1.内容和kernel_pagetable基本一样使得在内核态时能够使用内核的代码和数据\n\n2.在trampoline下面是进程的内核栈,kpagetable只能把本进程对应的内核栈map好.其他进程的不能map\n\n3.最重要的一点,由于进程的va从0开始且连续增长,我们在kpagetable中也要保存进程va和pa的对应关系,这样在内核态时可以直接使用用户空间的虚拟地址.以上述例子来说,内核态可以直接使用地址a,因为硬件会自动把a翻译为物理地址b.\n\n这个实验要求完成前两点,下个实验要求完成第3点.\n\n> proc.h\n\n```c\npagetable_t kpagetable;\n```\n\n> allocproc() 加入初始化kpagetable的过程,proc_kernel_kvminit()类似kvminit把物理内存和设备以及trampoline的地址map好.\n> kprocinit()用来map本进程的内核栈\n\n```c\n...\n// An empty user page table.\n  p->pagetable = proc_pagetable(p);\n  if(p->pagetable == 0){\n    freeproc(p);\n    release(&p->lock);\n    return 0;\n  }\n  //lab3 step2\n\n  p->kpagetable = proc_kernel_kvminit(p);\n  if(p->kpagetable == 0){\n    freeproc(p);\n    release(&p->lock);\n    return 0;\n  }\n  kprocinit(p);\n...\n```\n\n> proc_kernel_kvminit()\n> 这里面的proc_kvmmap和kvmmap一样,只不过加了参数指定pagetable\n\n```c\npagetable_t\nproc_kernel_kvminit(struct proc *p)\n{\n  pagetable_t pagetable;\n  pagetable = (pagetable_t) kalloc();\n  memset(pagetable, 0, PGSIZE);\n  // uart registers\n  proc_kvmmap(pagetable, UART0, UART0, PGSIZE, PTE_R | PTE_W);\n  // virtio mmio disk interface\n  proc_kvmmap(pagetable, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);\n\n  // CLINT\n  proc_kvmmap(pagetable, CLINT, CLINT, 0x10000, PTE_R | PTE_W);\n\n  // PLIC\n  proc_kvmmap(pagetable, PLIC, PLIC, 0x400000, PTE_R | PTE_W);\n\n  // map kernel text executable and read-only.\n  proc_kvmmap(pagetable, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);\n\n  // map kernel data and the physical RAM we'll make use of.\n  proc_kvmmap(pagetable, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);\n  // map the trampoline for trap entry/exit to\n  // the highest virtual address in the kernel.\n  proc_kvmmap(pagetable, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);\n  return pagetable;\n}\n```\n\n> void kprocinit(struct proc *p)\n> 内核栈物理内存在procinit()时就已经alloc好了,所以只要在页表里map一下就行\n\n```c\nvoid kprocinit(struct proc *p) {\n  uint64 va = KSTACK((int) (p - proc));\n  uint64 pa = kvmpa(va);\n  //printf(\"p->kstack = %p\\n\", KSTACK((int) (p - proc)));\n  proc_kvmmap(p->kpagetable, (uint64)va, (uint64)pa, PGSIZE, PTE_R | PTE_W);\n  p->kstack = va;\n}\n```\n\n> freeproc()\n> 加入free kpagetable的过程,首先把用户空间的地址都unmap掉(这是第三个实验要做的),然后proc_free_kpagetable用来free页表.\n\n```c\nstatic void\nfreeproc(struct proc *p)\n{\n  if(p->trapframe)\n    kfree((void*)p->trapframe);\n  p->trapframe = 0;\n  if(p->pagetable)\n    proc_freepagetable(p->pagetable, p->sz);\n\n  uvmunmap(p->kpagetable, 0, PGROUNDUP(p->sz) / PGSIZE, 0);\n  //lab3 step2\n  if (p->kpagetable)\n    proc_free_kpagetable(p);\n  p->pagetable = 0;\n  p->kpagetable = 0;\n  p->sz = 0;\n  p->pid = 0;\n  p->parent = 0;\n  p->name[0] = 0;\n  p->chan = 0;\n  p->killed = 0;\n  p->xstate = 0;\n  p->state = UNUSED;\n}\n```\n\n> kuvmunmap和uvmunmap相比去掉了panic,这是因为第三个实验map用户地址时会把底层某些地址覆盖掉,然后如果再unmap掉部分虚拟地址,就会导致中间有的地址unmap.比如UART0是0x1000000,如果用户虚拟地址增长到了0x1001000,再sbrk(-1000)删除一页,这样0x1000000->0x1001000这部分页表是空的,此时freeproc执行kuvmunmap(p->kpagetable, UART0, 1, 0)时就会出现not mapped的panic.\n\n```c\nvoid proc_free_kpagetable(struct proc *p)\n{\n  kuvmunmap(p->kpagetable, TRAMPOLINE, 1, 0);\n  kuvmunmap(p->kpagetable, KSTACK((int) (p - proc)), 1, 0);\n  kuvmunmap(p->kpagetable, UART0, 1, 0);\n  kuvmunmap(p->kpagetable, VIRTIO0, 1, 0);\n  kuvmunmap(p->kpagetable, CLINT, 0x10000 / PGSIZE, 0);\n  kuvmunmap(p->kpagetable, PLIC, 0x400000 / PGSIZE, 0);\n  kuvmunmap(p->kpagetable, KERNBASE, (uint64)(etext-KERNBASE) / PGSIZE, 0);\n  kuvmunmap(p->kpagetable, (uint64)etext, (PHYSTOP-(uint64)etext) / PGSIZE, 0);\n  freewalk(p->kpagetable);\n}\n```\n\n> scheduler()\n> 切换进程前切换到对应的kpagetable,某进程退出后回到scheduler使用全局kernel_pagetable\n\n```c\nfor(p = proc; p < &proc[NPROC]; p++) {\n      acquire(&p->lock);\n      if(p->state == RUNNABLE) {\n        // Switch to chosen process.  It is the process's job\n        // to release its lock and then reacquire it\n        // before jumping back to us.\n        p->state = RUNNING;\n        c->proc = p;\n        //lab3 step2\n        w_satp(MAKE_SATP(p->kpagetable));\n        sfence_vma();\n\n        swtch(&c->context, &p->context);\n\n        // Process is done running for now.\n        // It should have changed its p->state before coming back.\n\n        //lab3 step2\n        w_satp(MAKE_SATP(kernel_pagetable));\n        sfence_vma();\n\n        c->proc = 0;\n\n        found = 1;\n      }\n      release(&p->lock);\n    }\n```\n\n### Simplify copyin/copyinstr\n\n这个实验要完成第3个条件,在kpagetable把用户空间的虚拟地址也map好.hints已经告诉我们在exec(),fork(),growproc()里修改kpagetable就可以了,因为只有这些函数会修改用户pagetable.\n\n> exec()\n> 这里的逻辑就是把kpagetable底部用户空间的部分先全部unmap掉,再把用户pagetable的内容通过kuvmcopy复制到kpagetable里\n> 之所以unmap时不需要free掉物理内存,是因为下面proc_freepagetable(oldpagetable, oldsz)把原先的pagetable释放掉同时free了对应的物理内存.\n\n```c\n...\noldpagetable = p->pagetable;\n  p->pagetable = pagetable;\n  p->sz = sz;\n  p->trapframe->epc = elf.entry;  // initial program counter = main\n  p->trapframe->sp = sp; // initial stack pointer\n  //lab3 step3\n  uvmunmap(p->kpagetable, 0, PGROUNDUP(oldsz) / PGSIZE, 0);\n  if (kuvmcopy(p, sz, PTE_R|PTE_W|PTE_X) != 0) {\n    panic(\"kuvmcopy\");\n  }\n  w_satp(MAKE_SATP(p->kpagetable));\n  sfence_vma();\n  proc_freepagetable(oldpagetable, oldsz);\n...\n```\n\n> kuvmcopy()\n> 把进程new的pagetable底部(即不包含trampoline和trapframe)复制给kpagetable\n> 函数mappages_remap和mappages相比去掉了remap的panic,理由在step2里提到了,kpagetable在map时可能需要覆盖某些设备的地址.\n\n```c\nint kuvmcopy(struct proc *new, uint64 sz, int perm) {\n  pte_t *pte;\n  uint64 pa, i;\n  pagetable_t newpg = new->pagetable;\n  for(i = 0; i < sz; i += PGSIZE){\n    if((pte = walk(newpg, i, 0)) == 0)\n      panic(\"uvmcopy: pte should exist\");\n    if((*pte & PTE_V) == 0)\n      panic(\"uvmcopy: page not present\");\n    pa = PTE2PA(*pte);\n    if(mappages_remap(new->kpagetable, i, PGSIZE, pa, perm) != 0){\n      goto err;\n    }\n  }\n  return 0;\n\n err:\n  uvmunmap(new->kpagetable, 0, i / PGSIZE, 1);\n  return -1;\n}\n```\n\n> fork()\n> 同理把fork出来的子进程的用户pagetable复制给kpagetable,注意flag不能有PTE_U,因为cpu在suprivisor模式时不能访问设置PTE_U的页\n\n```c\n...\n// Copy user memory from parent to child.\n  if(uvmcopy(p->pagetable, np->pagetable, p->sz) < 0){\n    freeproc(np);\n    release(&np->lock);\n    return -1;\n  }\n  if(kuvmcopy(np, p->sz, PTE_R|PTE_W|PTE_X) < 0){\n    freeproc(np);\n    release(&np->lock);\n    return -1;\n...\n```\n\n> growproc()\n> 这个稍微麻烦一点,用户空间增长n时要同时在pagetable和kpagetable进行map,同理n<0也要.\n\n```c\nint\ngrowproc(int n)\n{\n  uint sz;\n  struct proc *p = myproc();\n  //lab3 step3\n\n  uint oldsz;\n  oldsz = sz = p->sz;\n  if(n > 0){\n    sz = kuvmalloc(p, sz, sz + n);\n    if( sz == 0 ) {\n      return -1;\n    }\n    if (sz > PLIC) {\n      kuvmdealloc(p, sz, oldsz);\n      return -1;\n    }\n  } else if(n < 0){\n      sz = kuvmdealloc(p, sz, sz + n);\n  } \n  p->sz = sz;\n  return 0;\n}\n```\n\n> kuvmalloc()\n> 和uvmalloc相比加入了给kpagetable进行map的过程,注意在mappages_remap返回-1的时候要不仅要free物理内存,还要把之前mappages()时用户pagetable给unmap掉,一直过不去sbrkfail这个test的原因就是这个.\n> 具体来说,比如内存还剩100,kuvmalloc分配第99页后不会触发mem=0,但是执行mappages会把物理内存剩的最后一页用于分配页表,此时执行mappages_remap就会失败(因为没有物理内存了),在这个逻辑下是不应该分配这个第99页的.如果直接执行kuvmdealloc会把用户pagetable第99页的map关系保留下来,导致最后freeproc时panic leaf map.\n\n```c\nuint64\nkuvmalloc(struct proc *p, uint64 oldsz, uint64 newsz)\n{\n  char *mem;\n  uint64 a;\n  pagetable_t pagetable = p->pagetable;\n  pagetable_t kpagetable = p->kpagetable;\n  if(newsz < oldsz)\n    return oldsz;\n  oldsz = PGROUNDUP(oldsz);\n  for(a = oldsz; a < newsz; a += PGSIZE){\n    mem = kalloc();\n    if(mem == 0){\n      kuvmdealloc(p, a, oldsz);    \n      return 0;\n    }\n    memset(mem, 0, PGSIZE);    \n    if(mappages(pagetable, a, PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != 0){\n      kfree(mem);\n      kuvmdealloc(p, a, oldsz);\n      return 0;\n    }\n    if (mappages_remap(kpagetable, a, PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R) != 0) {\n      kfree(mem);\n      uvmunmap(pagetable, a, 1, 0);\n      kuvmdealloc(p, a, oldsz);\n      return 0;\n    }    \n  }\n  return newsz;\n}\n```\n\n> kuvmdealloc()\n> 仿照uvmdealloc就行\n\n```c\nuint64\nkuvmdealloc(struct proc *p, uint64 oldsz, uint64 newsz)\n{\n  pagetable_t pagetable = p->pagetable;\n  pagetable_t kpagetable = p->kpagetable;\n  if(newsz >= oldsz)\n    return oldsz;\n\n  if(PGROUNDUP(newsz) < PGROUNDUP(oldsz)){\n    int npages = (PGROUNDUP(oldsz) - PGROUNDUP(newsz)) / PGSIZE;\n    uvmunmap(pagetable, PGROUNDUP(newsz), npages, 1);\n    kuvmunmap(kpagetable, PGROUNDUP(newsz), npages, 0);\n  }\n  return newsz;\n}\n```\n\n### 实验结果\n\n![img](https://pic3.zhimg.com/80/v2-d0566e3093b15954bdaedd4d1fcdf192_720w.jpg)\n\n### 心得\n\n主要是要先看懂几个重要函数的作用,弄懂陷入内核态和返回用户态的过程,理解内核页表和用户页表的内存分布,搞清楚实验目的是什么.接下来就是耐心debug了,如果usertests某些测试一直通不过可以看一下这个test做了些什么,以此定位哪里的代码可能出错.","slug":"MIT6.S081 Lab3","published":1,"updated":"2021-11-05T04:49:44.798Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckvlyb079000104v6cqgvb9hp","content":"<h3 id=\"实验前准备\"><a href=\"#实验前准备\" class=\"headerlink\" title=\"实验前准备\"></a>实验前准备</h3><blockquote>\n<p>阅读vm.c,proc.c,exec.c,看明白xv6怎么初始化内核页表以及怎么实现内存isolation的.阅读trap.c,trampoline.S,明白用户程序陷入内核态以及从内核态返回用户态的过程.<br>阅读xv6book chapter3&amp;chapter4.</p>\n</blockquote>\n<h3 id=\"Print-a-page-table\"><a href=\"#Print-a-page-table\" class=\"headerlink\" title=\"Print a page table\"></a>Print a page table</h3><p>第一个实验要求实现一个函数vmprint(pagetable_t pagetable),输出页表的内容.其实就是仿照walk模拟硬件翻译的过程,中间把页表项的值输出就可以了.比较简单:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> _vmprint(<span class=\"keyword\">pagetable_t</span> pagetable, uint64 depth) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (depth == <span class=\"number\">1</span>) </span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;page table %p\\n&quot;</span>, pagetable);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (depth == <span class=\"number\">4</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">512</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pte_t</span> pte = pagetable[i];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pte &amp; PTE_V) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;..&quot;</span>);</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt; depth; j++)</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot; ..&quot;</span>);</span><br><span class=\"line\">      <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d: pte %p pa %p\\n&quot;</span>, i, pte, PTE2PA(pte));</span><br><span class=\"line\">      _vmprint((<span class=\"keyword\">pagetable_t</span>)PTE2PA(pte), depth+<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">vmprint</span><span class=\"params\">(<span class=\"keyword\">pagetable_t</span> pagetable)</span> </span>&#123;</span><br><span class=\"line\">  _vmprint(pagetable, <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个实验主要是为了后面实验debug用.</p>\n<h3 id=\"A-kernel-page-table-per-process\"><a href=\"#A-kernel-page-table-per-process\" class=\"headerlink\" title=\"A kernel page table per process\"></a>A kernel page table per process</h3><p>xv6为每个进程分配了一个用户页表,在用户态时使用的是当前进程的pagetable,当陷入内核态时会把satp切换为全局的内核页表kernel_pagetable (trampoline.S 78行).kernel_pagetable使用了direct map,把虚拟内存直接map到物理内存,同时也初始化了一些设备地址(kvminit()).如下图</p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-d992e535c19abc307ea2230979f5c53c_720w.jpg\" alt=\"img\"></p>\n<p>当用户程序调用系统调用传入一个地址时需要在内核态进行翻译获得物理地址.举个例子,程序使用write系统调用传入一个buf,这个buf本质是一个地址,假设为a,它对应的物理地址是b.那么系统陷入到内核态后,由于此时的页表是kernel_pagetable而不是用户的pagetable,kernel_pagetable并没有地址a的对应关系,因此需要通过walk模拟MMU来获得a在用户pagetable中的物理地址即b.</p>\n<p>这个实验和下一个实验就是要求为每个进程分配一个kpagetable,当用户陷入内核态时切换到kpagetable而不是全局的kernel_pagetable.这个kpagetable的内容要求有3个:</p>\n<p>1.内容和kernel_pagetable基本一样使得在内核态时能够使用内核的代码和数据</p>\n<p>2.在trampoline下面是进程的内核栈,kpagetable只能把本进程对应的内核栈map好.其他进程的不能map</p>\n<p>3.最重要的一点,由于进程的va从0开始且连续增长,我们在kpagetable中也要保存进程va和pa的对应关系,这样在内核态时可以直接使用用户空间的虚拟地址.以上述例子来说,内核态可以直接使用地址a,因为硬件会自动把a翻译为物理地址b.</p>\n<p>这个实验要求完成前两点,下个实验要求完成第3点.</p>\n<blockquote>\n<p>proc.h</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">pagetable_t</span> kpagetable;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>allocproc() 加入初始化kpagetable的过程,proc_kernel_kvminit()类似kvminit把物理内存和设备以及trampoline的地址map好.<br>kprocinit()用来map本进程的内核栈</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"><span class=\"comment\">// An empty user page table.</span></span><br><span class=\"line\">  p-&gt;pagetable = proc_pagetable(p);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(p-&gt;pagetable == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    freeproc(p);</span><br><span class=\"line\">    release(&amp;p-&gt;lock);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//lab3 step2</span></span><br><span class=\"line\"></span><br><span class=\"line\">  p-&gt;kpagetable = proc_kernel_kvminit(p);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(p-&gt;kpagetable == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    freeproc(p);</span><br><span class=\"line\">    release(&amp;p-&gt;lock);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  kprocinit(p);</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>proc_kernel_kvminit()<br>这里面的proc_kvmmap和kvmmap一样,只不过加了参数指定pagetable</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">pagetable_t</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">proc_kernel_kvminit</span><span class=\"params\">(struct proc *p)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">pagetable_t</span> pagetable;</span><br><span class=\"line\">  pagetable = (<span class=\"keyword\">pagetable_t</span>) kalloc();</span><br><span class=\"line\">  <span class=\"built_in\">memset</span>(pagetable, <span class=\"number\">0</span>, PGSIZE);</span><br><span class=\"line\">  <span class=\"comment\">// uart registers</span></span><br><span class=\"line\">  proc_kvmmap(pagetable, UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class=\"line\">  <span class=\"comment\">// virtio mmio disk interface</span></span><br><span class=\"line\">  proc_kvmmap(pagetable, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// CLINT</span></span><br><span class=\"line\">  proc_kvmmap(pagetable, CLINT, CLINT, <span class=\"number\">0x10000</span>, PTE_R | PTE_W);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// PLIC</span></span><br><span class=\"line\">  proc_kvmmap(pagetable, PLIC, PLIC, <span class=\"number\">0x400000</span>, PTE_R | PTE_W);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// map kernel text executable and read-only.</span></span><br><span class=\"line\">  proc_kvmmap(pagetable, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// map kernel data and the physical RAM we&#x27;ll make use of.</span></span><br><span class=\"line\">  proc_kvmmap(pagetable, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);</span><br><span class=\"line\">  <span class=\"comment\">// map the trampoline for trap entry/exit to</span></span><br><span class=\"line\">  <span class=\"comment\">// the highest virtual address in the kernel.</span></span><br><span class=\"line\">  proc_kvmmap(pagetable, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> pagetable;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>void kprocinit(struct proc *p)<br>内核栈物理内存在procinit()时就已经alloc好了,所以只要在页表里map一下就行</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">kprocinit</span><span class=\"params\">(struct proc *p)</span> </span>&#123;</span><br><span class=\"line\">  uint64 va = KSTACK((<span class=\"keyword\">int</span>) (p - proc));</span><br><span class=\"line\">  uint64 pa = kvmpa(va);</span><br><span class=\"line\">  <span class=\"comment\">//printf(&quot;p-&gt;kstack = %p\\n&quot;, KSTACK((int) (p - proc)));</span></span><br><span class=\"line\">  proc_kvmmap(p-&gt;kpagetable, (uint64)va, (uint64)pa, PGSIZE, PTE_R | PTE_W);</span><br><span class=\"line\">  p-&gt;kstack = va;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>freeproc()<br>加入free kpagetable的过程,首先把用户空间的地址都unmap掉(这是第三个实验要做的),然后proc_free_kpagetable用来free页表.</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">freeproc</span><span class=\"params\">(struct proc *p)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(p-&gt;trapframe)</span><br><span class=\"line\">    kfree((<span class=\"keyword\">void</span>*)p-&gt;trapframe);</span><br><span class=\"line\">  p-&gt;trapframe = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(p-&gt;pagetable)</span><br><span class=\"line\">    proc_freepagetable(p-&gt;pagetable, p-&gt;sz);</span><br><span class=\"line\"></span><br><span class=\"line\">  uvmunmap(p-&gt;kpagetable, <span class=\"number\">0</span>, PGROUNDUP(p-&gt;sz) / PGSIZE, <span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"comment\">//lab3 step2</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (p-&gt;kpagetable)</span><br><span class=\"line\">    proc_free_kpagetable(p);</span><br><span class=\"line\">  p-&gt;pagetable = <span class=\"number\">0</span>;</span><br><span class=\"line\">  p-&gt;kpagetable = <span class=\"number\">0</span>;</span><br><span class=\"line\">  p-&gt;sz = <span class=\"number\">0</span>;</span><br><span class=\"line\">  p-&gt;pid = <span class=\"number\">0</span>;</span><br><span class=\"line\">  p-&gt;parent = <span class=\"number\">0</span>;</span><br><span class=\"line\">  p-&gt;name[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">  p-&gt;chan = <span class=\"number\">0</span>;</span><br><span class=\"line\">  p-&gt;killed = <span class=\"number\">0</span>;</span><br><span class=\"line\">  p-&gt;xstate = <span class=\"number\">0</span>;</span><br><span class=\"line\">  p-&gt;state = UNUSED;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>kuvmunmap和uvmunmap相比去掉了panic,这是因为第三个实验map用户地址时会把底层某些地址覆盖掉,然后如果再unmap掉部分虚拟地址,就会导致中间有的地址unmap.比如UART0是0x1000000,如果用户虚拟地址增长到了0x1001000,再sbrk(-1000)删除一页,这样0x1000000-&gt;0x1001000这部分页表是空的,此时freeproc执行kuvmunmap(p-&gt;kpagetable, UART0, 1, 0)时就会出现not mapped的panic.</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">proc_free_kpagetable</span><span class=\"params\">(struct proc *p)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  kuvmunmap(p-&gt;kpagetable, TRAMPOLINE, <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">  kuvmunmap(p-&gt;kpagetable, KSTACK((<span class=\"keyword\">int</span>) (p - proc)), <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">  kuvmunmap(p-&gt;kpagetable, UART0, <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">  kuvmunmap(p-&gt;kpagetable, VIRTIO0, <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">  kuvmunmap(p-&gt;kpagetable, CLINT, <span class=\"number\">0x10000</span> / PGSIZE, <span class=\"number\">0</span>);</span><br><span class=\"line\">  kuvmunmap(p-&gt;kpagetable, PLIC, <span class=\"number\">0x400000</span> / PGSIZE, <span class=\"number\">0</span>);</span><br><span class=\"line\">  kuvmunmap(p-&gt;kpagetable, KERNBASE, (uint64)(etext-KERNBASE) / PGSIZE, <span class=\"number\">0</span>);</span><br><span class=\"line\">  kuvmunmap(p-&gt;kpagetable, (uint64)etext, (PHYSTOP-(uint64)etext) / PGSIZE, <span class=\"number\">0</span>);</span><br><span class=\"line\">  freewalk(p-&gt;kpagetable);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>scheduler()<br>切换进程前切换到对应的kpagetable,某进程退出后回到scheduler使用全局kernel_pagetable</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class=\"line\">      acquire(&amp;p-&gt;lock);</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(p-&gt;state == RUNNABLE) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Switch to chosen process.  It is the process&#x27;s job</span></span><br><span class=\"line\">        <span class=\"comment\">// to release its lock and then reacquire it</span></span><br><span class=\"line\">        <span class=\"comment\">// before jumping back to us.</span></span><br><span class=\"line\">        p-&gt;state = RUNNING;</span><br><span class=\"line\">        c-&gt;proc = p;</span><br><span class=\"line\">        <span class=\"comment\">//lab3 step2</span></span><br><span class=\"line\">        w_satp(MAKE_SATP(p-&gt;kpagetable));</span><br><span class=\"line\">        sfence_vma();</span><br><span class=\"line\"></span><br><span class=\"line\">        swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Process is done running for now.</span></span><br><span class=\"line\">        <span class=\"comment\">// It should have changed its p-&gt;state before coming back.</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//lab3 step2</span></span><br><span class=\"line\">        w_satp(MAKE_SATP(kernel_pagetable));</span><br><span class=\"line\">        sfence_vma();</span><br><span class=\"line\"></span><br><span class=\"line\">        c-&gt;proc = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        found = <span class=\"number\">1</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      release(&amp;p-&gt;lock);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Simplify-copyin-copyinstr\"><a href=\"#Simplify-copyin-copyinstr\" class=\"headerlink\" title=\"Simplify copyin/copyinstr\"></a>Simplify copyin/copyinstr</h3><p>这个实验要完成第3个条件,在kpagetable把用户空间的虚拟地址也map好.hints已经告诉我们在exec(),fork(),growproc()里修改kpagetable就可以了,因为只有这些函数会修改用户pagetable.</p>\n<blockquote>\n<p>exec()<br>这里的逻辑就是把kpagetable底部用户空间的部分先全部unmap掉,再把用户pagetable的内容通过kuvmcopy复制到kpagetable里<br>之所以unmap时不需要free掉物理内存,是因为下面proc_freepagetable(oldpagetable, oldsz)把原先的pagetable释放掉同时free了对应的物理内存.</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">oldpagetable = p-&gt;pagetable;</span><br><span class=\"line\">  p-&gt;pagetable = pagetable;</span><br><span class=\"line\">  p-&gt;sz = sz;</span><br><span class=\"line\">  p-&gt;trapframe-&gt;epc = elf.entry;  <span class=\"comment\">// initial program counter = main</span></span><br><span class=\"line\">  p-&gt;trapframe-&gt;sp = sp; <span class=\"comment\">// initial stack pointer</span></span><br><span class=\"line\">  <span class=\"comment\">//lab3 step3</span></span><br><span class=\"line\">  uvmunmap(p-&gt;kpagetable, <span class=\"number\">0</span>, PGROUNDUP(oldsz) / PGSIZE, <span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (kuvmcopy(p, sz, PTE_R|PTE_W|PTE_X) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    panic(<span class=\"string\">&quot;kuvmcopy&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  w_satp(MAKE_SATP(p-&gt;kpagetable));</span><br><span class=\"line\">  sfence_vma();</span><br><span class=\"line\">  proc_freepagetable(oldpagetable, oldsz);</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>kuvmcopy()<br>把进程new的pagetable底部(即不包含trampoline和trapframe)复制给kpagetable<br>函数mappages_remap和mappages相比去掉了remap的panic,理由在step2里提到了,kpagetable在map时可能需要覆盖某些设备的地址.</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">kuvmcopy</span><span class=\"params\">(struct proc *<span class=\"keyword\">new</span>, uint64 sz, <span class=\"keyword\">int</span> perm)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">pte_t</span> *pte;</span><br><span class=\"line\">  uint64 pa, i;</span><br><span class=\"line\">  <span class=\"keyword\">pagetable_t</span> newpg = <span class=\"keyword\">new</span>-&gt;pagetable;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; sz; i += PGSIZE)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((pte = walk(newpg, i, <span class=\"number\">0</span>)) == <span class=\"number\">0</span>)</span><br><span class=\"line\">      panic(<span class=\"string\">&quot;uvmcopy: pte should exist&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((*pte &amp; PTE_V) == <span class=\"number\">0</span>)</span><br><span class=\"line\">      panic(<span class=\"string\">&quot;uvmcopy: page not present&quot;</span>);</span><br><span class=\"line\">    pa = PTE2PA(*pte);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(mappages_remap(<span class=\"keyword\">new</span>-&gt;kpagetable, i, PGSIZE, pa, perm) != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">goto</span> err;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"> err:</span><br><span class=\"line\">  uvmunmap(<span class=\"keyword\">new</span>-&gt;kpagetable, <span class=\"number\">0</span>, i / PGSIZE, <span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>fork()<br>同理把fork出来的子进程的用户pagetable复制给kpagetable,注意flag不能有PTE_U,因为cpu在suprivisor模式时不能访问设置PTE_U的页</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"><span class=\"comment\">// Copy user memory from parent to child.</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    freeproc(np);</span><br><span class=\"line\">    release(&amp;np-&gt;lock);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(kuvmcopy(np, p-&gt;sz, PTE_R|PTE_W|PTE_X) &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    freeproc(np);</span><br><span class=\"line\">    release(&amp;np-&gt;lock);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>growproc()<br>这个稍微麻烦一点,用户空间增长n时要同时在pagetable和kpagetable进行map,同理n&lt;0也要.</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">growproc</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  uint sz;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">proc</span> *<span class=\"title\">p</span> =</span> myproc();</span><br><span class=\"line\">  <span class=\"comment\">//lab3 step3</span></span><br><span class=\"line\"></span><br><span class=\"line\">  uint oldsz;</span><br><span class=\"line\">  oldsz = sz = p-&gt;sz;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(n &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    sz = kuvmalloc(p, sz, sz + n);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( sz == <span class=\"number\">0</span> ) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sz &gt; PLIC) &#123;</span><br><span class=\"line\">      kuvmdealloc(p, sz, oldsz);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(n &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">      sz = kuvmdealloc(p, sz, sz + n);</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  p-&gt;sz = sz;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>kuvmalloc()<br>和uvmalloc相比加入了给kpagetable进行map的过程,注意在mappages_remap返回-1的时候要不仅要free物理内存,还要把之前mappages()时用户pagetable给unmap掉,一直过不去sbrkfail这个test的原因就是这个.<br>具体来说,比如内存还剩100,kuvmalloc分配第99页后不会触发mem=0,但是执行mappages会把物理内存剩的最后一页用于分配页表,此时执行mappages_remap就会失败(因为没有物理内存了),在这个逻辑下是不应该分配这个第99页的.如果直接执行kuvmdealloc会把用户pagetable第99页的map关系保留下来,导致最后freeproc时panic leaf map.</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">uint64</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">kuvmalloc</span><span class=\"params\">(struct proc *p, uint64 oldsz, uint64 newsz)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">char</span> *mem;</span><br><span class=\"line\">  uint64 a;</span><br><span class=\"line\">  <span class=\"keyword\">pagetable_t</span> pagetable = p-&gt;pagetable;</span><br><span class=\"line\">  <span class=\"keyword\">pagetable_t</span> kpagetable = p-&gt;kpagetable;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(newsz &lt; oldsz)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> oldsz;</span><br><span class=\"line\">  oldsz = PGROUNDUP(oldsz);</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(a = oldsz; a &lt; newsz; a += PGSIZE)&#123;</span><br><span class=\"line\">    mem = kalloc();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(mem == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">      kuvmdealloc(p, a, oldsz);    </span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(mem, <span class=\"number\">0</span>, PGSIZE);    </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(mappages(pagetable, a, PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">      kfree(mem);</span><br><span class=\"line\">      kuvmdealloc(p, a, oldsz);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mappages_remap(kpagetable, a, PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      kfree(mem);</span><br><span class=\"line\">      uvmunmap(pagetable, a, <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">      kuvmdealloc(p, a, oldsz);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> newsz;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>kuvmdealloc()<br>仿照uvmdealloc就行</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">uint64</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">kuvmdealloc</span><span class=\"params\">(struct proc *p, uint64 oldsz, uint64 newsz)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">pagetable_t</span> pagetable = p-&gt;pagetable;</span><br><span class=\"line\">  <span class=\"keyword\">pagetable_t</span> kpagetable = p-&gt;kpagetable;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(newsz &gt;= oldsz)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> oldsz;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(PGROUNDUP(newsz) &lt; PGROUNDUP(oldsz))&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> npages = (PGROUNDUP(oldsz) - PGROUNDUP(newsz)) / PGSIZE;</span><br><span class=\"line\">    uvmunmap(pagetable, PGROUNDUP(newsz), npages, <span class=\"number\">1</span>);</span><br><span class=\"line\">    kuvmunmap(kpagetable, PGROUNDUP(newsz), npages, <span class=\"number\">0</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> newsz;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"实验结果\"><a href=\"#实验结果\" class=\"headerlink\" title=\"实验结果\"></a>实验结果</h3><p><img src=\"https://pic3.zhimg.com/80/v2-d0566e3093b15954bdaedd4d1fcdf192_720w.jpg\" alt=\"img\"></p>\n<h3 id=\"心得\"><a href=\"#心得\" class=\"headerlink\" title=\"心得\"></a>心得</h3><p>主要是要先看懂几个重要函数的作用,弄懂陷入内核态和返回用户态的过程,理解内核页表和用户页表的内存分布,搞清楚实验目的是什么.接下来就是耐心debug了,如果usertests某些测试一直通不过可以看一下这个test做了些什么,以此定位哪里的代码可能出错.</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/bg.jpg\");\n  background-repeat: no-repeat;\n  background-size: cover;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.9;\n}\n.header-inner {\n  background: rgba(255,255,255,0.85);\n}\n.popup {\n  opacity: 0.85;\n}\n.sidebar {\n  background-color: transparent;\n}\n","variables":""}},"excerpt":"","more":"<h3 id=\"实验前准备\"><a href=\"#实验前准备\" class=\"headerlink\" title=\"实验前准备\"></a>实验前准备</h3><blockquote>\n<p>阅读vm.c,proc.c,exec.c,看明白xv6怎么初始化内核页表以及怎么实现内存isolation的.阅读trap.c,trampoline.S,明白用户程序陷入内核态以及从内核态返回用户态的过程.<br>阅读xv6book chapter3&amp;chapter4.</p>\n</blockquote>\n<h3 id=\"Print-a-page-table\"><a href=\"#Print-a-page-table\" class=\"headerlink\" title=\"Print a page table\"></a>Print a page table</h3><p>第一个实验要求实现一个函数vmprint(pagetable_t pagetable),输出页表的内容.其实就是仿照walk模拟硬件翻译的过程,中间把页表项的值输出就可以了.比较简单:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">void</span> _vmprint(<span class=\"keyword\">pagetable_t</span> pagetable, uint64 depth) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (depth == <span class=\"number\">1</span>) </span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;page table %p\\n&quot;</span>, pagetable);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (depth == <span class=\"number\">4</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">512</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pte_t</span> pte = pagetable[i];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pte &amp; PTE_V) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;..&quot;</span>);</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>; j &lt; depth; j++)</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot; ..&quot;</span>);</span><br><span class=\"line\">      <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d: pte %p pa %p\\n&quot;</span>, i, pte, PTE2PA(pte));</span><br><span class=\"line\">      _vmprint((<span class=\"keyword\">pagetable_t</span>)PTE2PA(pte), depth+<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">vmprint</span><span class=\"params\">(<span class=\"keyword\">pagetable_t</span> pagetable)</span> </span>&#123;</span><br><span class=\"line\">  _vmprint(pagetable, <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个实验主要是为了后面实验debug用.</p>\n<h3 id=\"A-kernel-page-table-per-process\"><a href=\"#A-kernel-page-table-per-process\" class=\"headerlink\" title=\"A kernel page table per process\"></a>A kernel page table per process</h3><p>xv6为每个进程分配了一个用户页表,在用户态时使用的是当前进程的pagetable,当陷入内核态时会把satp切换为全局的内核页表kernel_pagetable (trampoline.S 78行).kernel_pagetable使用了direct map,把虚拟内存直接map到物理内存,同时也初始化了一些设备地址(kvminit()).如下图</p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-d992e535c19abc307ea2230979f5c53c_720w.jpg\" alt=\"img\"></p>\n<p>当用户程序调用系统调用传入一个地址时需要在内核态进行翻译获得物理地址.举个例子,程序使用write系统调用传入一个buf,这个buf本质是一个地址,假设为a,它对应的物理地址是b.那么系统陷入到内核态后,由于此时的页表是kernel_pagetable而不是用户的pagetable,kernel_pagetable并没有地址a的对应关系,因此需要通过walk模拟MMU来获得a在用户pagetable中的物理地址即b.</p>\n<p>这个实验和下一个实验就是要求为每个进程分配一个kpagetable,当用户陷入内核态时切换到kpagetable而不是全局的kernel_pagetable.这个kpagetable的内容要求有3个:</p>\n<p>1.内容和kernel_pagetable基本一样使得在内核态时能够使用内核的代码和数据</p>\n<p>2.在trampoline下面是进程的内核栈,kpagetable只能把本进程对应的内核栈map好.其他进程的不能map</p>\n<p>3.最重要的一点,由于进程的va从0开始且连续增长,我们在kpagetable中也要保存进程va和pa的对应关系,这样在内核态时可以直接使用用户空间的虚拟地址.以上述例子来说,内核态可以直接使用地址a,因为硬件会自动把a翻译为物理地址b.</p>\n<p>这个实验要求完成前两点,下个实验要求完成第3点.</p>\n<blockquote>\n<p>proc.h</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">pagetable_t</span> kpagetable;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>allocproc() 加入初始化kpagetable的过程,proc_kernel_kvminit()类似kvminit把物理内存和设备以及trampoline的地址map好.<br>kprocinit()用来map本进程的内核栈</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"><span class=\"comment\">// An empty user page table.</span></span><br><span class=\"line\">  p-&gt;pagetable = proc_pagetable(p);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(p-&gt;pagetable == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    freeproc(p);</span><br><span class=\"line\">    release(&amp;p-&gt;lock);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//lab3 step2</span></span><br><span class=\"line\"></span><br><span class=\"line\">  p-&gt;kpagetable = proc_kernel_kvminit(p);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(p-&gt;kpagetable == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    freeproc(p);</span><br><span class=\"line\">    release(&amp;p-&gt;lock);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  kprocinit(p);</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>proc_kernel_kvminit()<br>这里面的proc_kvmmap和kvmmap一样,只不过加了参数指定pagetable</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">pagetable_t</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">proc_kernel_kvminit</span><span class=\"params\">(struct proc *p)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">pagetable_t</span> pagetable;</span><br><span class=\"line\">  pagetable = (<span class=\"keyword\">pagetable_t</span>) kalloc();</span><br><span class=\"line\">  <span class=\"built_in\">memset</span>(pagetable, <span class=\"number\">0</span>, PGSIZE);</span><br><span class=\"line\">  <span class=\"comment\">// uart registers</span></span><br><span class=\"line\">  proc_kvmmap(pagetable, UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class=\"line\">  <span class=\"comment\">// virtio mmio disk interface</span></span><br><span class=\"line\">  proc_kvmmap(pagetable, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// CLINT</span></span><br><span class=\"line\">  proc_kvmmap(pagetable, CLINT, CLINT, <span class=\"number\">0x10000</span>, PTE_R | PTE_W);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// PLIC</span></span><br><span class=\"line\">  proc_kvmmap(pagetable, PLIC, PLIC, <span class=\"number\">0x400000</span>, PTE_R | PTE_W);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// map kernel text executable and read-only.</span></span><br><span class=\"line\">  proc_kvmmap(pagetable, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// map kernel data and the physical RAM we&#x27;ll make use of.</span></span><br><span class=\"line\">  proc_kvmmap(pagetable, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);</span><br><span class=\"line\">  <span class=\"comment\">// map the trampoline for trap entry/exit to</span></span><br><span class=\"line\">  <span class=\"comment\">// the highest virtual address in the kernel.</span></span><br><span class=\"line\">  proc_kvmmap(pagetable, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> pagetable;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>void kprocinit(struct proc *p)<br>内核栈物理内存在procinit()时就已经alloc好了,所以只要在页表里map一下就行</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">kprocinit</span><span class=\"params\">(struct proc *p)</span> </span>&#123;</span><br><span class=\"line\">  uint64 va = KSTACK((<span class=\"keyword\">int</span>) (p - proc));</span><br><span class=\"line\">  uint64 pa = kvmpa(va);</span><br><span class=\"line\">  <span class=\"comment\">//printf(&quot;p-&gt;kstack = %p\\n&quot;, KSTACK((int) (p - proc)));</span></span><br><span class=\"line\">  proc_kvmmap(p-&gt;kpagetable, (uint64)va, (uint64)pa, PGSIZE, PTE_R | PTE_W);</span><br><span class=\"line\">  p-&gt;kstack = va;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>freeproc()<br>加入free kpagetable的过程,首先把用户空间的地址都unmap掉(这是第三个实验要做的),然后proc_free_kpagetable用来free页表.</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">freeproc</span><span class=\"params\">(struct proc *p)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(p-&gt;trapframe)</span><br><span class=\"line\">    kfree((<span class=\"keyword\">void</span>*)p-&gt;trapframe);</span><br><span class=\"line\">  p-&gt;trapframe = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(p-&gt;pagetable)</span><br><span class=\"line\">    proc_freepagetable(p-&gt;pagetable, p-&gt;sz);</span><br><span class=\"line\"></span><br><span class=\"line\">  uvmunmap(p-&gt;kpagetable, <span class=\"number\">0</span>, PGROUNDUP(p-&gt;sz) / PGSIZE, <span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"comment\">//lab3 step2</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (p-&gt;kpagetable)</span><br><span class=\"line\">    proc_free_kpagetable(p);</span><br><span class=\"line\">  p-&gt;pagetable = <span class=\"number\">0</span>;</span><br><span class=\"line\">  p-&gt;kpagetable = <span class=\"number\">0</span>;</span><br><span class=\"line\">  p-&gt;sz = <span class=\"number\">0</span>;</span><br><span class=\"line\">  p-&gt;pid = <span class=\"number\">0</span>;</span><br><span class=\"line\">  p-&gt;parent = <span class=\"number\">0</span>;</span><br><span class=\"line\">  p-&gt;name[<span class=\"number\">0</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">  p-&gt;chan = <span class=\"number\">0</span>;</span><br><span class=\"line\">  p-&gt;killed = <span class=\"number\">0</span>;</span><br><span class=\"line\">  p-&gt;xstate = <span class=\"number\">0</span>;</span><br><span class=\"line\">  p-&gt;state = UNUSED;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>kuvmunmap和uvmunmap相比去掉了panic,这是因为第三个实验map用户地址时会把底层某些地址覆盖掉,然后如果再unmap掉部分虚拟地址,就会导致中间有的地址unmap.比如UART0是0x1000000,如果用户虚拟地址增长到了0x1001000,再sbrk(-1000)删除一页,这样0x1000000-&gt;0x1001000这部分页表是空的,此时freeproc执行kuvmunmap(p-&gt;kpagetable, UART0, 1, 0)时就会出现not mapped的panic.</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">proc_free_kpagetable</span><span class=\"params\">(struct proc *p)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  kuvmunmap(p-&gt;kpagetable, TRAMPOLINE, <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">  kuvmunmap(p-&gt;kpagetable, KSTACK((<span class=\"keyword\">int</span>) (p - proc)), <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">  kuvmunmap(p-&gt;kpagetable, UART0, <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">  kuvmunmap(p-&gt;kpagetable, VIRTIO0, <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">  kuvmunmap(p-&gt;kpagetable, CLINT, <span class=\"number\">0x10000</span> / PGSIZE, <span class=\"number\">0</span>);</span><br><span class=\"line\">  kuvmunmap(p-&gt;kpagetable, PLIC, <span class=\"number\">0x400000</span> / PGSIZE, <span class=\"number\">0</span>);</span><br><span class=\"line\">  kuvmunmap(p-&gt;kpagetable, KERNBASE, (uint64)(etext-KERNBASE) / PGSIZE, <span class=\"number\">0</span>);</span><br><span class=\"line\">  kuvmunmap(p-&gt;kpagetable, (uint64)etext, (PHYSTOP-(uint64)etext) / PGSIZE, <span class=\"number\">0</span>);</span><br><span class=\"line\">  freewalk(p-&gt;kpagetable);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>scheduler()<br>切换进程前切换到对应的kpagetable,某进程退出后回到scheduler使用全局kernel_pagetable</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class=\"line\">      acquire(&amp;p-&gt;lock);</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(p-&gt;state == RUNNABLE) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Switch to chosen process.  It is the process&#x27;s job</span></span><br><span class=\"line\">        <span class=\"comment\">// to release its lock and then reacquire it</span></span><br><span class=\"line\">        <span class=\"comment\">// before jumping back to us.</span></span><br><span class=\"line\">        p-&gt;state = RUNNING;</span><br><span class=\"line\">        c-&gt;proc = p;</span><br><span class=\"line\">        <span class=\"comment\">//lab3 step2</span></span><br><span class=\"line\">        w_satp(MAKE_SATP(p-&gt;kpagetable));</span><br><span class=\"line\">        sfence_vma();</span><br><span class=\"line\"></span><br><span class=\"line\">        swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Process is done running for now.</span></span><br><span class=\"line\">        <span class=\"comment\">// It should have changed its p-&gt;state before coming back.</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//lab3 step2</span></span><br><span class=\"line\">        w_satp(MAKE_SATP(kernel_pagetable));</span><br><span class=\"line\">        sfence_vma();</span><br><span class=\"line\"></span><br><span class=\"line\">        c-&gt;proc = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        found = <span class=\"number\">1</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      release(&amp;p-&gt;lock);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Simplify-copyin-copyinstr\"><a href=\"#Simplify-copyin-copyinstr\" class=\"headerlink\" title=\"Simplify copyin/copyinstr\"></a>Simplify copyin/copyinstr</h3><p>这个实验要完成第3个条件,在kpagetable把用户空间的虚拟地址也map好.hints已经告诉我们在exec(),fork(),growproc()里修改kpagetable就可以了,因为只有这些函数会修改用户pagetable.</p>\n<blockquote>\n<p>exec()<br>这里的逻辑就是把kpagetable底部用户空间的部分先全部unmap掉,再把用户pagetable的内容通过kuvmcopy复制到kpagetable里<br>之所以unmap时不需要free掉物理内存,是因为下面proc_freepagetable(oldpagetable, oldsz)把原先的pagetable释放掉同时free了对应的物理内存.</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">oldpagetable = p-&gt;pagetable;</span><br><span class=\"line\">  p-&gt;pagetable = pagetable;</span><br><span class=\"line\">  p-&gt;sz = sz;</span><br><span class=\"line\">  p-&gt;trapframe-&gt;epc = elf.entry;  <span class=\"comment\">// initial program counter = main</span></span><br><span class=\"line\">  p-&gt;trapframe-&gt;sp = sp; <span class=\"comment\">// initial stack pointer</span></span><br><span class=\"line\">  <span class=\"comment\">//lab3 step3</span></span><br><span class=\"line\">  uvmunmap(p-&gt;kpagetable, <span class=\"number\">0</span>, PGROUNDUP(oldsz) / PGSIZE, <span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (kuvmcopy(p, sz, PTE_R|PTE_W|PTE_X) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    panic(<span class=\"string\">&quot;kuvmcopy&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  w_satp(MAKE_SATP(p-&gt;kpagetable));</span><br><span class=\"line\">  sfence_vma();</span><br><span class=\"line\">  proc_freepagetable(oldpagetable, oldsz);</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>kuvmcopy()<br>把进程new的pagetable底部(即不包含trampoline和trapframe)复制给kpagetable<br>函数mappages_remap和mappages相比去掉了remap的panic,理由在step2里提到了,kpagetable在map时可能需要覆盖某些设备的地址.</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">kuvmcopy</span><span class=\"params\">(struct proc *<span class=\"keyword\">new</span>, uint64 sz, <span class=\"keyword\">int</span> perm)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">pte_t</span> *pte;</span><br><span class=\"line\">  uint64 pa, i;</span><br><span class=\"line\">  <span class=\"keyword\">pagetable_t</span> newpg = <span class=\"keyword\">new</span>-&gt;pagetable;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; sz; i += PGSIZE)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((pte = walk(newpg, i, <span class=\"number\">0</span>)) == <span class=\"number\">0</span>)</span><br><span class=\"line\">      panic(<span class=\"string\">&quot;uvmcopy: pte should exist&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((*pte &amp; PTE_V) == <span class=\"number\">0</span>)</span><br><span class=\"line\">      panic(<span class=\"string\">&quot;uvmcopy: page not present&quot;</span>);</span><br><span class=\"line\">    pa = PTE2PA(*pte);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(mappages_remap(<span class=\"keyword\">new</span>-&gt;kpagetable, i, PGSIZE, pa, perm) != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">goto</span> err;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"> err:</span><br><span class=\"line\">  uvmunmap(<span class=\"keyword\">new</span>-&gt;kpagetable, <span class=\"number\">0</span>, i / PGSIZE, <span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>fork()<br>同理把fork出来的子进程的用户pagetable复制给kpagetable,注意flag不能有PTE_U,因为cpu在suprivisor模式时不能访问设置PTE_U的页</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"><span class=\"comment\">// Copy user memory from parent to child.</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    freeproc(np);</span><br><span class=\"line\">    release(&amp;np-&gt;lock);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(kuvmcopy(np, p-&gt;sz, PTE_R|PTE_W|PTE_X) &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    freeproc(np);</span><br><span class=\"line\">    release(&amp;np-&gt;lock);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>growproc()<br>这个稍微麻烦一点,用户空间增长n时要同时在pagetable和kpagetable进行map,同理n&lt;0也要.</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">growproc</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  uint sz;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">proc</span> *<span class=\"title\">p</span> =</span> myproc();</span><br><span class=\"line\">  <span class=\"comment\">//lab3 step3</span></span><br><span class=\"line\"></span><br><span class=\"line\">  uint oldsz;</span><br><span class=\"line\">  oldsz = sz = p-&gt;sz;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(n &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    sz = kuvmalloc(p, sz, sz + n);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( sz == <span class=\"number\">0</span> ) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sz &gt; PLIC) &#123;</span><br><span class=\"line\">      kuvmdealloc(p, sz, oldsz);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(n &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">      sz = kuvmdealloc(p, sz, sz + n);</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  p-&gt;sz = sz;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>kuvmalloc()<br>和uvmalloc相比加入了给kpagetable进行map的过程,注意在mappages_remap返回-1的时候要不仅要free物理内存,还要把之前mappages()时用户pagetable给unmap掉,一直过不去sbrkfail这个test的原因就是这个.<br>具体来说,比如内存还剩100,kuvmalloc分配第99页后不会触发mem=0,但是执行mappages会把物理内存剩的最后一页用于分配页表,此时执行mappages_remap就会失败(因为没有物理内存了),在这个逻辑下是不应该分配这个第99页的.如果直接执行kuvmdealloc会把用户pagetable第99页的map关系保留下来,导致最后freeproc时panic leaf map.</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">uint64</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">kuvmalloc</span><span class=\"params\">(struct proc *p, uint64 oldsz, uint64 newsz)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">char</span> *mem;</span><br><span class=\"line\">  uint64 a;</span><br><span class=\"line\">  <span class=\"keyword\">pagetable_t</span> pagetable = p-&gt;pagetable;</span><br><span class=\"line\">  <span class=\"keyword\">pagetable_t</span> kpagetable = p-&gt;kpagetable;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(newsz &lt; oldsz)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> oldsz;</span><br><span class=\"line\">  oldsz = PGROUNDUP(oldsz);</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(a = oldsz; a &lt; newsz; a += PGSIZE)&#123;</span><br><span class=\"line\">    mem = kalloc();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(mem == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">      kuvmdealloc(p, a, oldsz);    </span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(mem, <span class=\"number\">0</span>, PGSIZE);    </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(mappages(pagetable, a, PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">      kfree(mem);</span><br><span class=\"line\">      kuvmdealloc(p, a, oldsz);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mappages_remap(kpagetable, a, PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      kfree(mem);</span><br><span class=\"line\">      uvmunmap(pagetable, a, <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">      kuvmdealloc(p, a, oldsz);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> newsz;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>kuvmdealloc()<br>仿照uvmdealloc就行</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">uint64</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">kuvmdealloc</span><span class=\"params\">(struct proc *p, uint64 oldsz, uint64 newsz)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">pagetable_t</span> pagetable = p-&gt;pagetable;</span><br><span class=\"line\">  <span class=\"keyword\">pagetable_t</span> kpagetable = p-&gt;kpagetable;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(newsz &gt;= oldsz)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> oldsz;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(PGROUNDUP(newsz) &lt; PGROUNDUP(oldsz))&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> npages = (PGROUNDUP(oldsz) - PGROUNDUP(newsz)) / PGSIZE;</span><br><span class=\"line\">    uvmunmap(pagetable, PGROUNDUP(newsz), npages, <span class=\"number\">1</span>);</span><br><span class=\"line\">    kuvmunmap(kpagetable, PGROUNDUP(newsz), npages, <span class=\"number\">0</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> newsz;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"实验结果\"><a href=\"#实验结果\" class=\"headerlink\" title=\"实验结果\"></a>实验结果</h3><p><img src=\"https://pic3.zhimg.com/80/v2-d0566e3093b15954bdaedd4d1fcdf192_720w.jpg\" alt=\"img\"></p>\n<h3 id=\"心得\"><a href=\"#心得\" class=\"headerlink\" title=\"心得\"></a>心得</h3><p>主要是要先看懂几个重要函数的作用,弄懂陷入内核态和返回用户态的过程,理解内核页表和用户页表的内存分布,搞清楚实验目的是什么.接下来就是耐心debug了,如果usertests某些测试一直通不过可以看一下这个test做了些什么,以此定位哪里的代码可能出错.</p>\n"},{"title":"MIT6.S081 Lab6 Cow","date":"2021-10-09T04:00:00.000Z","_content":"\n## **COW fork**\n\nfork的时候xv6会为子进程立刻分配所需的物理内存，并把父进程的用户内存复制过去。这样造成了时空上的浪费。写时复制指的是fork时不立刻分配物理内存，而是父子进程共用父进程的地址空间。\n\n实现这个功能主要要实现3个部分：\n\n1.fork时将子进程地址空间逐页map到和父进程一样的地址空间，并且把父子进程页表项设置为不可写。\n\n2.当某个进程要写一个COW map的不可写页时，此时这个进程就不能和其他进程共享这一页了，需要另外开辟新的物理内存并map，这一部分通过处理page fault实现。\n\n3.注意物理页free的时机，如果某一物理页被多个进程共享，那么即使其中某一个进程不再使用它，它也不能被free。当最后一个使用它的进程free这一页时才真正释放。\n\n第一个部分在uvmcopy函数中实现，fork会调用uvmcopy来把父进程地址空间复制给子进程：\n\n> 在原uvmcopy的基础上删除了分配内存的过程。逐页地，把父进程的物理地址map到子进程的页表中去。\n> 注意flag的设置，要把PTE_W位清除，并且set了flag中的保留位，用于指明这是一个由于COW fork而导致无法write的页。这是有必要的，因为操作系统不能保证用户程序不是恶意的，用户程序可能写一个它本不该写的页，如果不判断是否为COW map的页，到pagefault处理完用户程序就变得能够写这个页，这是不安全的。pte的flag如下图。\n> incref用于增加pa对应页的ref count，下面会说\n\n![img](https://pic2.zhimg.com/80/v2-707f039c178ba7db7fa04330baa66541_720w.jpg)\n\n```c\nint\nuvmcopy(pagetable_t old, pagetable_t new, uint64 sz)\n{\n  pte_t *pte;\n  uint64 pa, i;\n  uint flags;\n\n  for(i = 0; i < sz; i += PGSIZE){\n    if((pte = walk(old, i, 0)) == 0)\n      panic(\"uvmcopy: pte should exist\");\n    if((*pte & PTE_V) == 0)\n      panic(\"uvmcopy: page not present\");\n    pa = PTE2PA(*pte);\n    flags = PTE_FLAGS(*pte);\n    flags = (flags & ~PTE_W) | PTE_RESERVE;\n    *pte = (~(*pte ^ ~PTE_W)) | PTE_RESERVE;\n    if (mappages(new, i, PGSIZE, (uint64)pa, flags) != 0) {\n      goto err;\n    }\n    incref(pa);\n  }\n  return 0;\n\n  err:\n   uvmunmap(new, 0, i / PGSIZE, 1);\n   return -1;\n}\n```\n\n\n\n第二部分实现物理内存的分配，有两种情况会导致写共享页：用户程序主动写和内核缓存复制到用户空间（如read系统调用）。第一种情况需要在usertrap中处理pagefault：\n\n> 首先判断用户要写的这一页是否为COWmap页，如果不是则杀死进程，然后分配物理内存并map\n\n```c\n... \nelse if (r_scause() == 15) {\n      uint64 va = r_stval();\n      pte_t *pte = walk(p->pagetable, va, 0);\n      if (!(PTE_FLAGS(*pte)&PTE_RESERVE)) {\n        p->killed = 1;\n      }\n      else {\n        va = PGROUNDDOWN(va);\n        uint64 ka = (uint64)kalloc();\n        if (ka == 0) {\n          p->killed = 1;\n        }\n        else {\n          uint flags = PTE_FLAGS(*pte);\n          flags = flags & ~PTE_RESERVE;\n          uint64 pa = walkaddr(p->pagetable, va);\n          memmove((void*)ka, (void*)pa, PGSIZE);\n          uvmunmap(p->pagetable, va, 1, 1);\n          mappages(p->pagetable, va, 1, ka, flags | PTE_W); \n        }\n      }\n  }\n...\n```\n\n第二种情况在copyout中实现，和上面差不多：\n\n```c\nint\ncopyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)\n{\n  uint64 n, va0, pa0;\n  if (dstva > MAXVA - len) return -1; \n  while(len > 0){\n    va0 = PGROUNDDOWN(dstva);\n    pte_t* pte = walk(pagetable, va0, 0);\n    if (pte == 0) return -1;\n    if (!(PTE_FLAGS(*pte) & PTE_W)) {\n      if (!(PTE_FLAGS(*pte) & PTE_RESERVE)) {\n        return -1;\n      }\n      uint64 va = va0;\n      uint64 ka = (uint64)kalloc();\n      if (ka == 0) {\n        return -1;\n      }\n      else {\n        uint flags = PTE_FLAGS(*pte);\n        flags = flags & ~PTE_RESERVE;\n        uint64 pa = walkaddr(pagetable, va);\n        if (pa == 0) return -1;\n        memmove((void*)ka, (void*)pa, PGSIZE);\n        uvmunmap(pagetable, va, 1, 1);\n        mappages(pagetable, va, 1, ka, flags | PTE_W); \n      }\n    }\n    pa0 = walkaddr(pagetable, va0);\n    if(pa0 == 0)\n      return -1;\n    n = PGSIZE - (dstva - va0);\n    if(n > len)\n      n = len;\n    memmove((void *)(pa0 + (dstva - va0)), src, n);\n\n    len -= n;\n    src += n;\n    dstva = va0 + PGSIZE;\n  }\n  return 0;\n}\n```\n\n最后是free物理页面的问题，我们需要一个数据结构保存每个页面的引用次数ref count，当一个页面引用次数到达0时才可真正释放，数据结构设置在kalloc.c中：\n\n> 因为最大进程数NPROC为64，所以用1个字节保存引用数足以。每个页面用右移12位的页面序号作为index。\n\n```text\nuint8 refcount[PHYSTOP / PGSIZE];\n...\nvoid incref(uint64 va) {\n  refcount[va/PGSIZE]++;\n}\n```\n\n> 每次调用kfree时先减引用数，引用数为0再真正释放：\n\n```c\nvoid\nkfree(void *pa)\n{\n  struct run *r;\n\n  if(((uint64)pa % PGSIZE) != 0 || (char*)pa < end || (uint64)pa >= PHYSTOP)\n    panic(\"kfree\");\n\n  // Fill with junk to catch dangling refs.\n  if (--refcount[(uint64)pa / PGSIZE] > 0) \n    return ;\n  memset(pa, 1, PGSIZE);\n\n  r = (struct run*)pa;\n\n  acquire(&kmem.lock);\n  r->next = kmem.freelist;\n  kmem.freelist = r;\n  release(&kmem.lock);\n}\n```\n\n> 初始化的时候在freerange把refcount设置为0（这里设置为1再kfree就变成0了）。每次kalloc即初次分配时把refcount设置为1：\n\n```c\nvoid\nfreerange(void *pa_start, void *pa_end)\n{\n  char *p;\n  p = (char*)PGROUNDUP((uint64)pa_start);\n  for(; p + PGSIZE <= (char*)pa_end; p += PGSIZE)\n  {\n    refcount[(uint64)p / PGSIZE] = 1;\n    kfree(p);\n  }\n}\n\nvoid *\nkalloc(void)\n{\n  struct run *r;\n\n  acquire(&kmem.lock);\n  r = kmem.freelist;\n  if(r)\n    kmem.freelist = r->next;\n  release(&kmem.lock);\n\n  if(r) {\n    memset((char*)r, 5, PGSIZE); // fill with junk\n    refcount[(uint64)r / PGSIZE] = 1;\n  }\n  return (void*)r;\n}\n```\n\n结果：\n\n![img](https://pic4.zhimg.com/80/v2-16198edaae5d2659e976b78ef9dfe693_720w.jpg)\n\n## 心得\n\ndebug的时候可以在lab3 vmprint基础上输出一下flag以及对应的refcount查看有没有错误。","source":"_posts/MIT6.S081 Lab6.md","raw":"---\ntitle: MIT6.S081 Lab6 cow\ndate: 2021-10-09 12:00:00\ntags: 6.S081\n---\n\n## **COW fork**\n\nfork的时候xv6会为子进程立刻分配所需的物理内存，并把父进程的用户内存复制过去。这样造成了时空上的浪费。写时复制指的是fork时不立刻分配物理内存，而是父子进程共用父进程的地址空间。\n\n实现这个功能主要要实现3个部分：\n\n1.fork时将子进程地址空间逐页map到和父进程一样的地址空间，并且把父子进程页表项设置为不可写。\n\n2.当某个进程要写一个COW map的不可写页时，此时这个进程就不能和其他进程共享这一页了，需要另外开辟新的物理内存并map，这一部分通过处理page fault实现。\n\n3.注意物理页free的时机，如果某一物理页被多个进程共享，那么即使其中某一个进程不再使用它，它也不能被free。当最后一个使用它的进程free这一页时才真正释放。\n\n第一个部分在uvmcopy函数中实现，fork会调用uvmcopy来把父进程地址空间复制给子进程：\n\n> 在原uvmcopy的基础上删除了分配内存的过程。逐页地，把父进程的物理地址map到子进程的页表中去。\n> 注意flag的设置，要把PTE_W位清除，并且set了flag中的保留位，用于指明这是一个由于COW fork而导致无法write的页。这是有必要的，因为操作系统不能保证用户程序不是恶意的，用户程序可能写一个它本不该写的页，如果不判断是否为COW map的页，到pagefault处理完用户程序就变得能够写这个页，这是不安全的。pte的flag如下图。\n> incref用于增加pa对应页的ref count，下面会说\n\n![img](https://pic2.zhimg.com/80/v2-707f039c178ba7db7fa04330baa66541_720w.jpg)\n\n```c\nint\nuvmcopy(pagetable_t old, pagetable_t new, uint64 sz)\n{\n  pte_t *pte;\n  uint64 pa, i;\n  uint flags;\n\n  for(i = 0; i < sz; i += PGSIZE){\n    if((pte = walk(old, i, 0)) == 0)\n      panic(\"uvmcopy: pte should exist\");\n    if((*pte & PTE_V) == 0)\n      panic(\"uvmcopy: page not present\");\n    pa = PTE2PA(*pte);\n    flags = PTE_FLAGS(*pte);\n    flags = (flags & ~PTE_W) | PTE_RESERVE;\n    *pte = (~(*pte ^ ~PTE_W)) | PTE_RESERVE;\n    if (mappages(new, i, PGSIZE, (uint64)pa, flags) != 0) {\n      goto err;\n    }\n    incref(pa);\n  }\n  return 0;\n\n  err:\n   uvmunmap(new, 0, i / PGSIZE, 1);\n   return -1;\n}\n```\n\n\n\n第二部分实现物理内存的分配，有两种情况会导致写共享页：用户程序主动写和内核缓存复制到用户空间（如read系统调用）。第一种情况需要在usertrap中处理pagefault：\n\n> 首先判断用户要写的这一页是否为COWmap页，如果不是则杀死进程，然后分配物理内存并map\n\n```c\n... \nelse if (r_scause() == 15) {\n      uint64 va = r_stval();\n      pte_t *pte = walk(p->pagetable, va, 0);\n      if (!(PTE_FLAGS(*pte)&PTE_RESERVE)) {\n        p->killed = 1;\n      }\n      else {\n        va = PGROUNDDOWN(va);\n        uint64 ka = (uint64)kalloc();\n        if (ka == 0) {\n          p->killed = 1;\n        }\n        else {\n          uint flags = PTE_FLAGS(*pte);\n          flags = flags & ~PTE_RESERVE;\n          uint64 pa = walkaddr(p->pagetable, va);\n          memmove((void*)ka, (void*)pa, PGSIZE);\n          uvmunmap(p->pagetable, va, 1, 1);\n          mappages(p->pagetable, va, 1, ka, flags | PTE_W); \n        }\n      }\n  }\n...\n```\n\n第二种情况在copyout中实现，和上面差不多：\n\n```c\nint\ncopyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)\n{\n  uint64 n, va0, pa0;\n  if (dstva > MAXVA - len) return -1; \n  while(len > 0){\n    va0 = PGROUNDDOWN(dstva);\n    pte_t* pte = walk(pagetable, va0, 0);\n    if (pte == 0) return -1;\n    if (!(PTE_FLAGS(*pte) & PTE_W)) {\n      if (!(PTE_FLAGS(*pte) & PTE_RESERVE)) {\n        return -1;\n      }\n      uint64 va = va0;\n      uint64 ka = (uint64)kalloc();\n      if (ka == 0) {\n        return -1;\n      }\n      else {\n        uint flags = PTE_FLAGS(*pte);\n        flags = flags & ~PTE_RESERVE;\n        uint64 pa = walkaddr(pagetable, va);\n        if (pa == 0) return -1;\n        memmove((void*)ka, (void*)pa, PGSIZE);\n        uvmunmap(pagetable, va, 1, 1);\n        mappages(pagetable, va, 1, ka, flags | PTE_W); \n      }\n    }\n    pa0 = walkaddr(pagetable, va0);\n    if(pa0 == 0)\n      return -1;\n    n = PGSIZE - (dstva - va0);\n    if(n > len)\n      n = len;\n    memmove((void *)(pa0 + (dstva - va0)), src, n);\n\n    len -= n;\n    src += n;\n    dstva = va0 + PGSIZE;\n  }\n  return 0;\n}\n```\n\n最后是free物理页面的问题，我们需要一个数据结构保存每个页面的引用次数ref count，当一个页面引用次数到达0时才可真正释放，数据结构设置在kalloc.c中：\n\n> 因为最大进程数NPROC为64，所以用1个字节保存引用数足以。每个页面用右移12位的页面序号作为index。\n\n```text\nuint8 refcount[PHYSTOP / PGSIZE];\n...\nvoid incref(uint64 va) {\n  refcount[va/PGSIZE]++;\n}\n```\n\n> 每次调用kfree时先减引用数，引用数为0再真正释放：\n\n```c\nvoid\nkfree(void *pa)\n{\n  struct run *r;\n\n  if(((uint64)pa % PGSIZE) != 0 || (char*)pa < end || (uint64)pa >= PHYSTOP)\n    panic(\"kfree\");\n\n  // Fill with junk to catch dangling refs.\n  if (--refcount[(uint64)pa / PGSIZE] > 0) \n    return ;\n  memset(pa, 1, PGSIZE);\n\n  r = (struct run*)pa;\n\n  acquire(&kmem.lock);\n  r->next = kmem.freelist;\n  kmem.freelist = r;\n  release(&kmem.lock);\n}\n```\n\n> 初始化的时候在freerange把refcount设置为0（这里设置为1再kfree就变成0了）。每次kalloc即初次分配时把refcount设置为1：\n\n```c\nvoid\nfreerange(void *pa_start, void *pa_end)\n{\n  char *p;\n  p = (char*)PGROUNDUP((uint64)pa_start);\n  for(; p + PGSIZE <= (char*)pa_end; p += PGSIZE)\n  {\n    refcount[(uint64)p / PGSIZE] = 1;\n    kfree(p);\n  }\n}\n\nvoid *\nkalloc(void)\n{\n  struct run *r;\n\n  acquire(&kmem.lock);\n  r = kmem.freelist;\n  if(r)\n    kmem.freelist = r->next;\n  release(&kmem.lock);\n\n  if(r) {\n    memset((char*)r, 5, PGSIZE); // fill with junk\n    refcount[(uint64)r / PGSIZE] = 1;\n  }\n  return (void*)r;\n}\n```\n\n结果：\n\n![img](https://pic4.zhimg.com/80/v2-16198edaae5d2659e976b78ef9dfe693_720w.jpg)\n\n## 心得\n\ndebug的时候可以在lab3 vmprint基础上输出一下flag以及对应的refcount查看有没有错误。","slug":"MIT6.S081 Lab6","published":1,"updated":"2021-11-05T04:49:44.800Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckvlyb07b000304v68u19hmg9","content":"<h2 id=\"COW-fork\"><a href=\"#COW-fork\" class=\"headerlink\" title=\"COW fork\"></a><strong>COW fork</strong></h2><p>fork的时候xv6会为子进程立刻分配所需的物理内存，并把父进程的用户内存复制过去。这样造成了时空上的浪费。写时复制指的是fork时不立刻分配物理内存，而是父子进程共用父进程的地址空间。</p>\n<p>实现这个功能主要要实现3个部分：</p>\n<p>1.fork时将子进程地址空间逐页map到和父进程一样的地址空间，并且把父子进程页表项设置为不可写。</p>\n<p>2.当某个进程要写一个COW map的不可写页时，此时这个进程就不能和其他进程共享这一页了，需要另外开辟新的物理内存并map，这一部分通过处理page fault实现。</p>\n<p>3.注意物理页free的时机，如果某一物理页被多个进程共享，那么即使其中某一个进程不再使用它，它也不能被free。当最后一个使用它的进程free这一页时才真正释放。</p>\n<p>第一个部分在uvmcopy函数中实现，fork会调用uvmcopy来把父进程地址空间复制给子进程：</p>\n<blockquote>\n<p>在原uvmcopy的基础上删除了分配内存的过程。逐页地，把父进程的物理地址map到子进程的页表中去。<br>注意flag的设置，要把PTE_W位清除，并且set了flag中的保留位，用于指明这是一个由于COW fork而导致无法write的页。这是有必要的，因为操作系统不能保证用户程序不是恶意的，用户程序可能写一个它本不该写的页，如果不判断是否为COW map的页，到pagefault处理完用户程序就变得能够写这个页，这是不安全的。pte的flag如下图。<br>incref用于增加pa对应页的ref count，下面会说</p>\n</blockquote>\n<p><img src=\"https://pic2.zhimg.com/80/v2-707f039c178ba7db7fa04330baa66541_720w.jpg\" alt=\"img\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">uvmcopy</span><span class=\"params\">(<span class=\"keyword\">pagetable_t</span> old, <span class=\"keyword\">pagetable_t</span> <span class=\"keyword\">new</span>, uint64 sz)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">pte_t</span> *pte;</span><br><span class=\"line\">  uint64 pa, i;</span><br><span class=\"line\">  uint flags;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; sz; i += PGSIZE)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((pte = walk(old, i, <span class=\"number\">0</span>)) == <span class=\"number\">0</span>)</span><br><span class=\"line\">      panic(<span class=\"string\">&quot;uvmcopy: pte should exist&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((*pte &amp; PTE_V) == <span class=\"number\">0</span>)</span><br><span class=\"line\">      panic(<span class=\"string\">&quot;uvmcopy: page not present&quot;</span>);</span><br><span class=\"line\">    pa = PTE2PA(*pte);</span><br><span class=\"line\">    flags = PTE_FLAGS(*pte);</span><br><span class=\"line\">    flags = (flags &amp; ~PTE_W) | PTE_RESERVE;</span><br><span class=\"line\">    *pte = (~(*pte ^ ~PTE_W)) | PTE_RESERVE;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mappages(<span class=\"keyword\">new</span>, i, PGSIZE, (uint64)pa, flags) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">goto</span> err;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    incref(pa);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  err:</span><br><span class=\"line\">   uvmunmap(<span class=\"keyword\">new</span>, <span class=\"number\">0</span>, i / PGSIZE, <span class=\"number\">1</span>);</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>第二部分实现物理内存的分配，有两种情况会导致写共享页：用户程序主动写和内核缓存复制到用户空间（如read系统调用）。第一种情况需要在usertrap中处理pagefault：</p>\n<blockquote>\n<p>首先判断用户要写的这一页是否为COWmap页，如果不是则杀死进程，然后分配物理内存并map</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">... </span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (r_scause() == <span class=\"number\">15</span>) &#123;</span><br><span class=\"line\">      uint64 va = r_stval();</span><br><span class=\"line\">      <span class=\"keyword\">pte_t</span> *pte = walk(p-&gt;pagetable, va, <span class=\"number\">0</span>);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!(PTE_FLAGS(*pte)&amp;PTE_RESERVE)) &#123;</span><br><span class=\"line\">        p-&gt;killed = <span class=\"number\">1</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        va = PGROUNDDOWN(va);</span><br><span class=\"line\">        uint64 ka = (uint64)kalloc();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ka == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">          p-&gt;killed = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          uint flags = PTE_FLAGS(*pte);</span><br><span class=\"line\">          flags = flags &amp; ~PTE_RESERVE;</span><br><span class=\"line\">          uint64 pa = walkaddr(p-&gt;pagetable, va);</span><br><span class=\"line\">          memmove((<span class=\"keyword\">void</span>*)ka, (<span class=\"keyword\">void</span>*)pa, PGSIZE);</span><br><span class=\"line\">          uvmunmap(p-&gt;pagetable, va, <span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">          mappages(p-&gt;pagetable, va, <span class=\"number\">1</span>, ka, flags | PTE_W); </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>第二种情况在copyout中实现，和上面差不多：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">copyout</span><span class=\"params\">(<span class=\"keyword\">pagetable_t</span> pagetable, uint64 dstva, <span class=\"keyword\">char</span> *src, uint64 len)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  uint64 n, va0, pa0;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (dstva &gt; MAXVA - len) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>; </span><br><span class=\"line\">  <span class=\"keyword\">while</span>(len &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    va0 = PGROUNDDOWN(dstva);</span><br><span class=\"line\">    <span class=\"keyword\">pte_t</span>* pte = walk(pagetable, va0, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pte == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!(PTE_FLAGS(*pte) &amp; PTE_W)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!(PTE_FLAGS(*pte) &amp; PTE_RESERVE)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      uint64 va = va0;</span><br><span class=\"line\">      uint64 ka = (uint64)kalloc();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (ka == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        uint flags = PTE_FLAGS(*pte);</span><br><span class=\"line\">        flags = flags &amp; ~PTE_RESERVE;</span><br><span class=\"line\">        uint64 pa = walkaddr(pagetable, va);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pa == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        memmove((<span class=\"keyword\">void</span>*)ka, (<span class=\"keyword\">void</span>*)pa, PGSIZE);</span><br><span class=\"line\">        uvmunmap(pagetable, va, <span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        mappages(pagetable, va, <span class=\"number\">1</span>, ka, flags | PTE_W); </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pa0 = walkaddr(pagetable, va0);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(pa0 == <span class=\"number\">0</span>)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    n = PGSIZE - (dstva - va0);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n &gt; len)</span><br><span class=\"line\">      n = len;</span><br><span class=\"line\">    memmove((<span class=\"keyword\">void</span> *)(pa0 + (dstva - va0)), src, n);</span><br><span class=\"line\"></span><br><span class=\"line\">    len -= n;</span><br><span class=\"line\">    src += n;</span><br><span class=\"line\">    dstva = va0 + PGSIZE;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后是free物理页面的问题，我们需要一个数据结构保存每个页面的引用次数ref count，当一个页面引用次数到达0时才可真正释放，数据结构设置在kalloc.c中：</p>\n<blockquote>\n<p>因为最大进程数NPROC为64，所以用1个字节保存引用数足以。每个页面用右移12位的页面序号作为index。</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uint8 refcount[PHYSTOP / PGSIZE];</span><br><span class=\"line\">...</span><br><span class=\"line\">void incref(uint64 va) &#123;</span><br><span class=\"line\">  refcount[va/PGSIZE]++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>每次调用kfree时先减引用数，引用数为0再真正释放：</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">kfree</span><span class=\"params\">(<span class=\"keyword\">void</span> *pa)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">run</span> *<span class=\"title\">r</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(((uint64)pa % PGSIZE) != <span class=\"number\">0</span> || (<span class=\"keyword\">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class=\"line\">    panic(<span class=\"string\">&quot;kfree&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Fill with junk to catch dangling refs.</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (--refcount[(uint64)pa / PGSIZE] &gt; <span class=\"number\">0</span>) </span><br><span class=\"line\">    <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">  <span class=\"built_in\">memset</span>(pa, <span class=\"number\">1</span>, PGSIZE);</span><br><span class=\"line\"></span><br><span class=\"line\">  r = (struct run*)pa;</span><br><span class=\"line\"></span><br><span class=\"line\">  acquire(&amp;kmem.lock);</span><br><span class=\"line\">  r-&gt;next = kmem.freelist;</span><br><span class=\"line\">  kmem.freelist = r;</span><br><span class=\"line\">  release(&amp;kmem.lock);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>初始化的时候在freerange把refcount设置为0（这里设置为1再kfree就变成0了）。每次kalloc即初次分配时把refcount设置为1：</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">freerange</span><span class=\"params\">(<span class=\"keyword\">void</span> *pa_start, <span class=\"keyword\">void</span> *pa_end)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">char</span> *p;</span><br><span class=\"line\">  p = (<span class=\"keyword\">char</span>*)PGROUNDUP((uint64)pa_start);</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(; p + PGSIZE &lt;= (<span class=\"keyword\">char</span>*)pa_end; p += PGSIZE)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    refcount[(uint64)p / PGSIZE] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    kfree(p);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">kalloc</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">run</span> *<span class=\"title\">r</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  acquire(&amp;kmem.lock);</span><br><span class=\"line\">  r = kmem.freelist;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(r)</span><br><span class=\"line\">    kmem.freelist = r-&gt;next;</span><br><span class=\"line\">  release(&amp;kmem.lock);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(r) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>((<span class=\"keyword\">char</span>*)r, <span class=\"number\">5</span>, PGSIZE); <span class=\"comment\">// fill with junk</span></span><br><span class=\"line\">    refcount[(uint64)r / PGSIZE] = <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"keyword\">void</span>*)r;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>结果：</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-16198edaae5d2659e976b78ef9dfe693_720w.jpg\" alt=\"img\"></p>\n<h2 id=\"心得\"><a href=\"#心得\" class=\"headerlink\" title=\"心得\"></a>心得</h2><p>debug的时候可以在lab3 vmprint基础上输出一下flag以及对应的refcount查看有没有错误。</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/bg.jpg\");\n  background-repeat: no-repeat;\n  background-size: cover;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.9;\n}\n.header-inner {\n  background: rgba(255,255,255,0.85);\n}\n.popup {\n  opacity: 0.85;\n}\n.sidebar {\n  background-color: transparent;\n}\n","variables":""}},"excerpt":"","more":"<h2 id=\"COW-fork\"><a href=\"#COW-fork\" class=\"headerlink\" title=\"COW fork\"></a><strong>COW fork</strong></h2><p>fork的时候xv6会为子进程立刻分配所需的物理内存，并把父进程的用户内存复制过去。这样造成了时空上的浪费。写时复制指的是fork时不立刻分配物理内存，而是父子进程共用父进程的地址空间。</p>\n<p>实现这个功能主要要实现3个部分：</p>\n<p>1.fork时将子进程地址空间逐页map到和父进程一样的地址空间，并且把父子进程页表项设置为不可写。</p>\n<p>2.当某个进程要写一个COW map的不可写页时，此时这个进程就不能和其他进程共享这一页了，需要另外开辟新的物理内存并map，这一部分通过处理page fault实现。</p>\n<p>3.注意物理页free的时机，如果某一物理页被多个进程共享，那么即使其中某一个进程不再使用它，它也不能被free。当最后一个使用它的进程free这一页时才真正释放。</p>\n<p>第一个部分在uvmcopy函数中实现，fork会调用uvmcopy来把父进程地址空间复制给子进程：</p>\n<blockquote>\n<p>在原uvmcopy的基础上删除了分配内存的过程。逐页地，把父进程的物理地址map到子进程的页表中去。<br>注意flag的设置，要把PTE_W位清除，并且set了flag中的保留位，用于指明这是一个由于COW fork而导致无法write的页。这是有必要的，因为操作系统不能保证用户程序不是恶意的，用户程序可能写一个它本不该写的页，如果不判断是否为COW map的页，到pagefault处理完用户程序就变得能够写这个页，这是不安全的。pte的flag如下图。<br>incref用于增加pa对应页的ref count，下面会说</p>\n</blockquote>\n<p><img src=\"https://pic2.zhimg.com/80/v2-707f039c178ba7db7fa04330baa66541_720w.jpg\" alt=\"img\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">uvmcopy</span><span class=\"params\">(<span class=\"keyword\">pagetable_t</span> old, <span class=\"keyword\">pagetable_t</span> <span class=\"keyword\">new</span>, uint64 sz)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">pte_t</span> *pte;</span><br><span class=\"line\">  uint64 pa, i;</span><br><span class=\"line\">  uint flags;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; sz; i += PGSIZE)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((pte = walk(old, i, <span class=\"number\">0</span>)) == <span class=\"number\">0</span>)</span><br><span class=\"line\">      panic(<span class=\"string\">&quot;uvmcopy: pte should exist&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((*pte &amp; PTE_V) == <span class=\"number\">0</span>)</span><br><span class=\"line\">      panic(<span class=\"string\">&quot;uvmcopy: page not present&quot;</span>);</span><br><span class=\"line\">    pa = PTE2PA(*pte);</span><br><span class=\"line\">    flags = PTE_FLAGS(*pte);</span><br><span class=\"line\">    flags = (flags &amp; ~PTE_W) | PTE_RESERVE;</span><br><span class=\"line\">    *pte = (~(*pte ^ ~PTE_W)) | PTE_RESERVE;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (mappages(<span class=\"keyword\">new</span>, i, PGSIZE, (uint64)pa, flags) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">goto</span> err;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    incref(pa);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  err:</span><br><span class=\"line\">   uvmunmap(<span class=\"keyword\">new</span>, <span class=\"number\">0</span>, i / PGSIZE, <span class=\"number\">1</span>);</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>第二部分实现物理内存的分配，有两种情况会导致写共享页：用户程序主动写和内核缓存复制到用户空间（如read系统调用）。第一种情况需要在usertrap中处理pagefault：</p>\n<blockquote>\n<p>首先判断用户要写的这一页是否为COWmap页，如果不是则杀死进程，然后分配物理内存并map</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">... </span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (r_scause() == <span class=\"number\">15</span>) &#123;</span><br><span class=\"line\">      uint64 va = r_stval();</span><br><span class=\"line\">      <span class=\"keyword\">pte_t</span> *pte = walk(p-&gt;pagetable, va, <span class=\"number\">0</span>);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!(PTE_FLAGS(*pte)&amp;PTE_RESERVE)) &#123;</span><br><span class=\"line\">        p-&gt;killed = <span class=\"number\">1</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        va = PGROUNDDOWN(va);</span><br><span class=\"line\">        uint64 ka = (uint64)kalloc();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (ka == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">          p-&gt;killed = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          uint flags = PTE_FLAGS(*pte);</span><br><span class=\"line\">          flags = flags &amp; ~PTE_RESERVE;</span><br><span class=\"line\">          uint64 pa = walkaddr(p-&gt;pagetable, va);</span><br><span class=\"line\">          memmove((<span class=\"keyword\">void</span>*)ka, (<span class=\"keyword\">void</span>*)pa, PGSIZE);</span><br><span class=\"line\">          uvmunmap(p-&gt;pagetable, va, <span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">          mappages(p-&gt;pagetable, va, <span class=\"number\">1</span>, ka, flags | PTE_W); </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>第二种情况在copyout中实现，和上面差不多：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">copyout</span><span class=\"params\">(<span class=\"keyword\">pagetable_t</span> pagetable, uint64 dstva, <span class=\"keyword\">char</span> *src, uint64 len)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  uint64 n, va0, pa0;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (dstva &gt; MAXVA - len) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>; </span><br><span class=\"line\">  <span class=\"keyword\">while</span>(len &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    va0 = PGROUNDDOWN(dstva);</span><br><span class=\"line\">    <span class=\"keyword\">pte_t</span>* pte = walk(pagetable, va0, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pte == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!(PTE_FLAGS(*pte) &amp; PTE_W)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!(PTE_FLAGS(*pte) &amp; PTE_RESERVE)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      uint64 va = va0;</span><br><span class=\"line\">      uint64 ka = (uint64)kalloc();</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (ka == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        uint flags = PTE_FLAGS(*pte);</span><br><span class=\"line\">        flags = flags &amp; ~PTE_RESERVE;</span><br><span class=\"line\">        uint64 pa = walkaddr(pagetable, va);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pa == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        memmove((<span class=\"keyword\">void</span>*)ka, (<span class=\"keyword\">void</span>*)pa, PGSIZE);</span><br><span class=\"line\">        uvmunmap(pagetable, va, <span class=\"number\">1</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">        mappages(pagetable, va, <span class=\"number\">1</span>, ka, flags | PTE_W); </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pa0 = walkaddr(pagetable, va0);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(pa0 == <span class=\"number\">0</span>)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    n = PGSIZE - (dstva - va0);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n &gt; len)</span><br><span class=\"line\">      n = len;</span><br><span class=\"line\">    memmove((<span class=\"keyword\">void</span> *)(pa0 + (dstva - va0)), src, n);</span><br><span class=\"line\"></span><br><span class=\"line\">    len -= n;</span><br><span class=\"line\">    src += n;</span><br><span class=\"line\">    dstva = va0 + PGSIZE;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后是free物理页面的问题，我们需要一个数据结构保存每个页面的引用次数ref count，当一个页面引用次数到达0时才可真正释放，数据结构设置在kalloc.c中：</p>\n<blockquote>\n<p>因为最大进程数NPROC为64，所以用1个字节保存引用数足以。每个页面用右移12位的页面序号作为index。</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uint8 refcount[PHYSTOP / PGSIZE];</span><br><span class=\"line\">...</span><br><span class=\"line\">void incref(uint64 va) &#123;</span><br><span class=\"line\">  refcount[va/PGSIZE]++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>每次调用kfree时先减引用数，引用数为0再真正释放：</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">kfree</span><span class=\"params\">(<span class=\"keyword\">void</span> *pa)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">run</span> *<span class=\"title\">r</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(((uint64)pa % PGSIZE) != <span class=\"number\">0</span> || (<span class=\"keyword\">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class=\"line\">    panic(<span class=\"string\">&quot;kfree&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Fill with junk to catch dangling refs.</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (--refcount[(uint64)pa / PGSIZE] &gt; <span class=\"number\">0</span>) </span><br><span class=\"line\">    <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">  <span class=\"built_in\">memset</span>(pa, <span class=\"number\">1</span>, PGSIZE);</span><br><span class=\"line\"></span><br><span class=\"line\">  r = (struct run*)pa;</span><br><span class=\"line\"></span><br><span class=\"line\">  acquire(&amp;kmem.lock);</span><br><span class=\"line\">  r-&gt;next = kmem.freelist;</span><br><span class=\"line\">  kmem.freelist = r;</span><br><span class=\"line\">  release(&amp;kmem.lock);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>初始化的时候在freerange把refcount设置为0（这里设置为1再kfree就变成0了）。每次kalloc即初次分配时把refcount设置为1：</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">freerange</span><span class=\"params\">(<span class=\"keyword\">void</span> *pa_start, <span class=\"keyword\">void</span> *pa_end)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">char</span> *p;</span><br><span class=\"line\">  p = (<span class=\"keyword\">char</span>*)PGROUNDUP((uint64)pa_start);</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(; p + PGSIZE &lt;= (<span class=\"keyword\">char</span>*)pa_end; p += PGSIZE)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    refcount[(uint64)p / PGSIZE] = <span class=\"number\">1</span>;</span><br><span class=\"line\">    kfree(p);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">kalloc</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">run</span> *<span class=\"title\">r</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  acquire(&amp;kmem.lock);</span><br><span class=\"line\">  r = kmem.freelist;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(r)</span><br><span class=\"line\">    kmem.freelist = r-&gt;next;</span><br><span class=\"line\">  release(&amp;kmem.lock);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(r) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>((<span class=\"keyword\">char</span>*)r, <span class=\"number\">5</span>, PGSIZE); <span class=\"comment\">// fill with junk</span></span><br><span class=\"line\">    refcount[(uint64)r / PGSIZE] = <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"keyword\">void</span>*)r;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>结果：</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-16198edaae5d2659e976b78ef9dfe693_720w.jpg\" alt=\"img\"></p>\n<h2 id=\"心得\"><a href=\"#心得\" class=\"headerlink\" title=\"心得\"></a>心得</h2><p>debug的时候可以在lab3 vmprint基础上输出一下flag以及对应的refcount查看有没有错误。</p>\n"},{"title":"MIT6.S081 Lab5 Lazy Allocation","date":"2021-04-24T04:00:00.000Z","_content":"\n## 实验前准备\n\n> 阅读xv6 book chapter5，尤其是page fault的部分\n\n## Eliminate allocation from sbrk()\n\nlazy allocation就是在用户程序通过sbrk系统调用申请内存空间时，并不当场给它分配内存，而仅仅是增加p->sz。当用户程序使用申请的内存时会产生page fault而trap到内核态，此时再分配内存。\n\n第一个实验就是把sbrk中分配内存的过程去掉，观察产生的结果：\n\n![img](https://pic2.zhimg.com/80/v2-caf0f6b5fd4f81ed375c9cfd9eb89da9_720w.jpg)\n\n这里去掉了分配内存的部分，增加了proc的sz\n\n![img](https://pic3.zhimg.com/80/v2-0b9bf1ec112ed8cf8508f97fff8fbff2_720w.jpg)\n\n之后运行xv6，执行echo hi会产生page fault。这是因为执行echo hi时系统会使用sbrk分配一些内存，当访问到这一部分内存时，由于我们修改了的sbrk并没有真正分配物理内存，就会导致访问的页面不存在。\n\n这里的输出包含一些信息：\n\n> 这里输出了SCAUSE寄存器内容，我们可以看到它的值是15，表明这是一个store page fault。\n> 产生page fault的进程pid是3\n> 我们还可以看到SEPC寄存器的值，是0x12a4，表明产生page fault的指令的地址。\n> 最后还可以看到出错的虚拟内存地址，也就是STVAL寄存器的内容，是0x4008。\n\n产生page fault后看到有个panic。这是因为产生页面中断后，内核的做法会杀死当前进程（在usertrap（）中）。进程退出的时候需要free页表，free页表首先会把页表对应项unmap再free物理内存。unmap的时候是从虚拟地址0到p->sz逐页unmap的，在我们修改的sbrk函数中增加了p->sz，对应的内存并没有分配并map。因此在uvmunmap的逻辑中就会panic。\n\n## Lazy allocation\n\n在trap.c中加上处理page fault的逻辑，使得echo hi能够正常运行。\n\n比较简单，仿照课程视频的就行：\n\n> 在usertrap中处理page fault，如果kalloc失败或者访问的地址va不合法，杀死进程\n\n```c\n...\nelse if (r_scause() == 13 || r_scause() == 15) {\n    uint64 va = r_stval();\n    uint64 ka = (uint64)kalloc();\n    if (ka == 0) {\n      p->killed = 1;\n    }\n    else if(isValid(p, va) == 0) {\n      kfree((void*)ka);\n      p->killed = 1;\n    }\n    else {\n      memset((void*)ka, 0, PGSIZE);\n      if (mappages(p->pagetable, PGROUNDDOWN(va), PGSIZE, ka, PTE_U | PTE_R | PTE_W) != 0) {\n        kfree((void*)ka);\n        p->killed = 1;\n      }\n    }\n  }\n...\n```\n\n> 判断va是否合法：如果va大于sz或者访问了guard page，则不合法。\n\n```c\nint isValid(struct proc *p, uint64 va) {\n  uint64 stackbase = PGROUNDDOWN(p->trapframe->sp);\n  if (va >= p->sz || (va < stackbase+PGSIZE)) \n    return 0;\n  return 1;\n}\n```\n\n> 处理unmap的panic：如果某一页并没有分配或并没有map，那么可以跳过这一页而不是panic\n\n```c\n...\nfor(a = va; a < va + npages*PGSIZE; a += PGSIZE){\n    if((pte = walk(pagetable, a, 0)) == 0)\n      //panic(\"uvmunmap: walk\");\n      continue;\n    if((*pte & PTE_V) == 0)\n      //panic(\"uvmunmap: not mapped\");\n      continue;\n    if(PTE_FLAGS(*pte) == PTE_V)\n      panic(\"uvmunmap: not a leaf\");\n    if(do_free){\n      uint64 pa = PTE2PA(*pte);\n      kfree((void*)pa);\n    }\n    *pte = 0;\n  }\n...\n```\n\n## Lazytests and Usertests\n\n完善lazy allocation，保证：\n\n1.处理sbrk的负数参数\n\n2.如果va大于sz，杀死进程\n\n3.在fork中正确处理父进程到子进程的复制过程\n\n4.处理这样一种情况：系统调用（比如write）传入的虚拟地址对应的内存并没有被分配。\n\n5.物理内存不足时杀死进程\n\n6.处理va在user stack以下的情况\n\n其中2，5，6在上一个实验中已经完成了。isValid函数即处理了2和6。\n\n> sys_sbrk()中处理负数参数的情况\n> 如果传入的n为负数，则把p->sz+n到p->sz的地址范围都dealloc\n> 这里加上了两个判断，传入sbrk的参数不合法（即sz+n大于trapframe或小于user stack），sbrk失败，返回-1.\n> 之前修改过unmap的部分，dealloc的时候如果某一页不存在，不会panic而是会跳过这一页。\n\n```c\nuint64\nsys_sbrk(void)\n{\n  int addr;\n  int n;\n  struct proc *p = myproc();\n  addr = myproc()->sz;\n  uint64 stackbase = PGROUNDDOWN(p->trapframe->sp);\n  if(argint(0, &n) < 0)\n    return -1;\n  if (n > 0) {\n    p->sz += n;\n    if (p->sz > MAXVA-2*PGSIZE)\n      return -1;\n  }\n  else if (n < 0) {\n    if (p->sz < stackbase+PGSIZE-n) {\n      return -1;\n    }\n    else p->sz = uvmdealloc(p->pagetable, p->sz, p->sz + n);\n  }\n  return addr;\n}\n```\n\n> 在fork时会调用uvmcopy复制一份父进程的内存，在lazy allocation中可能0->sz中有部分没有真正分配，在uvmcopy中就会导致panic。累次uvmunmap，修改uvmcopy使得在页面不存在时跳过这一页。\n\n```c\nfor(i = 0; i < sz; i += PGSIZE){\n    if((pte = walk(old, i, 0)) == 0)\n      //panic(\"uvmcopy: pte should exist\");\n      continue;\n    if((*pte & PTE_V) == 0)\n      //panic(\"uvmcopy: page not present\");\n      continue;\n    pa = PTE2PA(*pte);\n    flags = PTE_FLAGS(*pte);\n    if((mem = kalloc()) == 0)\n      goto err;\n    memmove(mem, (char*)pa, PGSIZE);\n    if(mappages(new, i, PGSIZE, (uint64)mem, flags) != 0){\n      kfree(mem);\n      goto err;\n    }\n  }\n  return 0;\n```\n\n> 处理第4种情况，即系统调用（比如write）传入的虚拟地址对应的内存并没有被分配。\n> 首先搞清楚函数执行流程，在调用write后系统trap到内核态，执行copyin来把用户程序va处的内容复制到内核空间，此时若va处并未分配内存，walkaddr会返回0导致系统调用失败。因此我们要做的就是在walkaddr中分配内存。\n\n```c\nuint64\nwalkaddr(pagetable_t pagetable, uint64 va)\n{\n  pte_t *pte;\n  uint64 pa;\n      struct proc *p = myproc();\n  if(va >= MAXVA)\n    return 0;\n\n  pte = walk(pagetable, va, 0);\n  if(pte == 0 || (*pte & PTE_V) == 0) {\n    uint64 ka = (uint64)kalloc();\n    if (ka == 0) {\n      return 0;\n    }\n    else if (isValid(p, va) == 0) {\n      kfree((void*)ka);              //注意这里也要kfree，不然会导致内存泄漏\n      return 0;\n    }\n    else {\n      memset((void*)ka, 0, PGSIZE);\n      if (mappages(p->pagetable, PGROUNDDOWN(va), PGSIZE, ka, PTE_U | PTE_R | PTE_W) != 0) {\n        kfree((void*)ka);\n        return 0;\n      }\n      return ka;\n    }\n  }\n\n  if((*pte & PTE_U) == 0)\n    return 0;\n  pa = PTE2PA(*pte);\n  return pa;\n}\n```\n\n## 结果\n\n![img](https://pic2.zhimg.com/80/v2-4625c42a0a109262f033de943e938a39_720w.jpg)\n\n## 心得\n\nusertests失败的时候可以看看test代码是怎么写的从而定位错误。\n\n测试usertests前记得make clean一下，不然会导致部分test创建文件失败。","source":"_posts/MIT6.S081 Lab5.md","raw":"---\ntitle: MIT6.S081 Lab5 lazy allocation\ndate: 2021-04-24 12:00:00\ntags: 6.S081\n---\n\n## 实验前准备\n\n> 阅读xv6 book chapter5，尤其是page fault的部分\n\n## Eliminate allocation from sbrk()\n\nlazy allocation就是在用户程序通过sbrk系统调用申请内存空间时，并不当场给它分配内存，而仅仅是增加p->sz。当用户程序使用申请的内存时会产生page fault而trap到内核态，此时再分配内存。\n\n第一个实验就是把sbrk中分配内存的过程去掉，观察产生的结果：\n\n![img](https://pic2.zhimg.com/80/v2-caf0f6b5fd4f81ed375c9cfd9eb89da9_720w.jpg)\n\n这里去掉了分配内存的部分，增加了proc的sz\n\n![img](https://pic3.zhimg.com/80/v2-0b9bf1ec112ed8cf8508f97fff8fbff2_720w.jpg)\n\n之后运行xv6，执行echo hi会产生page fault。这是因为执行echo hi时系统会使用sbrk分配一些内存，当访问到这一部分内存时，由于我们修改了的sbrk并没有真正分配物理内存，就会导致访问的页面不存在。\n\n这里的输出包含一些信息：\n\n> 这里输出了SCAUSE寄存器内容，我们可以看到它的值是15，表明这是一个store page fault。\n> 产生page fault的进程pid是3\n> 我们还可以看到SEPC寄存器的值，是0x12a4，表明产生page fault的指令的地址。\n> 最后还可以看到出错的虚拟内存地址，也就是STVAL寄存器的内容，是0x4008。\n\n产生page fault后看到有个panic。这是因为产生页面中断后，内核的做法会杀死当前进程（在usertrap（）中）。进程退出的时候需要free页表，free页表首先会把页表对应项unmap再free物理内存。unmap的时候是从虚拟地址0到p->sz逐页unmap的，在我们修改的sbrk函数中增加了p->sz，对应的内存并没有分配并map。因此在uvmunmap的逻辑中就会panic。\n\n## Lazy allocation\n\n在trap.c中加上处理page fault的逻辑，使得echo hi能够正常运行。\n\n比较简单，仿照课程视频的就行：\n\n> 在usertrap中处理page fault，如果kalloc失败或者访问的地址va不合法，杀死进程\n\n```c\n...\nelse if (r_scause() == 13 || r_scause() == 15) {\n    uint64 va = r_stval();\n    uint64 ka = (uint64)kalloc();\n    if (ka == 0) {\n      p->killed = 1;\n    }\n    else if(isValid(p, va) == 0) {\n      kfree((void*)ka);\n      p->killed = 1;\n    }\n    else {\n      memset((void*)ka, 0, PGSIZE);\n      if (mappages(p->pagetable, PGROUNDDOWN(va), PGSIZE, ka, PTE_U | PTE_R | PTE_W) != 0) {\n        kfree((void*)ka);\n        p->killed = 1;\n      }\n    }\n  }\n...\n```\n\n> 判断va是否合法：如果va大于sz或者访问了guard page，则不合法。\n\n```c\nint isValid(struct proc *p, uint64 va) {\n  uint64 stackbase = PGROUNDDOWN(p->trapframe->sp);\n  if (va >= p->sz || (va < stackbase+PGSIZE)) \n    return 0;\n  return 1;\n}\n```\n\n> 处理unmap的panic：如果某一页并没有分配或并没有map，那么可以跳过这一页而不是panic\n\n```c\n...\nfor(a = va; a < va + npages*PGSIZE; a += PGSIZE){\n    if((pte = walk(pagetable, a, 0)) == 0)\n      //panic(\"uvmunmap: walk\");\n      continue;\n    if((*pte & PTE_V) == 0)\n      //panic(\"uvmunmap: not mapped\");\n      continue;\n    if(PTE_FLAGS(*pte) == PTE_V)\n      panic(\"uvmunmap: not a leaf\");\n    if(do_free){\n      uint64 pa = PTE2PA(*pte);\n      kfree((void*)pa);\n    }\n    *pte = 0;\n  }\n...\n```\n\n## Lazytests and Usertests\n\n完善lazy allocation，保证：\n\n1.处理sbrk的负数参数\n\n2.如果va大于sz，杀死进程\n\n3.在fork中正确处理父进程到子进程的复制过程\n\n4.处理这样一种情况：系统调用（比如write）传入的虚拟地址对应的内存并没有被分配。\n\n5.物理内存不足时杀死进程\n\n6.处理va在user stack以下的情况\n\n其中2，5，6在上一个实验中已经完成了。isValid函数即处理了2和6。\n\n> sys_sbrk()中处理负数参数的情况\n> 如果传入的n为负数，则把p->sz+n到p->sz的地址范围都dealloc\n> 这里加上了两个判断，传入sbrk的参数不合法（即sz+n大于trapframe或小于user stack），sbrk失败，返回-1.\n> 之前修改过unmap的部分，dealloc的时候如果某一页不存在，不会panic而是会跳过这一页。\n\n```c\nuint64\nsys_sbrk(void)\n{\n  int addr;\n  int n;\n  struct proc *p = myproc();\n  addr = myproc()->sz;\n  uint64 stackbase = PGROUNDDOWN(p->trapframe->sp);\n  if(argint(0, &n) < 0)\n    return -1;\n  if (n > 0) {\n    p->sz += n;\n    if (p->sz > MAXVA-2*PGSIZE)\n      return -1;\n  }\n  else if (n < 0) {\n    if (p->sz < stackbase+PGSIZE-n) {\n      return -1;\n    }\n    else p->sz = uvmdealloc(p->pagetable, p->sz, p->sz + n);\n  }\n  return addr;\n}\n```\n\n> 在fork时会调用uvmcopy复制一份父进程的内存，在lazy allocation中可能0->sz中有部分没有真正分配，在uvmcopy中就会导致panic。累次uvmunmap，修改uvmcopy使得在页面不存在时跳过这一页。\n\n```c\nfor(i = 0; i < sz; i += PGSIZE){\n    if((pte = walk(old, i, 0)) == 0)\n      //panic(\"uvmcopy: pte should exist\");\n      continue;\n    if((*pte & PTE_V) == 0)\n      //panic(\"uvmcopy: page not present\");\n      continue;\n    pa = PTE2PA(*pte);\n    flags = PTE_FLAGS(*pte);\n    if((mem = kalloc()) == 0)\n      goto err;\n    memmove(mem, (char*)pa, PGSIZE);\n    if(mappages(new, i, PGSIZE, (uint64)mem, flags) != 0){\n      kfree(mem);\n      goto err;\n    }\n  }\n  return 0;\n```\n\n> 处理第4种情况，即系统调用（比如write）传入的虚拟地址对应的内存并没有被分配。\n> 首先搞清楚函数执行流程，在调用write后系统trap到内核态，执行copyin来把用户程序va处的内容复制到内核空间，此时若va处并未分配内存，walkaddr会返回0导致系统调用失败。因此我们要做的就是在walkaddr中分配内存。\n\n```c\nuint64\nwalkaddr(pagetable_t pagetable, uint64 va)\n{\n  pte_t *pte;\n  uint64 pa;\n      struct proc *p = myproc();\n  if(va >= MAXVA)\n    return 0;\n\n  pte = walk(pagetable, va, 0);\n  if(pte == 0 || (*pte & PTE_V) == 0) {\n    uint64 ka = (uint64)kalloc();\n    if (ka == 0) {\n      return 0;\n    }\n    else if (isValid(p, va) == 0) {\n      kfree((void*)ka);              //注意这里也要kfree，不然会导致内存泄漏\n      return 0;\n    }\n    else {\n      memset((void*)ka, 0, PGSIZE);\n      if (mappages(p->pagetable, PGROUNDDOWN(va), PGSIZE, ka, PTE_U | PTE_R | PTE_W) != 0) {\n        kfree((void*)ka);\n        return 0;\n      }\n      return ka;\n    }\n  }\n\n  if((*pte & PTE_U) == 0)\n    return 0;\n  pa = PTE2PA(*pte);\n  return pa;\n}\n```\n\n## 结果\n\n![img](https://pic2.zhimg.com/80/v2-4625c42a0a109262f033de943e938a39_720w.jpg)\n\n## 心得\n\nusertests失败的时候可以看看test代码是怎么写的从而定位错误。\n\n测试usertests前记得make clean一下，不然会导致部分test创建文件失败。","slug":"MIT6.S081 Lab5","published":1,"updated":"2021-11-05T04:49:44.799Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckvlyb07c000404v6hrs81azk","content":"<h2 id=\"实验前准备\"><a href=\"#实验前准备\" class=\"headerlink\" title=\"实验前准备\"></a>实验前准备</h2><blockquote>\n<p>阅读xv6 book chapter5，尤其是page fault的部分</p>\n</blockquote>\n<h2 id=\"Eliminate-allocation-from-sbrk\"><a href=\"#Eliminate-allocation-from-sbrk\" class=\"headerlink\" title=\"Eliminate allocation from sbrk()\"></a>Eliminate allocation from sbrk()</h2><p>lazy allocation就是在用户程序通过sbrk系统调用申请内存空间时，并不当场给它分配内存，而仅仅是增加p-&gt;sz。当用户程序使用申请的内存时会产生page fault而trap到内核态，此时再分配内存。</p>\n<p>第一个实验就是把sbrk中分配内存的过程去掉，观察产生的结果：</p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-caf0f6b5fd4f81ed375c9cfd9eb89da9_720w.jpg\" alt=\"img\"></p>\n<p>这里去掉了分配内存的部分，增加了proc的sz</p>\n<p><img src=\"https://pic3.zhimg.com/80/v2-0b9bf1ec112ed8cf8508f97fff8fbff2_720w.jpg\" alt=\"img\"></p>\n<p>之后运行xv6，执行echo hi会产生page fault。这是因为执行echo hi时系统会使用sbrk分配一些内存，当访问到这一部分内存时，由于我们修改了的sbrk并没有真正分配物理内存，就会导致访问的页面不存在。</p>\n<p>这里的输出包含一些信息：</p>\n<blockquote>\n<p>这里输出了SCAUSE寄存器内容，我们可以看到它的值是15，表明这是一个store page fault。<br>产生page fault的进程pid是3<br>我们还可以看到SEPC寄存器的值，是0x12a4，表明产生page fault的指令的地址。<br>最后还可以看到出错的虚拟内存地址，也就是STVAL寄存器的内容，是0x4008。</p>\n</blockquote>\n<p>产生page fault后看到有个panic。这是因为产生页面中断后，内核的做法会杀死当前进程（在usertrap（）中）。进程退出的时候需要free页表，free页表首先会把页表对应项unmap再free物理内存。unmap的时候是从虚拟地址0到p-&gt;sz逐页unmap的，在我们修改的sbrk函数中增加了p-&gt;sz，对应的内存并没有分配并map。因此在uvmunmap的逻辑中就会panic。</p>\n<h2 id=\"Lazy-allocation\"><a href=\"#Lazy-allocation\" class=\"headerlink\" title=\"Lazy allocation\"></a>Lazy allocation</h2><p>在trap.c中加上处理page fault的逻辑，使得echo hi能够正常运行。</p>\n<p>比较简单，仿照课程视频的就行：</p>\n<blockquote>\n<p>在usertrap中处理page fault，如果kalloc失败或者访问的地址va不合法，杀死进程</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (r_scause() == <span class=\"number\">13</span> || r_scause() == <span class=\"number\">15</span>) &#123;</span><br><span class=\"line\">    uint64 va = r_stval();</span><br><span class=\"line\">    uint64 ka = (uint64)kalloc();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ka == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      p-&gt;killed = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(isValid(p, va) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      kfree((<span class=\"keyword\">void</span>*)ka);</span><br><span class=\"line\">      p-&gt;killed = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">memset</span>((<span class=\"keyword\">void</span>*)ka, <span class=\"number\">0</span>, PGSIZE);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (mappages(p-&gt;pagetable, PGROUNDDOWN(va), PGSIZE, ka, PTE_U | PTE_R | PTE_W) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        kfree((<span class=\"keyword\">void</span>*)ka);</span><br><span class=\"line\">        p-&gt;killed = <span class=\"number\">1</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>判断va是否合法：如果va大于sz或者访问了guard page，则不合法。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">isValid</span><span class=\"params\">(struct proc *p, uint64 va)</span> </span>&#123;</span><br><span class=\"line\">  uint64 stackbase = PGROUNDDOWN(p-&gt;trapframe-&gt;sp);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (va &gt;= p-&gt;sz || (va &lt; stackbase+PGSIZE)) </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>处理unmap的panic：如果某一页并没有分配或并没有map，那么可以跳过这一页而不是panic</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">for</span>(a = va; a &lt; va + npages*PGSIZE; a += PGSIZE)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((pte = walk(pagetable, a, <span class=\"number\">0</span>)) == <span class=\"number\">0</span>)</span><br><span class=\"line\">      <span class=\"comment\">//panic(&quot;uvmunmap: walk&quot;);</span></span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((*pte &amp; PTE_V) == <span class=\"number\">0</span>)</span><br><span class=\"line\">      <span class=\"comment\">//panic(&quot;uvmunmap: not mapped&quot;);</span></span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(PTE_FLAGS(*pte) == PTE_V)</span><br><span class=\"line\">      panic(<span class=\"string\">&quot;uvmunmap: not a leaf&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(do_free)&#123;</span><br><span class=\"line\">      uint64 pa = PTE2PA(*pte);</span><br><span class=\"line\">      kfree((<span class=\"keyword\">void</span>*)pa);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    *pte = <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Lazytests-and-Usertests\"><a href=\"#Lazytests-and-Usertests\" class=\"headerlink\" title=\"Lazytests and Usertests\"></a>Lazytests and Usertests</h2><p>完善lazy allocation，保证：</p>\n<p>1.处理sbrk的负数参数</p>\n<p>2.如果va大于sz，杀死进程</p>\n<p>3.在fork中正确处理父进程到子进程的复制过程</p>\n<p>4.处理这样一种情况：系统调用（比如write）传入的虚拟地址对应的内存并没有被分配。</p>\n<p>5.物理内存不足时杀死进程</p>\n<p>6.处理va在user stack以下的情况</p>\n<p>其中2，5，6在上一个实验中已经完成了。isValid函数即处理了2和6。</p>\n<blockquote>\n<p>sys_sbrk()中处理负数参数的情况<br>如果传入的n为负数，则把p-&gt;sz+n到p-&gt;sz的地址范围都dealloc<br>这里加上了两个判断，传入sbrk的参数不合法（即sz+n大于trapframe或小于user stack），sbrk失败，返回-1.<br>之前修改过unmap的部分，dealloc的时候如果某一页不存在，不会panic而是会跳过这一页。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">uint64</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">sys_sbrk</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> addr;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">proc</span> *<span class=\"title\">p</span> =</span> myproc();</span><br><span class=\"line\">  addr = myproc()-&gt;sz;</span><br><span class=\"line\">  uint64 stackbase = PGROUNDDOWN(p-&gt;trapframe-&gt;sp);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(argint(<span class=\"number\">0</span>, &amp;n) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    p-&gt;sz += n;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p-&gt;sz &gt; MAXVA<span class=\"number\">-2</span>*PGSIZE)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p-&gt;sz &lt; stackbase+PGSIZE-n) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> p-&gt;sz = uvmdealloc(p-&gt;pagetable, p-&gt;sz, p-&gt;sz + n);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> addr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>在fork时会调用uvmcopy复制一份父进程的内存，在lazy allocation中可能0-&gt;sz中有部分没有真正分配，在uvmcopy中就会导致panic。累次uvmunmap，修改uvmcopy使得在页面不存在时跳过这一页。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; sz; i += PGSIZE)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((pte = walk(old, i, <span class=\"number\">0</span>)) == <span class=\"number\">0</span>)</span><br><span class=\"line\">      <span class=\"comment\">//panic(&quot;uvmcopy: pte should exist&quot;);</span></span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((*pte &amp; PTE_V) == <span class=\"number\">0</span>)</span><br><span class=\"line\">      <span class=\"comment\">//panic(&quot;uvmcopy: page not present&quot;);</span></span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    pa = PTE2PA(*pte);</span><br><span class=\"line\">    flags = PTE_FLAGS(*pte);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((mem = kalloc()) == <span class=\"number\">0</span>)</span><br><span class=\"line\">      <span class=\"keyword\">goto</span> err;</span><br><span class=\"line\">    memmove(mem, (<span class=\"keyword\">char</span>*)pa, PGSIZE);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(mappages(<span class=\"keyword\">new</span>, i, PGSIZE, (uint64)mem, flags) != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">      kfree(mem);</span><br><span class=\"line\">      <span class=\"keyword\">goto</span> err;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>处理第4种情况，即系统调用（比如write）传入的虚拟地址对应的内存并没有被分配。<br>首先搞清楚函数执行流程，在调用write后系统trap到内核态，执行copyin来把用户程序va处的内容复制到内核空间，此时若va处并未分配内存，walkaddr会返回0导致系统调用失败。因此我们要做的就是在walkaddr中分配内存。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">uint64</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">walkaddr</span><span class=\"params\">(<span class=\"keyword\">pagetable_t</span> pagetable, uint64 va)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">pte_t</span> *pte;</span><br><span class=\"line\">  uint64 pa;</span><br><span class=\"line\">      <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">proc</span> *<span class=\"title\">p</span> =</span> myproc();</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(va &gt;= MAXVA)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  pte = walk(pagetable, va, <span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(pte == <span class=\"number\">0</span> || (*pte &amp; PTE_V) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    uint64 ka = (uint64)kalloc();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ka == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isValid(p, va) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      kfree((<span class=\"keyword\">void</span>*)ka);              <span class=\"comment\">//注意这里也要kfree，不然会导致内存泄漏</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">memset</span>((<span class=\"keyword\">void</span>*)ka, <span class=\"number\">0</span>, PGSIZE);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (mappages(p-&gt;pagetable, PGROUNDDOWN(va), PGSIZE, ka, PTE_U | PTE_R | PTE_W) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        kfree((<span class=\"keyword\">void</span>*)ka);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> ka;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>((*pte &amp; PTE_U) == <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  pa = PTE2PA(*pte);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> pa;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"结果\"><a href=\"#结果\" class=\"headerlink\" title=\"结果\"></a>结果</h2><p><img src=\"https://pic2.zhimg.com/80/v2-4625c42a0a109262f033de943e938a39_720w.jpg\" alt=\"img\"></p>\n<h2 id=\"心得\"><a href=\"#心得\" class=\"headerlink\" title=\"心得\"></a>心得</h2><p>usertests失败的时候可以看看test代码是怎么写的从而定位错误。</p>\n<p>测试usertests前记得make clean一下，不然会导致部分test创建文件失败。</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/bg.jpg\");\n  background-repeat: no-repeat;\n  background-size: cover;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.9;\n}\n.header-inner {\n  background: rgba(255,255,255,0.85);\n}\n.popup {\n  opacity: 0.85;\n}\n.sidebar {\n  background-color: transparent;\n}\n","variables":""}},"excerpt":"","more":"<h2 id=\"实验前准备\"><a href=\"#实验前准备\" class=\"headerlink\" title=\"实验前准备\"></a>实验前准备</h2><blockquote>\n<p>阅读xv6 book chapter5，尤其是page fault的部分</p>\n</blockquote>\n<h2 id=\"Eliminate-allocation-from-sbrk\"><a href=\"#Eliminate-allocation-from-sbrk\" class=\"headerlink\" title=\"Eliminate allocation from sbrk()\"></a>Eliminate allocation from sbrk()</h2><p>lazy allocation就是在用户程序通过sbrk系统调用申请内存空间时，并不当场给它分配内存，而仅仅是增加p-&gt;sz。当用户程序使用申请的内存时会产生page fault而trap到内核态，此时再分配内存。</p>\n<p>第一个实验就是把sbrk中分配内存的过程去掉，观察产生的结果：</p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-caf0f6b5fd4f81ed375c9cfd9eb89da9_720w.jpg\" alt=\"img\"></p>\n<p>这里去掉了分配内存的部分，增加了proc的sz</p>\n<p><img src=\"https://pic3.zhimg.com/80/v2-0b9bf1ec112ed8cf8508f97fff8fbff2_720w.jpg\" alt=\"img\"></p>\n<p>之后运行xv6，执行echo hi会产生page fault。这是因为执行echo hi时系统会使用sbrk分配一些内存，当访问到这一部分内存时，由于我们修改了的sbrk并没有真正分配物理内存，就会导致访问的页面不存在。</p>\n<p>这里的输出包含一些信息：</p>\n<blockquote>\n<p>这里输出了SCAUSE寄存器内容，我们可以看到它的值是15，表明这是一个store page fault。<br>产生page fault的进程pid是3<br>我们还可以看到SEPC寄存器的值，是0x12a4，表明产生page fault的指令的地址。<br>最后还可以看到出错的虚拟内存地址，也就是STVAL寄存器的内容，是0x4008。</p>\n</blockquote>\n<p>产生page fault后看到有个panic。这是因为产生页面中断后，内核的做法会杀死当前进程（在usertrap（）中）。进程退出的时候需要free页表，free页表首先会把页表对应项unmap再free物理内存。unmap的时候是从虚拟地址0到p-&gt;sz逐页unmap的，在我们修改的sbrk函数中增加了p-&gt;sz，对应的内存并没有分配并map。因此在uvmunmap的逻辑中就会panic。</p>\n<h2 id=\"Lazy-allocation\"><a href=\"#Lazy-allocation\" class=\"headerlink\" title=\"Lazy allocation\"></a>Lazy allocation</h2><p>在trap.c中加上处理page fault的逻辑，使得echo hi能够正常运行。</p>\n<p>比较简单，仿照课程视频的就行：</p>\n<blockquote>\n<p>在usertrap中处理page fault，如果kalloc失败或者访问的地址va不合法，杀死进程</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (r_scause() == <span class=\"number\">13</span> || r_scause() == <span class=\"number\">15</span>) &#123;</span><br><span class=\"line\">    uint64 va = r_stval();</span><br><span class=\"line\">    uint64 ka = (uint64)kalloc();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ka == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      p-&gt;killed = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(isValid(p, va) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      kfree((<span class=\"keyword\">void</span>*)ka);</span><br><span class=\"line\">      p-&gt;killed = <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">memset</span>((<span class=\"keyword\">void</span>*)ka, <span class=\"number\">0</span>, PGSIZE);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (mappages(p-&gt;pagetable, PGROUNDDOWN(va), PGSIZE, ka, PTE_U | PTE_R | PTE_W) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        kfree((<span class=\"keyword\">void</span>*)ka);</span><br><span class=\"line\">        p-&gt;killed = <span class=\"number\">1</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>判断va是否合法：如果va大于sz或者访问了guard page，则不合法。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">isValid</span><span class=\"params\">(struct proc *p, uint64 va)</span> </span>&#123;</span><br><span class=\"line\">  uint64 stackbase = PGROUNDDOWN(p-&gt;trapframe-&gt;sp);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (va &gt;= p-&gt;sz || (va &lt; stackbase+PGSIZE)) </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>处理unmap的panic：如果某一页并没有分配或并没有map，那么可以跳过这一页而不是panic</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">for</span>(a = va; a &lt; va + npages*PGSIZE; a += PGSIZE)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((pte = walk(pagetable, a, <span class=\"number\">0</span>)) == <span class=\"number\">0</span>)</span><br><span class=\"line\">      <span class=\"comment\">//panic(&quot;uvmunmap: walk&quot;);</span></span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((*pte &amp; PTE_V) == <span class=\"number\">0</span>)</span><br><span class=\"line\">      <span class=\"comment\">//panic(&quot;uvmunmap: not mapped&quot;);</span></span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(PTE_FLAGS(*pte) == PTE_V)</span><br><span class=\"line\">      panic(<span class=\"string\">&quot;uvmunmap: not a leaf&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(do_free)&#123;</span><br><span class=\"line\">      uint64 pa = PTE2PA(*pte);</span><br><span class=\"line\">      kfree((<span class=\"keyword\">void</span>*)pa);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    *pte = <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Lazytests-and-Usertests\"><a href=\"#Lazytests-and-Usertests\" class=\"headerlink\" title=\"Lazytests and Usertests\"></a>Lazytests and Usertests</h2><p>完善lazy allocation，保证：</p>\n<p>1.处理sbrk的负数参数</p>\n<p>2.如果va大于sz，杀死进程</p>\n<p>3.在fork中正确处理父进程到子进程的复制过程</p>\n<p>4.处理这样一种情况：系统调用（比如write）传入的虚拟地址对应的内存并没有被分配。</p>\n<p>5.物理内存不足时杀死进程</p>\n<p>6.处理va在user stack以下的情况</p>\n<p>其中2，5，6在上一个实验中已经完成了。isValid函数即处理了2和6。</p>\n<blockquote>\n<p>sys_sbrk()中处理负数参数的情况<br>如果传入的n为负数，则把p-&gt;sz+n到p-&gt;sz的地址范围都dealloc<br>这里加上了两个判断，传入sbrk的参数不合法（即sz+n大于trapframe或小于user stack），sbrk失败，返回-1.<br>之前修改过unmap的部分，dealloc的时候如果某一页不存在，不会panic而是会跳过这一页。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">uint64</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">sys_sbrk</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> addr;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">proc</span> *<span class=\"title\">p</span> =</span> myproc();</span><br><span class=\"line\">  addr = myproc()-&gt;sz;</span><br><span class=\"line\">  uint64 stackbase = PGROUNDDOWN(p-&gt;trapframe-&gt;sp);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(argint(<span class=\"number\">0</span>, &amp;n) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    p-&gt;sz += n;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p-&gt;sz &gt; MAXVA<span class=\"number\">-2</span>*PGSIZE)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (p-&gt;sz &lt; stackbase+PGSIZE-n) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> p-&gt;sz = uvmdealloc(p-&gt;pagetable, p-&gt;sz, p-&gt;sz + n);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> addr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>在fork时会调用uvmcopy复制一份父进程的内存，在lazy allocation中可能0-&gt;sz中有部分没有真正分配，在uvmcopy中就会导致panic。累次uvmunmap，修改uvmcopy使得在页面不存在时跳过这一页。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; sz; i += PGSIZE)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((pte = walk(old, i, <span class=\"number\">0</span>)) == <span class=\"number\">0</span>)</span><br><span class=\"line\">      <span class=\"comment\">//panic(&quot;uvmcopy: pte should exist&quot;);</span></span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((*pte &amp; PTE_V) == <span class=\"number\">0</span>)</span><br><span class=\"line\">      <span class=\"comment\">//panic(&quot;uvmcopy: page not present&quot;);</span></span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">    pa = PTE2PA(*pte);</span><br><span class=\"line\">    flags = PTE_FLAGS(*pte);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((mem = kalloc()) == <span class=\"number\">0</span>)</span><br><span class=\"line\">      <span class=\"keyword\">goto</span> err;</span><br><span class=\"line\">    memmove(mem, (<span class=\"keyword\">char</span>*)pa, PGSIZE);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(mappages(<span class=\"keyword\">new</span>, i, PGSIZE, (uint64)mem, flags) != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">      kfree(mem);</span><br><span class=\"line\">      <span class=\"keyword\">goto</span> err;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>处理第4种情况，即系统调用（比如write）传入的虚拟地址对应的内存并没有被分配。<br>首先搞清楚函数执行流程，在调用write后系统trap到内核态，执行copyin来把用户程序va处的内容复制到内核空间，此时若va处并未分配内存，walkaddr会返回0导致系统调用失败。因此我们要做的就是在walkaddr中分配内存。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">uint64</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">walkaddr</span><span class=\"params\">(<span class=\"keyword\">pagetable_t</span> pagetable, uint64 va)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">pte_t</span> *pte;</span><br><span class=\"line\">  uint64 pa;</span><br><span class=\"line\">      <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">proc</span> *<span class=\"title\">p</span> =</span> myproc();</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(va &gt;= MAXVA)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  pte = walk(pagetable, va, <span class=\"number\">0</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(pte == <span class=\"number\">0</span> || (*pte &amp; PTE_V) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    uint64 ka = (uint64)kalloc();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ka == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isValid(p, va) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      kfree((<span class=\"keyword\">void</span>*)ka);              <span class=\"comment\">//注意这里也要kfree，不然会导致内存泄漏</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">memset</span>((<span class=\"keyword\">void</span>*)ka, <span class=\"number\">0</span>, PGSIZE);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (mappages(p-&gt;pagetable, PGROUNDDOWN(va), PGSIZE, ka, PTE_U | PTE_R | PTE_W) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        kfree((<span class=\"keyword\">void</span>*)ka);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> ka;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>((*pte &amp; PTE_U) == <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  pa = PTE2PA(*pte);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> pa;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"结果\"><a href=\"#结果\" class=\"headerlink\" title=\"结果\"></a>结果</h2><p><img src=\"https://pic2.zhimg.com/80/v2-4625c42a0a109262f033de943e938a39_720w.jpg\" alt=\"img\"></p>\n<h2 id=\"心得\"><a href=\"#心得\" class=\"headerlink\" title=\"心得\"></a>心得</h2><p>usertests失败的时候可以看看test代码是怎么写的从而定位错误。</p>\n<p>测试usertests前记得make clean一下，不然会导致部分test创建文件失败。</p>\n"},{"title":"MIT6.S081 Lab7 Multithreading","date":"2021-10-12T04:00:00.000Z","_content":"\n## Uthread: switching between threads\n\n这个lab要求完善一个用户态线程库，比较简单\n\n> 首先创建线程时把context的ra设置为传入的函数地址，这样第一次scheduler到这个线程可以返回到执行函数。\n> 注意stack是从上往下增长的，所以sp的值初始化为对应stack的顶部。\n> 实际上thread[0].stack是没有用到的，因为main线程一直使用的都是进程分配好的栈区域，其他stack被分配在data段。\n\n```c\nvoid \nthread_create(void (*func)())\n{\n  struct thread *t;\n\n  for (t = all_thread; t < all_thread + MAX_THREAD; t++) {\n    if (t->state == FREE) break;\n  }\n  t->state = RUNNABLE;\n  // YOUR CODE HERE\n  t->context.ra = (uint64)func;\n  t->context.sp = (uint64)t->stack+STACK_SIZE;\n}\n```\n\n> sheduler函数中，找到一个RUNNABLE的线程就进行切换\n\n```c\nif (current_thread != next_thread) {         /* switch threads?  */\n    next_thread->state = RUNNING;\n    t = current_thread;\n    current_thread = next_thread;\n    /* YOUR CODE HERE\n     * Invoke thread_switch to switch from t to next_thread:\n     * thread_switch(??, ??);\n     */\n    thread_switch((uint64)(&t->context), (uint64)(&current_thread->context));\n  } else\n    next_thread = 0;\n}\n```\n\n> thread_switch代码和swtch一样\n\n```text\nthread_switch:\n\t/* YOUR CODE HERE */\n        sd ra, 0(a0)\n        sd sp, 8(a0)\n        sd s0, 16(a0)\n        sd s1, 24(a0)\n        sd s2, 32(a0)\n        sd s3, 40(a0)\n        sd s4, 48(a0)\n        sd s5, 56(a0)\n        sd s6, 64(a0)\n        sd s7, 72(a0)\n        sd s8, 80(a0)\n        sd s9, 88(a0)\n        sd s10, 96(a0)\n        sd s11, 104(a0)\n\n        ld ra, 0(a1)\n        ld sp, 8(a1)\n        ld s0, 16(a1)\n        ld s1, 24(a1)\n        ld s2, 32(a1)\n        ld s3, 40(a1)\n        ld s4, 48(a1)\n        ld s5, 56(a1)\n        ld s6, 64(a1)\n        ld s7, 72(a1)\n        ld s8, 80(a1)\n        ld s9, 88(a1)\n        ld s10, 96(a1)\n        ld s11, 104(a1)\n\t\n\tret    /* return to ra */\n```\n\n另外需要定义struct context并作为thread类的一个成员变量\n\n## Using threads\n\n这个lab展示了如何使用linux pthread线程库。程序定义了一个链式哈希表并向其中put 10000个kv数据对。创建多个线程执行put操作时，效率会有所提高但会产生miss的情况，也就是一些key并没有成功写入hash table。原因是线程对hash table的操作没有加锁。例如线程t1要对其中某个链表进行e1的头插，当执行完 e->next = n后切换到线程t2，线程t2同样要对该链表进行e2的头插，也运行到e->next = n。\n\n这时候有两种情况：t1先执行 *p = e，这样就丢失了e2这个数据；t2先执行 *p = e;，这样会丢失e1.所以需要对共享数据加锁。最简单的方法是对整个hash table加锁，每次put前都需要acquire这个锁，但这样效率很低，所有put操作相当于都串行操作了。hints告诉我们实际上只要对hash table的每个bucket加锁就行，因为不同bucket的插入操作彼此互不影响。\n\n代码的话比较简单，主要是熟悉pthread库的mutex锁的使用。\n\n> lock定义了每个bucket的锁，put时加锁即可。\n\n```c\n...\npthread_mutex_t lock[NBUCKET];\n...\nstatic \nvoid put(int key, int value)\n{\n  int i = key % NBUCKET;\n\n  // is the key already present?\n  struct entry *e = 0;\n  pthread_mutex_lock(&lock[i]);\n  for (e = table[i]; e != 0; e = e->next) {\n    if (e->key == key)\n      break;i\n  }\n  if(e){\n    // update the existing key.\n    e->value = value;\n  } else {\n    // the new is new.\n    insert(key, value, &table[i], table[i]);\n  }\n  pthread_mutex_unlock(&lock[i]);\n}\n```\n\n## Barrier\n\n程序开始创建了多个线程，要求每个线程都运行到barrier函数就sleep，直到所有线程都到达barrier函数才能被wakeup。这个lab也比较简单，主要是熟悉pthread的条件变量，本质上和xv6的sleep&wakeup一样。\n\n> barrier_mutex用来保护条件变量nthread，当nthread满足条件后wakeup所有等待barrier_cond这个channel的线程。\n\n```c\nstatic void \nbarrier()\n{\n  // YOUR CODE HERE\n  //\n  // Block until all threads have called barrier() and\n  // then increment bstate.round.\n  //\n  pthread_mutex_lock(&bstate.barrier_mutex);\n  bstate.nthread++;\n  if (bstate.nthread == nthread) {\n    bstate.nthread = 0;\n    bstate.round++;\n    pthread_cond_broadcast(&bstate.barrier_cond);\n  }\n  else {\n    pthread_cond_wait(&bstate.barrier_cond, &bstate.barrier_mutex);\n  }\n  pthread_mutex_unlock(&bstate.barrier_mutex);\n}\n```\n\n\n\n结果\n\n![img](https://pic2.zhimg.com/80/v2-0e04ba414726a4cb23de4791fb4f4ca9_720w.jpg)","source":"_posts/MIT6.S081 Lab7.md","raw":"---\ntitle: MIT6.S081 Lab7 Multithreading\ndate: 2021-10-12 12:00:00\ntags: 6.S081\n---\n\n## Uthread: switching between threads\n\n这个lab要求完善一个用户态线程库，比较简单\n\n> 首先创建线程时把context的ra设置为传入的函数地址，这样第一次scheduler到这个线程可以返回到执行函数。\n> 注意stack是从上往下增长的，所以sp的值初始化为对应stack的顶部。\n> 实际上thread[0].stack是没有用到的，因为main线程一直使用的都是进程分配好的栈区域，其他stack被分配在data段。\n\n```c\nvoid \nthread_create(void (*func)())\n{\n  struct thread *t;\n\n  for (t = all_thread; t < all_thread + MAX_THREAD; t++) {\n    if (t->state == FREE) break;\n  }\n  t->state = RUNNABLE;\n  // YOUR CODE HERE\n  t->context.ra = (uint64)func;\n  t->context.sp = (uint64)t->stack+STACK_SIZE;\n}\n```\n\n> sheduler函数中，找到一个RUNNABLE的线程就进行切换\n\n```c\nif (current_thread != next_thread) {         /* switch threads?  */\n    next_thread->state = RUNNING;\n    t = current_thread;\n    current_thread = next_thread;\n    /* YOUR CODE HERE\n     * Invoke thread_switch to switch from t to next_thread:\n     * thread_switch(??, ??);\n     */\n    thread_switch((uint64)(&t->context), (uint64)(&current_thread->context));\n  } else\n    next_thread = 0;\n}\n```\n\n> thread_switch代码和swtch一样\n\n```text\nthread_switch:\n\t/* YOUR CODE HERE */\n        sd ra, 0(a0)\n        sd sp, 8(a0)\n        sd s0, 16(a0)\n        sd s1, 24(a0)\n        sd s2, 32(a0)\n        sd s3, 40(a0)\n        sd s4, 48(a0)\n        sd s5, 56(a0)\n        sd s6, 64(a0)\n        sd s7, 72(a0)\n        sd s8, 80(a0)\n        sd s9, 88(a0)\n        sd s10, 96(a0)\n        sd s11, 104(a0)\n\n        ld ra, 0(a1)\n        ld sp, 8(a1)\n        ld s0, 16(a1)\n        ld s1, 24(a1)\n        ld s2, 32(a1)\n        ld s3, 40(a1)\n        ld s4, 48(a1)\n        ld s5, 56(a1)\n        ld s6, 64(a1)\n        ld s7, 72(a1)\n        ld s8, 80(a1)\n        ld s9, 88(a1)\n        ld s10, 96(a1)\n        ld s11, 104(a1)\n\t\n\tret    /* return to ra */\n```\n\n另外需要定义struct context并作为thread类的一个成员变量\n\n## Using threads\n\n这个lab展示了如何使用linux pthread线程库。程序定义了一个链式哈希表并向其中put 10000个kv数据对。创建多个线程执行put操作时，效率会有所提高但会产生miss的情况，也就是一些key并没有成功写入hash table。原因是线程对hash table的操作没有加锁。例如线程t1要对其中某个链表进行e1的头插，当执行完 e->next = n后切换到线程t2，线程t2同样要对该链表进行e2的头插，也运行到e->next = n。\n\n这时候有两种情况：t1先执行 *p = e，这样就丢失了e2这个数据；t2先执行 *p = e;，这样会丢失e1.所以需要对共享数据加锁。最简单的方法是对整个hash table加锁，每次put前都需要acquire这个锁，但这样效率很低，所有put操作相当于都串行操作了。hints告诉我们实际上只要对hash table的每个bucket加锁就行，因为不同bucket的插入操作彼此互不影响。\n\n代码的话比较简单，主要是熟悉pthread库的mutex锁的使用。\n\n> lock定义了每个bucket的锁，put时加锁即可。\n\n```c\n...\npthread_mutex_t lock[NBUCKET];\n...\nstatic \nvoid put(int key, int value)\n{\n  int i = key % NBUCKET;\n\n  // is the key already present?\n  struct entry *e = 0;\n  pthread_mutex_lock(&lock[i]);\n  for (e = table[i]; e != 0; e = e->next) {\n    if (e->key == key)\n      break;i\n  }\n  if(e){\n    // update the existing key.\n    e->value = value;\n  } else {\n    // the new is new.\n    insert(key, value, &table[i], table[i]);\n  }\n  pthread_mutex_unlock(&lock[i]);\n}\n```\n\n## Barrier\n\n程序开始创建了多个线程，要求每个线程都运行到barrier函数就sleep，直到所有线程都到达barrier函数才能被wakeup。这个lab也比较简单，主要是熟悉pthread的条件变量，本质上和xv6的sleep&wakeup一样。\n\n> barrier_mutex用来保护条件变量nthread，当nthread满足条件后wakeup所有等待barrier_cond这个channel的线程。\n\n```c\nstatic void \nbarrier()\n{\n  // YOUR CODE HERE\n  //\n  // Block until all threads have called barrier() and\n  // then increment bstate.round.\n  //\n  pthread_mutex_lock(&bstate.barrier_mutex);\n  bstate.nthread++;\n  if (bstate.nthread == nthread) {\n    bstate.nthread = 0;\n    bstate.round++;\n    pthread_cond_broadcast(&bstate.barrier_cond);\n  }\n  else {\n    pthread_cond_wait(&bstate.barrier_cond, &bstate.barrier_mutex);\n  }\n  pthread_mutex_unlock(&bstate.barrier_mutex);\n}\n```\n\n\n\n结果\n\n![img](https://pic2.zhimg.com/80/v2-0e04ba414726a4cb23de4791fb4f4ca9_720w.jpg)","slug":"MIT6.S081 Lab7","published":1,"updated":"2021-11-05T04:49:44.801Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckvlyb07c000504v63jyt3ysm","content":"<h2 id=\"Uthread-switching-between-threads\"><a href=\"#Uthread-switching-between-threads\" class=\"headerlink\" title=\"Uthread: switching between threads\"></a>Uthread: switching between threads</h2><p>这个lab要求完善一个用户态线程库，比较简单</p>\n<blockquote>\n<p>首先创建线程时把context的ra设置为传入的函数地址，这样第一次scheduler到这个线程可以返回到执行函数。<br>注意stack是从上往下增长的，所以sp的值初始化为对应stack的顶部。<br>实际上thread[0].stack是没有用到的，因为main线程一直使用的都是进程分配好的栈区域，其他stack被分配在data段。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">thread_create</span><span class=\"params\">(<span class=\"keyword\">void</span> (*func)())</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">thread</span> *<span class=\"title\">t</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (t = all_thread; t &lt; all_thread + MAX_THREAD; t++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (t-&gt;state == FREE) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  t-&gt;state = RUNNABLE;</span><br><span class=\"line\">  <span class=\"comment\">// YOUR CODE HERE</span></span><br><span class=\"line\">  t-&gt;context.ra = (uint64)func;</span><br><span class=\"line\">  t-&gt;context.sp = (uint64)t-&gt;<span class=\"built_in\">stack</span>+STACK_SIZE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>sheduler函数中，找到一个RUNNABLE的线程就进行切换</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (current_thread != next_thread) &#123;         <span class=\"comment\">/* switch threads?  */</span></span><br><span class=\"line\">    next_thread-&gt;state = RUNNING;</span><br><span class=\"line\">    t = current_thread;</span><br><span class=\"line\">    current_thread = next_thread;</span><br><span class=\"line\">    <span class=\"comment\">/* YOUR CODE HERE</span></span><br><span class=\"line\"><span class=\"comment\">     * Invoke thread_switch to switch from t to next_thread:</span></span><br><span class=\"line\"><span class=\"comment\">     * thread_switch(??, ??);</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    thread_switch((uint64)(&amp;t-&gt;context), (uint64)(&amp;current_thread-&gt;context));</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\">    next_thread = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>thread_switch代码和swtch一样</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">thread_switch:</span><br><span class=\"line\">\t/* YOUR CODE HERE */</span><br><span class=\"line\">        sd ra, 0(a0)</span><br><span class=\"line\">        sd sp, 8(a0)</span><br><span class=\"line\">        sd s0, 16(a0)</span><br><span class=\"line\">        sd s1, 24(a0)</span><br><span class=\"line\">        sd s2, 32(a0)</span><br><span class=\"line\">        sd s3, 40(a0)</span><br><span class=\"line\">        sd s4, 48(a0)</span><br><span class=\"line\">        sd s5, 56(a0)</span><br><span class=\"line\">        sd s6, 64(a0)</span><br><span class=\"line\">        sd s7, 72(a0)</span><br><span class=\"line\">        sd s8, 80(a0)</span><br><span class=\"line\">        sd s9, 88(a0)</span><br><span class=\"line\">        sd s10, 96(a0)</span><br><span class=\"line\">        sd s11, 104(a0)</span><br><span class=\"line\"></span><br><span class=\"line\">        ld ra, 0(a1)</span><br><span class=\"line\">        ld sp, 8(a1)</span><br><span class=\"line\">        ld s0, 16(a1)</span><br><span class=\"line\">        ld s1, 24(a1)</span><br><span class=\"line\">        ld s2, 32(a1)</span><br><span class=\"line\">        ld s3, 40(a1)</span><br><span class=\"line\">        ld s4, 48(a1)</span><br><span class=\"line\">        ld s5, 56(a1)</span><br><span class=\"line\">        ld s6, 64(a1)</span><br><span class=\"line\">        ld s7, 72(a1)</span><br><span class=\"line\">        ld s8, 80(a1)</span><br><span class=\"line\">        ld s9, 88(a1)</span><br><span class=\"line\">        ld s10, 96(a1)</span><br><span class=\"line\">        ld s11, 104(a1)</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tret    /* return to ra */</span><br></pre></td></tr></table></figure>\n\n<p>另外需要定义struct context并作为thread类的一个成员变量</p>\n<h2 id=\"Using-threads\"><a href=\"#Using-threads\" class=\"headerlink\" title=\"Using threads\"></a>Using threads</h2><p>这个lab展示了如何使用linux pthread线程库。程序定义了一个链式哈希表并向其中put 10000个kv数据对。创建多个线程执行put操作时，效率会有所提高但会产生miss的情况，也就是一些key并没有成功写入hash table。原因是线程对hash table的操作没有加锁。例如线程t1要对其中某个链表进行e1的头插，当执行完 e-&gt;next = n后切换到线程t2，线程t2同样要对该链表进行e2的头插，也运行到e-&gt;next = n。</p>\n<p>这时候有两种情况：t1先执行 *p = e，这样就丢失了e2这个数据；t2先执行 *p = e;，这样会丢失e1.所以需要对共享数据加锁。最简单的方法是对整个hash table加锁，每次put前都需要acquire这个锁，但这样效率很低，所有put操作相当于都串行操作了。hints告诉我们实际上只要对hash table的每个bucket加锁就行，因为不同bucket的插入操作彼此互不影响。</p>\n<p>代码的话比较简单，主要是熟悉pthread库的mutex锁的使用。</p>\n<blockquote>\n<p>lock定义了每个bucket的锁，put时加锁即可。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">pthread_mutex_t</span> lock[NBUCKET];</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(<span class=\"keyword\">int</span> key, <span class=\"keyword\">int</span> value)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i = key % NBUCKET;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// is the key already present?</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">entry</span> *<span class=\"title\">e</span> =</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  pthread_mutex_lock(&amp;lock[i]);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (e = table[i]; e != <span class=\"number\">0</span>; e = e-&gt;next) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (e-&gt;key == key)</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;i</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(e)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// update the existing key.</span></span><br><span class=\"line\">    e-&gt;value = value;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// the new is new.</span></span><br><span class=\"line\">    insert(key, value, &amp;table[i], table[i]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  pthread_mutex_unlock(&amp;lock[i]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Barrier\"><a href=\"#Barrier\" class=\"headerlink\" title=\"Barrier\"></a>Barrier</h2><p>程序开始创建了多个线程，要求每个线程都运行到barrier函数就sleep，直到所有线程都到达barrier函数才能被wakeup。这个lab也比较简单，主要是熟悉pthread的条件变量，本质上和xv6的sleep&amp;wakeup一样。</p>\n<blockquote>\n<p>barrier_mutex用来保护条件变量nthread，当nthread满足条件后wakeup所有等待barrier_cond这个channel的线程。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">barrier</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// YOUR CODE HERE</span></span><br><span class=\"line\">  <span class=\"comment\">//</span></span><br><span class=\"line\">  <span class=\"comment\">// Block until all threads have called barrier() and</span></span><br><span class=\"line\">  <span class=\"comment\">// then increment bstate.round.</span></span><br><span class=\"line\">  <span class=\"comment\">//</span></span><br><span class=\"line\">  pthread_mutex_lock(&amp;bstate.barrier_mutex);</span><br><span class=\"line\">  bstate.nthread++;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (bstate.nthread == nthread) &#123;</span><br><span class=\"line\">    bstate.nthread = <span class=\"number\">0</span>;</span><br><span class=\"line\">    bstate.round++;</span><br><span class=\"line\">    pthread_cond_broadcast(&amp;bstate.barrier_cond);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    pthread_cond_wait(&amp;bstate.barrier_cond, &amp;bstate.barrier_mutex);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  pthread_mutex_unlock(&amp;bstate.barrier_mutex);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>结果</p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-0e04ba414726a4cb23de4791fb4f4ca9_720w.jpg\" alt=\"img\"></p>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/bg.jpg\");\n  background-repeat: no-repeat;\n  background-size: cover;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.9;\n}\n.header-inner {\n  background: rgba(255,255,255,0.85);\n}\n.popup {\n  opacity: 0.85;\n}\n.sidebar {\n  background-color: transparent;\n}\n","variables":""}},"excerpt":"","more":"<h2 id=\"Uthread-switching-between-threads\"><a href=\"#Uthread-switching-between-threads\" class=\"headerlink\" title=\"Uthread: switching between threads\"></a>Uthread: switching between threads</h2><p>这个lab要求完善一个用户态线程库，比较简单</p>\n<blockquote>\n<p>首先创建线程时把context的ra设置为传入的函数地址，这样第一次scheduler到这个线程可以返回到执行函数。<br>注意stack是从上往下增长的，所以sp的值初始化为对应stack的顶部。<br>实际上thread[0].stack是没有用到的，因为main线程一直使用的都是进程分配好的栈区域，其他stack被分配在data段。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">thread_create</span><span class=\"params\">(<span class=\"keyword\">void</span> (*func)())</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">thread</span> *<span class=\"title\">t</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (t = all_thread; t &lt; all_thread + MAX_THREAD; t++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (t-&gt;state == FREE) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  t-&gt;state = RUNNABLE;</span><br><span class=\"line\">  <span class=\"comment\">// YOUR CODE HERE</span></span><br><span class=\"line\">  t-&gt;context.ra = (uint64)func;</span><br><span class=\"line\">  t-&gt;context.sp = (uint64)t-&gt;<span class=\"built_in\">stack</span>+STACK_SIZE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>sheduler函数中，找到一个RUNNABLE的线程就进行切换</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (current_thread != next_thread) &#123;         <span class=\"comment\">/* switch threads?  */</span></span><br><span class=\"line\">    next_thread-&gt;state = RUNNING;</span><br><span class=\"line\">    t = current_thread;</span><br><span class=\"line\">    current_thread = next_thread;</span><br><span class=\"line\">    <span class=\"comment\">/* YOUR CODE HERE</span></span><br><span class=\"line\"><span class=\"comment\">     * Invoke thread_switch to switch from t to next_thread:</span></span><br><span class=\"line\"><span class=\"comment\">     * thread_switch(??, ??);</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    thread_switch((uint64)(&amp;t-&gt;context), (uint64)(&amp;current_thread-&gt;context));</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span></span><br><span class=\"line\">    next_thread = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>thread_switch代码和swtch一样</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">thread_switch:</span><br><span class=\"line\">\t/* YOUR CODE HERE */</span><br><span class=\"line\">        sd ra, 0(a0)</span><br><span class=\"line\">        sd sp, 8(a0)</span><br><span class=\"line\">        sd s0, 16(a0)</span><br><span class=\"line\">        sd s1, 24(a0)</span><br><span class=\"line\">        sd s2, 32(a0)</span><br><span class=\"line\">        sd s3, 40(a0)</span><br><span class=\"line\">        sd s4, 48(a0)</span><br><span class=\"line\">        sd s5, 56(a0)</span><br><span class=\"line\">        sd s6, 64(a0)</span><br><span class=\"line\">        sd s7, 72(a0)</span><br><span class=\"line\">        sd s8, 80(a0)</span><br><span class=\"line\">        sd s9, 88(a0)</span><br><span class=\"line\">        sd s10, 96(a0)</span><br><span class=\"line\">        sd s11, 104(a0)</span><br><span class=\"line\"></span><br><span class=\"line\">        ld ra, 0(a1)</span><br><span class=\"line\">        ld sp, 8(a1)</span><br><span class=\"line\">        ld s0, 16(a1)</span><br><span class=\"line\">        ld s1, 24(a1)</span><br><span class=\"line\">        ld s2, 32(a1)</span><br><span class=\"line\">        ld s3, 40(a1)</span><br><span class=\"line\">        ld s4, 48(a1)</span><br><span class=\"line\">        ld s5, 56(a1)</span><br><span class=\"line\">        ld s6, 64(a1)</span><br><span class=\"line\">        ld s7, 72(a1)</span><br><span class=\"line\">        ld s8, 80(a1)</span><br><span class=\"line\">        ld s9, 88(a1)</span><br><span class=\"line\">        ld s10, 96(a1)</span><br><span class=\"line\">        ld s11, 104(a1)</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tret    /* return to ra */</span><br></pre></td></tr></table></figure>\n\n<p>另外需要定义struct context并作为thread类的一个成员变量</p>\n<h2 id=\"Using-threads\"><a href=\"#Using-threads\" class=\"headerlink\" title=\"Using threads\"></a>Using threads</h2><p>这个lab展示了如何使用linux pthread线程库。程序定义了一个链式哈希表并向其中put 10000个kv数据对。创建多个线程执行put操作时，效率会有所提高但会产生miss的情况，也就是一些key并没有成功写入hash table。原因是线程对hash table的操作没有加锁。例如线程t1要对其中某个链表进行e1的头插，当执行完 e-&gt;next = n后切换到线程t2，线程t2同样要对该链表进行e2的头插，也运行到e-&gt;next = n。</p>\n<p>这时候有两种情况：t1先执行 *p = e，这样就丢失了e2这个数据；t2先执行 *p = e;，这样会丢失e1.所以需要对共享数据加锁。最简单的方法是对整个hash table加锁，每次put前都需要acquire这个锁，但这样效率很低，所有put操作相当于都串行操作了。hints告诉我们实际上只要对hash table的每个bucket加锁就行，因为不同bucket的插入操作彼此互不影响。</p>\n<p>代码的话比较简单，主要是熟悉pthread库的mutex锁的使用。</p>\n<blockquote>\n<p>lock定义了每个bucket的锁，put时加锁即可。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">pthread_mutex_t</span> lock[NBUCKET];</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(<span class=\"keyword\">int</span> key, <span class=\"keyword\">int</span> value)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i = key % NBUCKET;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// is the key already present?</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">entry</span> *<span class=\"title\">e</span> =</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  pthread_mutex_lock(&amp;lock[i]);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (e = table[i]; e != <span class=\"number\">0</span>; e = e-&gt;next) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (e-&gt;key == key)</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;i</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(e)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// update the existing key.</span></span><br><span class=\"line\">    e-&gt;value = value;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// the new is new.</span></span><br><span class=\"line\">    insert(key, value, &amp;table[i], table[i]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  pthread_mutex_unlock(&amp;lock[i]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Barrier\"><a href=\"#Barrier\" class=\"headerlink\" title=\"Barrier\"></a>Barrier</h2><p>程序开始创建了多个线程，要求每个线程都运行到barrier函数就sleep，直到所有线程都到达barrier函数才能被wakeup。这个lab也比较简单，主要是熟悉pthread的条件变量，本质上和xv6的sleep&amp;wakeup一样。</p>\n<blockquote>\n<p>barrier_mutex用来保护条件变量nthread，当nthread满足条件后wakeup所有等待barrier_cond这个channel的线程。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">barrier</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// YOUR CODE HERE</span></span><br><span class=\"line\">  <span class=\"comment\">//</span></span><br><span class=\"line\">  <span class=\"comment\">// Block until all threads have called barrier() and</span></span><br><span class=\"line\">  <span class=\"comment\">// then increment bstate.round.</span></span><br><span class=\"line\">  <span class=\"comment\">//</span></span><br><span class=\"line\">  pthread_mutex_lock(&amp;bstate.barrier_mutex);</span><br><span class=\"line\">  bstate.nthread++;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (bstate.nthread == nthread) &#123;</span><br><span class=\"line\">    bstate.nthread = <span class=\"number\">0</span>;</span><br><span class=\"line\">    bstate.round++;</span><br><span class=\"line\">    pthread_cond_broadcast(&amp;bstate.barrier_cond);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    pthread_cond_wait(&amp;bstate.barrier_cond, &amp;bstate.barrier_mutex);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  pthread_mutex_unlock(&amp;bstate.barrier_mutex);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>结果</p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-0e04ba414726a4cb23de4791fb4f4ca9_720w.jpg\" alt=\"img\"></p>\n"},{"title":"MIT6.S081 Lab8 Locks","date":"2021-10-14T04:00:00.000Z","_content":"\n## Memory allocator\n\nacquire一个spinlock的时候，如果锁已被占用线程会阻塞，这种锁的争用减弱了系统的并行度，减少了操作系统的效率。执行kalloctest，可以看到\n\n```text\n$ kalloctest\nstart test1\ntest1 results:\n--- lock kmem/bcache stats\nlock: kmem: #fetch-and-add 83375 #acquire() 433015\nlock: bcache: #fetch-and-add 0 #acquire() 1260\n--- top 5 contended locks:\nlock: kmem: #fetch-and-add 83375 #acquire() 433015\nlock: proc: #fetch-and-add 23737 #acquire() 130718\nlock: virtio_disk: #fetch-and-add 11159 #acquire() 114\nlock: proc: #fetch-and-add 5937 #acquire() 130786\nlock: proc: #fetch-and-add 4080 #acquire() 130786\ntot= 83375\ntest1 FAIL\n```\n\nacquire阻塞时对kmem锁的询问达到了83375次。这个lab要求重写分配物理内存的代码，减少锁的争用。\n\n思路是每个cpu分配一个freelist和一个锁，每次cpu执行kalloc或kfree时访问对应的cpu锁，这样cpu之间并行分配内存时就不会争用锁。\n\n另外，当某个cpu的freelist为空时要从别的cpu的freelist里“偷取”可用的物理内存，保证这个过程不会发生死锁。\n\n最开始的想法是平分每个物理页面，根据页面index来分配给对应的cpu，free时根据index还给对应的cpu的freelist。这样做结果也是正确的，但问题是NCPU是cpu的最大值固定为8，实际使用的cpu数不一定为8，make qemu时用了3个hart。\n\n实际上不用这么做，因为只有cpu0会执行kinit以及freerange，一开始把所有物理内存分给cpu0即可。这样别的cpu执行kalloc时会从cpu0“偷取”物理内存，kfree时直接还给这个cpu的freelist，即谁分配就退还给谁。而且不存在的cpu对应的freelist一直为空。\n\n> 数据结构和kinit\n\n```c\nstruct {\n  struct spinlock lock;\n  struct run *freelist;\n} kmem[NCPU];\n\nvoid\nkinit()\n{\n  for (int i = 0; i < NCPU; i++) {\n    initlock(&kmem[i].lock, \"kmem\");\n  }\n  freerange(end, (void*)PHYSTOP);\n}\n```\n\n> kalloc时先获取对应cpu的锁，如果freelist为空，则循环所有cpu偷取可用内存，这一步也需要加锁。\n\n```c\nvoid *\nkalloc(void)\n{\n  struct run *r;\n  int c;\n  push_off();\n  c = cpuid();\n  pop_off();\n  acquire(&kmem[c].lock);\n  r = kmem[c].freelist;\n  if(r) {\n    kmem[c].freelist = r->next;\n  }\n  else {\n    for (int i = 0; i < NCPU; i++) {\n      if (i == c) continue;\n      acquire(&kmem[i].lock);\n      if (kmem[i].freelist) {\n        r = kmem[i].freelist;\n        kmem[i].freelist = r->next;\n        release(&kmem[i].lock);\n        break;\n      }\n      release(&kmem[i].lock);\n    }\n  }\n  if(r)\n    memset((char*)r, 5, PGSIZE); // fill with junk\n  release(&kmem[c].lock);\n  return (void*)r;\n}\n```\n\n在freelist不为空的情况下不会产生锁的争用，因为只用到了本cpu的锁；但是如果需要偷取内存，就可能产生锁的争用。但由于“偷取时对应cpu正好需要kalloc”这件事概率不高，并且acquire和release之间距离比较近，所以产生争用的可能性不大，因此kalloctest时输出的tot为0.\n\n如果在偷取时acquire和release之间加上 for (int i = 0;i < 1000000; i++);可以看到结果是产生了争用的。\n\n![img](https://pic2.zhimg.com/80/v2-89c3ed41f875fec6da034537d125bda5_720w.jpg)\n\n> kfree把内存还给当前cpu。\n\n```c\nvoid\nkfree(void *pa)\n{\n  struct run *r;\n\n  if(((uint64)pa % PGSIZE) != 0 || (char*)pa < end || (uint64)pa >= PHYSTOP)\n    panic(\"kfree\");\n\n  // Fill with junk to catch dangling refs.\n  memset(pa, 1, PGSIZE);\n\n  r = (struct run*)pa;\n  push_off();\n  int c = cpuid();\n  pop_off();\n  acquire(&kmem[c].lock);\n  r->next = kmem[c].freelist;\n  kmem[c].freelist = r;\n  release(&kmem[c].lock);\n}\n```\n\n## Buffer cache\n\n程序访问磁盘时首先会通过bget查看块缓存bcache中有没有所需的block，如果有就无需访问磁盘，仅仅产生内存间数据交换。如果没有需要访问磁盘并且把读取到的块代替bcache的某个buf（通过LRU）。\n\nxv6用了一个大锁bcache.lock保证bcache同时只有一个线程使用，毫无疑问这会导致大量的争用，这个lab要求修改bio.c的代码减少争用。\n\n思路化大锁为小锁，创建多个bucket，根据block的index把对应块hash到对应bucket中。这样每次bget时只需要获取对应bucket的锁，假如多个cpu同时进入bget，但blockno hash到了不同的bucket，这种情况是可以并行的。\n\nhints要求替换buf时用时间戳来实现LRU算法。\n\n> bucket数最好是个质数减少hash冲突，总的buf数就是NBUCKET*BUCKETSZ。xv6原来的buf数是30，我这里增加了一点来尽量减少争用。\n\n```c\n#define NBUCKET 13\n#define BUCKETSZ 8\n\nextern uint ticks;\nstruct bucket {\n  struct spinlock lock;\n  struct buf bufs[BUCKETSZ];\n};\n```\n\n> binit初始化所有bucket的锁\n\n```c\nvoid\nbinit(void)\n{\n  initlock(&bcache.lock, \"bcache\");\n  for (int i = 0; i < NBUCKET; i++) {\n    initlock(&bcache.buckets[i].lock, \"bcache.bucket\");\n    for (int j = 0; j < BUCKETSZ; j++)\n      initsleeplock(&bcache.buckets[i].bufs[j].lock, \"buffer\");\n  }\n}\n```\n\n> bget首先根据blockno获取对应bucket的锁，如果cache中存在这个块，就更新timestamp，并且refcnt++表示当前多了一个线程对这个buf感兴趣。\n> 如果没有对应块，从bucket中选取一个timestamp最小的（LRU）来替换这个块。\n\n```c\nstatic struct buf*\nbget(uint dev, uint blockno)\n{\n  int k = blockno % NBUCKET;\n  acquire(&bcache.buckets[k].lock);\n  struct bucket* bkt = &bcache.buckets[k];\n  struct buf* b;\n  for (b = &bkt->bufs[0]; b < (struct buf*)&bkt->bufs[0] + BUCKETSZ; b++) {\n    if (b->dev == dev && b->blockno == blockno) {\n      b->timestamp = ticks; \n      b->refcnt++;\n      release(&bcache.buckets[k].lock);\n      acquiresleep(&b->lock);\n      return b;\n    }\n  }\n  uint last = -1;\n  struct buf* ret = b;\n  for (b = &bkt->bufs[0]; b < (struct buf*)&bkt->bufs[0] + BUCKETSZ; b++) {\n    if (b->timestamp < last && b->refcnt == 0) {\n      last = b->timestamp;\n      ret = b;  \n    }\n  }\n  ret->dev = dev;\n  ret->blockno = blockno;\n  ret->valid = 0;\n  ret->timestamp = ticks;\n  ret->refcnt = 1;\n  release(&bcache.buckets[k].lock);\n  acquiresleep(&ret->lock);\n  return ret;\n  panic(\"bget: no buffers\");\n}\n```\n\n> brelse不用再release大锁。\n> bpin和bunpin把锁改成对应bucket的锁即可。\n\n```c\nvoid\nbrelse(struct buf *b)\n{\n  if(!holdingsleep(&b->lock))\n    panic(\"brelse\");\n  b->refcnt--;\n  releasesleep(&b->lock);\n}\n\nvoid\nbpin(struct buf *b) {\n  int k = b->blockno % NBUCKET;\n  acquire(&bcache.buckets[k].lock);\n  b->refcnt++;\n  release(&bcache.buckets[k].lock);\n}\n\nvoid\nbunpin(struct buf *b) {\n  int k = b->blockno % NBUCKET;\n  acquire(&bcache.buckets[k].lock);\n  b->refcnt--;\n  release(&bcache.buckets[k].lock);\n}\n```\n\n\n\nbcache减少争用和kmem不一样，内存页面之间是没有区别的，因此kmem可以每个cpu一个锁，如果不考虑“偷取”，kmem可以达到0争用。但是bcache是所有cpu共享的，并且每个buf内容不一样不能随意分配，所以不可能做到0争用。\n\n但是由于bcachetest中，不同进程不会访问同一磁盘块，并且不会同时miss cache，所以争用发生的可能性不大，结果显示tot=0.（实际上这个lab只要求tot<500）\n\n![img](https://pic4.zhimg.com/80/v2-79bc8d636b1fd85126eae88f8c6d2e73_720w.jpg)\n\n这里实现LRU的方法是循环遍历每个buf查看timestamp，这样的效率还不如初始链表实现的做法。hints里要求我们使用timestamp且要删除初始链表，所以我觉得lab的要求其实是要实现bucket之间的“偷取”。当当前bucket需要找替代块的时候，应该要从所有的buf中找到timestamp最小的buf替换，而不是仅仅在当前bucket找。但是我的做法已经能通过测试，就没有改进了。\n\n## 结果\n\n![img](https://pic3.zhimg.com/80/v2-4983007f0ba5e2221c5783a478477476_720w.jpg)\n\n## 心得\n\n第2个lab测试前最好先make clean。","source":"_posts/MIT6.S081 Lab8.md","raw":"---\ntitle: MIT6.S081 Lab8 locks\ndate: 2021-10-14 12:00:00\ntags: 6.S081\n---\n\n## Memory allocator\n\nacquire一个spinlock的时候，如果锁已被占用线程会阻塞，这种锁的争用减弱了系统的并行度，减少了操作系统的效率。执行kalloctest，可以看到\n\n```text\n$ kalloctest\nstart test1\ntest1 results:\n--- lock kmem/bcache stats\nlock: kmem: #fetch-and-add 83375 #acquire() 433015\nlock: bcache: #fetch-and-add 0 #acquire() 1260\n--- top 5 contended locks:\nlock: kmem: #fetch-and-add 83375 #acquire() 433015\nlock: proc: #fetch-and-add 23737 #acquire() 130718\nlock: virtio_disk: #fetch-and-add 11159 #acquire() 114\nlock: proc: #fetch-and-add 5937 #acquire() 130786\nlock: proc: #fetch-and-add 4080 #acquire() 130786\ntot= 83375\ntest1 FAIL\n```\n\nacquire阻塞时对kmem锁的询问达到了83375次。这个lab要求重写分配物理内存的代码，减少锁的争用。\n\n思路是每个cpu分配一个freelist和一个锁，每次cpu执行kalloc或kfree时访问对应的cpu锁，这样cpu之间并行分配内存时就不会争用锁。\n\n另外，当某个cpu的freelist为空时要从别的cpu的freelist里“偷取”可用的物理内存，保证这个过程不会发生死锁。\n\n最开始的想法是平分每个物理页面，根据页面index来分配给对应的cpu，free时根据index还给对应的cpu的freelist。这样做结果也是正确的，但问题是NCPU是cpu的最大值固定为8，实际使用的cpu数不一定为8，make qemu时用了3个hart。\n\n实际上不用这么做，因为只有cpu0会执行kinit以及freerange，一开始把所有物理内存分给cpu0即可。这样别的cpu执行kalloc时会从cpu0“偷取”物理内存，kfree时直接还给这个cpu的freelist，即谁分配就退还给谁。而且不存在的cpu对应的freelist一直为空。\n\n> 数据结构和kinit\n\n```c\nstruct {\n  struct spinlock lock;\n  struct run *freelist;\n} kmem[NCPU];\n\nvoid\nkinit()\n{\n  for (int i = 0; i < NCPU; i++) {\n    initlock(&kmem[i].lock, \"kmem\");\n  }\n  freerange(end, (void*)PHYSTOP);\n}\n```\n\n> kalloc时先获取对应cpu的锁，如果freelist为空，则循环所有cpu偷取可用内存，这一步也需要加锁。\n\n```c\nvoid *\nkalloc(void)\n{\n  struct run *r;\n  int c;\n  push_off();\n  c = cpuid();\n  pop_off();\n  acquire(&kmem[c].lock);\n  r = kmem[c].freelist;\n  if(r) {\n    kmem[c].freelist = r->next;\n  }\n  else {\n    for (int i = 0; i < NCPU; i++) {\n      if (i == c) continue;\n      acquire(&kmem[i].lock);\n      if (kmem[i].freelist) {\n        r = kmem[i].freelist;\n        kmem[i].freelist = r->next;\n        release(&kmem[i].lock);\n        break;\n      }\n      release(&kmem[i].lock);\n    }\n  }\n  if(r)\n    memset((char*)r, 5, PGSIZE); // fill with junk\n  release(&kmem[c].lock);\n  return (void*)r;\n}\n```\n\n在freelist不为空的情况下不会产生锁的争用，因为只用到了本cpu的锁；但是如果需要偷取内存，就可能产生锁的争用。但由于“偷取时对应cpu正好需要kalloc”这件事概率不高，并且acquire和release之间距离比较近，所以产生争用的可能性不大，因此kalloctest时输出的tot为0.\n\n如果在偷取时acquire和release之间加上 for (int i = 0;i < 1000000; i++);可以看到结果是产生了争用的。\n\n![img](https://pic2.zhimg.com/80/v2-89c3ed41f875fec6da034537d125bda5_720w.jpg)\n\n> kfree把内存还给当前cpu。\n\n```c\nvoid\nkfree(void *pa)\n{\n  struct run *r;\n\n  if(((uint64)pa % PGSIZE) != 0 || (char*)pa < end || (uint64)pa >= PHYSTOP)\n    panic(\"kfree\");\n\n  // Fill with junk to catch dangling refs.\n  memset(pa, 1, PGSIZE);\n\n  r = (struct run*)pa;\n  push_off();\n  int c = cpuid();\n  pop_off();\n  acquire(&kmem[c].lock);\n  r->next = kmem[c].freelist;\n  kmem[c].freelist = r;\n  release(&kmem[c].lock);\n}\n```\n\n## Buffer cache\n\n程序访问磁盘时首先会通过bget查看块缓存bcache中有没有所需的block，如果有就无需访问磁盘，仅仅产生内存间数据交换。如果没有需要访问磁盘并且把读取到的块代替bcache的某个buf（通过LRU）。\n\nxv6用了一个大锁bcache.lock保证bcache同时只有一个线程使用，毫无疑问这会导致大量的争用，这个lab要求修改bio.c的代码减少争用。\n\n思路化大锁为小锁，创建多个bucket，根据block的index把对应块hash到对应bucket中。这样每次bget时只需要获取对应bucket的锁，假如多个cpu同时进入bget，但blockno hash到了不同的bucket，这种情况是可以并行的。\n\nhints要求替换buf时用时间戳来实现LRU算法。\n\n> bucket数最好是个质数减少hash冲突，总的buf数就是NBUCKET*BUCKETSZ。xv6原来的buf数是30，我这里增加了一点来尽量减少争用。\n\n```c\n#define NBUCKET 13\n#define BUCKETSZ 8\n\nextern uint ticks;\nstruct bucket {\n  struct spinlock lock;\n  struct buf bufs[BUCKETSZ];\n};\n```\n\n> binit初始化所有bucket的锁\n\n```c\nvoid\nbinit(void)\n{\n  initlock(&bcache.lock, \"bcache\");\n  for (int i = 0; i < NBUCKET; i++) {\n    initlock(&bcache.buckets[i].lock, \"bcache.bucket\");\n    for (int j = 0; j < BUCKETSZ; j++)\n      initsleeplock(&bcache.buckets[i].bufs[j].lock, \"buffer\");\n  }\n}\n```\n\n> bget首先根据blockno获取对应bucket的锁，如果cache中存在这个块，就更新timestamp，并且refcnt++表示当前多了一个线程对这个buf感兴趣。\n> 如果没有对应块，从bucket中选取一个timestamp最小的（LRU）来替换这个块。\n\n```c\nstatic struct buf*\nbget(uint dev, uint blockno)\n{\n  int k = blockno % NBUCKET;\n  acquire(&bcache.buckets[k].lock);\n  struct bucket* bkt = &bcache.buckets[k];\n  struct buf* b;\n  for (b = &bkt->bufs[0]; b < (struct buf*)&bkt->bufs[0] + BUCKETSZ; b++) {\n    if (b->dev == dev && b->blockno == blockno) {\n      b->timestamp = ticks; \n      b->refcnt++;\n      release(&bcache.buckets[k].lock);\n      acquiresleep(&b->lock);\n      return b;\n    }\n  }\n  uint last = -1;\n  struct buf* ret = b;\n  for (b = &bkt->bufs[0]; b < (struct buf*)&bkt->bufs[0] + BUCKETSZ; b++) {\n    if (b->timestamp < last && b->refcnt == 0) {\n      last = b->timestamp;\n      ret = b;  \n    }\n  }\n  ret->dev = dev;\n  ret->blockno = blockno;\n  ret->valid = 0;\n  ret->timestamp = ticks;\n  ret->refcnt = 1;\n  release(&bcache.buckets[k].lock);\n  acquiresleep(&ret->lock);\n  return ret;\n  panic(\"bget: no buffers\");\n}\n```\n\n> brelse不用再release大锁。\n> bpin和bunpin把锁改成对应bucket的锁即可。\n\n```c\nvoid\nbrelse(struct buf *b)\n{\n  if(!holdingsleep(&b->lock))\n    panic(\"brelse\");\n  b->refcnt--;\n  releasesleep(&b->lock);\n}\n\nvoid\nbpin(struct buf *b) {\n  int k = b->blockno % NBUCKET;\n  acquire(&bcache.buckets[k].lock);\n  b->refcnt++;\n  release(&bcache.buckets[k].lock);\n}\n\nvoid\nbunpin(struct buf *b) {\n  int k = b->blockno % NBUCKET;\n  acquire(&bcache.buckets[k].lock);\n  b->refcnt--;\n  release(&bcache.buckets[k].lock);\n}\n```\n\n\n\nbcache减少争用和kmem不一样，内存页面之间是没有区别的，因此kmem可以每个cpu一个锁，如果不考虑“偷取”，kmem可以达到0争用。但是bcache是所有cpu共享的，并且每个buf内容不一样不能随意分配，所以不可能做到0争用。\n\n但是由于bcachetest中，不同进程不会访问同一磁盘块，并且不会同时miss cache，所以争用发生的可能性不大，结果显示tot=0.（实际上这个lab只要求tot<500）\n\n![img](https://pic4.zhimg.com/80/v2-79bc8d636b1fd85126eae88f8c6d2e73_720w.jpg)\n\n这里实现LRU的方法是循环遍历每个buf查看timestamp，这样的效率还不如初始链表实现的做法。hints里要求我们使用timestamp且要删除初始链表，所以我觉得lab的要求其实是要实现bucket之间的“偷取”。当当前bucket需要找替代块的时候，应该要从所有的buf中找到timestamp最小的buf替换，而不是仅仅在当前bucket找。但是我的做法已经能通过测试，就没有改进了。\n\n## 结果\n\n![img](https://pic3.zhimg.com/80/v2-4983007f0ba5e2221c5783a478477476_720w.jpg)\n\n## 心得\n\n第2个lab测试前最好先make clean。","slug":"MIT6.S081 Lab8","published":1,"updated":"2021-11-05T04:49:44.801Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckvlyb07e000804v68j6jh9cg","content":"<h2 id=\"Memory-allocator\"><a href=\"#Memory-allocator\" class=\"headerlink\" title=\"Memory allocator\"></a>Memory allocator</h2><p>acquire一个spinlock的时候，如果锁已被占用线程会阻塞，这种锁的争用减弱了系统的并行度，减少了操作系统的效率。执行kalloctest，可以看到</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kalloctest</span><br><span class=\"line\">start test1</span><br><span class=\"line\">test1 results:</span><br><span class=\"line\">--- lock kmem/bcache stats</span><br><span class=\"line\">lock: kmem: #fetch-and-add 83375 #acquire() 433015</span><br><span class=\"line\">lock: bcache: #fetch-and-add 0 #acquire() 1260</span><br><span class=\"line\">--- top 5 contended locks:</span><br><span class=\"line\">lock: kmem: #fetch-and-add 83375 #acquire() 433015</span><br><span class=\"line\">lock: proc: #fetch-and-add 23737 #acquire() 130718</span><br><span class=\"line\">lock: virtio_disk: #fetch-and-add 11159 #acquire() 114</span><br><span class=\"line\">lock: proc: #fetch-and-add 5937 #acquire() 130786</span><br><span class=\"line\">lock: proc: #fetch-and-add 4080 #acquire() 130786</span><br><span class=\"line\">tot= 83375</span><br><span class=\"line\">test1 FAIL</span><br></pre></td></tr></table></figure>\n\n<p>acquire阻塞时对kmem锁的询问达到了83375次。这个lab要求重写分配物理内存的代码，减少锁的争用。</p>\n<p>思路是每个cpu分配一个freelist和一个锁，每次cpu执行kalloc或kfree时访问对应的cpu锁，这样cpu之间并行分配内存时就不会争用锁。</p>\n<p>另外，当某个cpu的freelist为空时要从别的cpu的freelist里“偷取”可用的物理内存，保证这个过程不会发生死锁。</p>\n<p>最开始的想法是平分每个物理页面，根据页面index来分配给对应的cpu，free时根据index还给对应的cpu的freelist。这样做结果也是正确的，但问题是NCPU是cpu的最大值固定为8，实际使用的cpu数不一定为8，make qemu时用了3个hart。</p>\n<p>实际上不用这么做，因为只有cpu0会执行kinit以及freerange，一开始把所有物理内存分给cpu0即可。这样别的cpu执行kalloc时会从cpu0“偷取”物理内存，kfree时直接还给这个cpu的freelist，即谁分配就退还给谁。而且不存在的cpu对应的freelist一直为空。</p>\n<blockquote>\n<p>数据结构和kinit</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">spinlock</span> <span class=\"title\">lock</span>;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">run</span> *<span class=\"title\">freelist</span>;</span></span><br><span class=\"line\">&#125; kmem[NCPU];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">kinit</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; NCPU; i++) &#123;</span><br><span class=\"line\">    initlock(&amp;kmem[i].lock, <span class=\"string\">&quot;kmem&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  freerange(end, (<span class=\"keyword\">void</span>*)PHYSTOP);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>kalloc时先获取对应cpu的锁，如果freelist为空，则循环所有cpu偷取可用内存，这一步也需要加锁。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">kalloc</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">run</span> *<span class=\"title\">r</span>;</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> c;</span><br><span class=\"line\">  push_off();</span><br><span class=\"line\">  c = cpuid();</span><br><span class=\"line\">  pop_off();</span><br><span class=\"line\">  acquire(&amp;kmem[c].lock);</span><br><span class=\"line\">  r = kmem[c].freelist;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(r) &#123;</span><br><span class=\"line\">    kmem[c].freelist = r-&gt;next;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; NCPU; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i == c) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">      acquire(&amp;kmem[i].lock);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (kmem[i].freelist) &#123;</span><br><span class=\"line\">        r = kmem[i].freelist;</span><br><span class=\"line\">        kmem[i].freelist = r-&gt;next;</span><br><span class=\"line\">        release(&amp;kmem[i].lock);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      release(&amp;kmem[i].lock);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(r)</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>((<span class=\"keyword\">char</span>*)r, <span class=\"number\">5</span>, PGSIZE); <span class=\"comment\">// fill with junk</span></span><br><span class=\"line\">  release(&amp;kmem[c].lock);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"keyword\">void</span>*)r;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在freelist不为空的情况下不会产生锁的争用，因为只用到了本cpu的锁；但是如果需要偷取内存，就可能产生锁的争用。但由于“偷取时对应cpu正好需要kalloc”这件事概率不高，并且acquire和release之间距离比较近，所以产生争用的可能性不大，因此kalloctest时输出的tot为0.</p>\n<p>如果在偷取时acquire和release之间加上 for (int i = 0;i &lt; 1000000; i++);可以看到结果是产生了争用的。</p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-89c3ed41f875fec6da034537d125bda5_720w.jpg\" alt=\"img\"></p>\n<blockquote>\n<p>kfree把内存还给当前cpu。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">kfree</span><span class=\"params\">(<span class=\"keyword\">void</span> *pa)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">run</span> *<span class=\"title\">r</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(((uint64)pa % PGSIZE) != <span class=\"number\">0</span> || (<span class=\"keyword\">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class=\"line\">    panic(<span class=\"string\">&quot;kfree&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Fill with junk to catch dangling refs.</span></span><br><span class=\"line\">  <span class=\"built_in\">memset</span>(pa, <span class=\"number\">1</span>, PGSIZE);</span><br><span class=\"line\"></span><br><span class=\"line\">  r = (struct run*)pa;</span><br><span class=\"line\">  push_off();</span><br><span class=\"line\">  <span class=\"keyword\">int</span> c = cpuid();</span><br><span class=\"line\">  pop_off();</span><br><span class=\"line\">  acquire(&amp;kmem[c].lock);</span><br><span class=\"line\">  r-&gt;next = kmem[c].freelist;</span><br><span class=\"line\">  kmem[c].freelist = r;</span><br><span class=\"line\">  release(&amp;kmem[c].lock);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Buffer-cache\"><a href=\"#Buffer-cache\" class=\"headerlink\" title=\"Buffer cache\"></a>Buffer cache</h2><p>程序访问磁盘时首先会通过bget查看块缓存bcache中有没有所需的block，如果有就无需访问磁盘，仅仅产生内存间数据交换。如果没有需要访问磁盘并且把读取到的块代替bcache的某个buf（通过LRU）。</p>\n<p>xv6用了一个大锁bcache.lock保证bcache同时只有一个线程使用，毫无疑问这会导致大量的争用，这个lab要求修改bio.c的代码减少争用。</p>\n<p>思路化大锁为小锁，创建多个bucket，根据block的index把对应块hash到对应bucket中。这样每次bget时只需要获取对应bucket的锁，假如多个cpu同时进入bget，但blockno hash到了不同的bucket，这种情况是可以并行的。</p>\n<p>hints要求替换buf时用时间戳来实现LRU算法。</p>\n<blockquote>\n<p>bucket数最好是个质数减少hash冲突，总的buf数就是NBUCKET*BUCKETSZ。xv6原来的buf数是30，我这里增加了一点来尽量减少争用。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NBUCKET 13</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BUCKETSZ 8</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">extern</span> uint ticks;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bucket</span> &#123;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">spinlock</span> <span class=\"title\">lock</span>;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">buf</span> <span class=\"title\">bufs</span>[<span class=\"title\">BUCKETSZ</span>];</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>binit初始化所有bucket的锁</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">binit</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  initlock(&amp;bcache.lock, <span class=\"string\">&quot;bcache&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; NBUCKET; i++) &#123;</span><br><span class=\"line\">    initlock(&amp;bcache.buckets[i].lock, <span class=\"string\">&quot;bcache.bucket&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; BUCKETSZ; j++)</span><br><span class=\"line\">      initsleeplock(&amp;bcache.buckets[i].bufs[j].lock, <span class=\"string\">&quot;buffer&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>bget首先根据blockno获取对应bucket的锁，如果cache中存在这个块，就更新timestamp，并且refcnt++表示当前多了一个线程对这个buf感兴趣。<br>如果没有对应块，从bucket中选取一个timestamp最小的（LRU）来替换这个块。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> struct buf*</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">bget</span><span class=\"params\">(uint dev, uint blockno)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> k = blockno % NBUCKET;</span><br><span class=\"line\">  acquire(&amp;bcache.buckets[k].lock);</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bucket</span>* <span class=\"title\">bkt</span> =</span> &amp;bcache.buckets[k];</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">buf</span>* <span class=\"title\">b</span>;</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (b = &amp;bkt-&gt;bufs[<span class=\"number\">0</span>]; b &lt; (struct buf*)&amp;bkt-&gt;bufs[<span class=\"number\">0</span>] + BUCKETSZ; b++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno) &#123;</span><br><span class=\"line\">      b-&gt;timestamp = ticks; </span><br><span class=\"line\">      b-&gt;refcnt++;</span><br><span class=\"line\">      release(&amp;bcache.buckets[k].lock);</span><br><span class=\"line\">      acquiresleep(&amp;b-&gt;lock);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  uint last = <span class=\"number\">-1</span>;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">buf</span>* <span class=\"title\">ret</span> =</span> b;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (b = &amp;bkt-&gt;bufs[<span class=\"number\">0</span>]; b &lt; (struct buf*)&amp;bkt-&gt;bufs[<span class=\"number\">0</span>] + BUCKETSZ; b++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (b-&gt;timestamp &lt; last &amp;&amp; b-&gt;refcnt == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      last = b-&gt;timestamp;</span><br><span class=\"line\">      ret = b;  </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ret-&gt;dev = dev;</span><br><span class=\"line\">  ret-&gt;blockno = blockno;</span><br><span class=\"line\">  ret-&gt;valid = <span class=\"number\">0</span>;</span><br><span class=\"line\">  ret-&gt;timestamp = ticks;</span><br><span class=\"line\">  ret-&gt;refcnt = <span class=\"number\">1</span>;</span><br><span class=\"line\">  release(&amp;bcache.buckets[k].lock);</span><br><span class=\"line\">  acquiresleep(&amp;ret-&gt;lock);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">  panic(<span class=\"string\">&quot;bget: no buffers&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>brelse不用再release大锁。<br>bpin和bunpin把锁改成对应bucket的锁即可。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">brelse</span><span class=\"params\">(struct buf *b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!holdingsleep(&amp;b-&gt;lock))</span><br><span class=\"line\">    panic(<span class=\"string\">&quot;brelse&quot;</span>);</span><br><span class=\"line\">  b-&gt;refcnt--;</span><br><span class=\"line\">  releasesleep(&amp;b-&gt;lock);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">bpin</span><span class=\"params\">(struct buf *b)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> k = b-&gt;blockno % NBUCKET;</span><br><span class=\"line\">  acquire(&amp;bcache.buckets[k].lock);</span><br><span class=\"line\">  b-&gt;refcnt++;</span><br><span class=\"line\">  release(&amp;bcache.buckets[k].lock);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">bunpin</span><span class=\"params\">(struct buf *b)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> k = b-&gt;blockno % NBUCKET;</span><br><span class=\"line\">  acquire(&amp;bcache.buckets[k].lock);</span><br><span class=\"line\">  b-&gt;refcnt--;</span><br><span class=\"line\">  release(&amp;bcache.buckets[k].lock);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>bcache减少争用和kmem不一样，内存页面之间是没有区别的，因此kmem可以每个cpu一个锁，如果不考虑“偷取”，kmem可以达到0争用。但是bcache是所有cpu共享的，并且每个buf内容不一样不能随意分配，所以不可能做到0争用。</p>\n<p>但是由于bcachetest中，不同进程不会访问同一磁盘块，并且不会同时miss cache，所以争用发生的可能性不大，结果显示tot=0.（实际上这个lab只要求tot&lt;500）</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-79bc8d636b1fd85126eae88f8c6d2e73_720w.jpg\" alt=\"img\"></p>\n<p>这里实现LRU的方法是循环遍历每个buf查看timestamp，这样的效率还不如初始链表实现的做法。hints里要求我们使用timestamp且要删除初始链表，所以我觉得lab的要求其实是要实现bucket之间的“偷取”。当当前bucket需要找替代块的时候，应该要从所有的buf中找到timestamp最小的buf替换，而不是仅仅在当前bucket找。但是我的做法已经能通过测试，就没有改进了。</p>\n<h2 id=\"结果\"><a href=\"#结果\" class=\"headerlink\" title=\"结果\"></a>结果</h2><p><img src=\"https://pic3.zhimg.com/80/v2-4983007f0ba5e2221c5783a478477476_720w.jpg\" alt=\"img\"></p>\n<h2 id=\"心得\"><a href=\"#心得\" class=\"headerlink\" title=\"心得\"></a>心得</h2><p>第2个lab测试前最好先make clean。</p>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/bg.jpg\");\n  background-repeat: no-repeat;\n  background-size: cover;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.9;\n}\n.header-inner {\n  background: rgba(255,255,255,0.85);\n}\n.popup {\n  opacity: 0.85;\n}\n.sidebar {\n  background-color: transparent;\n}\n","variables":""}},"excerpt":"","more":"<h2 id=\"Memory-allocator\"><a href=\"#Memory-allocator\" class=\"headerlink\" title=\"Memory allocator\"></a>Memory allocator</h2><p>acquire一个spinlock的时候，如果锁已被占用线程会阻塞，这种锁的争用减弱了系统的并行度，减少了操作系统的效率。执行kalloctest，可以看到</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ kalloctest</span><br><span class=\"line\">start test1</span><br><span class=\"line\">test1 results:</span><br><span class=\"line\">--- lock kmem/bcache stats</span><br><span class=\"line\">lock: kmem: #fetch-and-add 83375 #acquire() 433015</span><br><span class=\"line\">lock: bcache: #fetch-and-add 0 #acquire() 1260</span><br><span class=\"line\">--- top 5 contended locks:</span><br><span class=\"line\">lock: kmem: #fetch-and-add 83375 #acquire() 433015</span><br><span class=\"line\">lock: proc: #fetch-and-add 23737 #acquire() 130718</span><br><span class=\"line\">lock: virtio_disk: #fetch-and-add 11159 #acquire() 114</span><br><span class=\"line\">lock: proc: #fetch-and-add 5937 #acquire() 130786</span><br><span class=\"line\">lock: proc: #fetch-and-add 4080 #acquire() 130786</span><br><span class=\"line\">tot= 83375</span><br><span class=\"line\">test1 FAIL</span><br></pre></td></tr></table></figure>\n\n<p>acquire阻塞时对kmem锁的询问达到了83375次。这个lab要求重写分配物理内存的代码，减少锁的争用。</p>\n<p>思路是每个cpu分配一个freelist和一个锁，每次cpu执行kalloc或kfree时访问对应的cpu锁，这样cpu之间并行分配内存时就不会争用锁。</p>\n<p>另外，当某个cpu的freelist为空时要从别的cpu的freelist里“偷取”可用的物理内存，保证这个过程不会发生死锁。</p>\n<p>最开始的想法是平分每个物理页面，根据页面index来分配给对应的cpu，free时根据index还给对应的cpu的freelist。这样做结果也是正确的，但问题是NCPU是cpu的最大值固定为8，实际使用的cpu数不一定为8，make qemu时用了3个hart。</p>\n<p>实际上不用这么做，因为只有cpu0会执行kinit以及freerange，一开始把所有物理内存分给cpu0即可。这样别的cpu执行kalloc时会从cpu0“偷取”物理内存，kfree时直接还给这个cpu的freelist，即谁分配就退还给谁。而且不存在的cpu对应的freelist一直为空。</p>\n<blockquote>\n<p>数据结构和kinit</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">spinlock</span> <span class=\"title\">lock</span>;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">run</span> *<span class=\"title\">freelist</span>;</span></span><br><span class=\"line\">&#125; kmem[NCPU];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">kinit</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; NCPU; i++) &#123;</span><br><span class=\"line\">    initlock(&amp;kmem[i].lock, <span class=\"string\">&quot;kmem&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  freerange(end, (<span class=\"keyword\">void</span>*)PHYSTOP);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>kalloc时先获取对应cpu的锁，如果freelist为空，则循环所有cpu偷取可用内存，这一步也需要加锁。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">kalloc</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">run</span> *<span class=\"title\">r</span>;</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> c;</span><br><span class=\"line\">  push_off();</span><br><span class=\"line\">  c = cpuid();</span><br><span class=\"line\">  pop_off();</span><br><span class=\"line\">  acquire(&amp;kmem[c].lock);</span><br><span class=\"line\">  r = kmem[c].freelist;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(r) &#123;</span><br><span class=\"line\">    kmem[c].freelist = r-&gt;next;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; NCPU; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i == c) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">      acquire(&amp;kmem[i].lock);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (kmem[i].freelist) &#123;</span><br><span class=\"line\">        r = kmem[i].freelist;</span><br><span class=\"line\">        kmem[i].freelist = r-&gt;next;</span><br><span class=\"line\">        release(&amp;kmem[i].lock);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      release(&amp;kmem[i].lock);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(r)</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>((<span class=\"keyword\">char</span>*)r, <span class=\"number\">5</span>, PGSIZE); <span class=\"comment\">// fill with junk</span></span><br><span class=\"line\">  release(&amp;kmem[c].lock);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"keyword\">void</span>*)r;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在freelist不为空的情况下不会产生锁的争用，因为只用到了本cpu的锁；但是如果需要偷取内存，就可能产生锁的争用。但由于“偷取时对应cpu正好需要kalloc”这件事概率不高，并且acquire和release之间距离比较近，所以产生争用的可能性不大，因此kalloctest时输出的tot为0.</p>\n<p>如果在偷取时acquire和release之间加上 for (int i = 0;i &lt; 1000000; i++);可以看到结果是产生了争用的。</p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-89c3ed41f875fec6da034537d125bda5_720w.jpg\" alt=\"img\"></p>\n<blockquote>\n<p>kfree把内存还给当前cpu。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">kfree</span><span class=\"params\">(<span class=\"keyword\">void</span> *pa)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">run</span> *<span class=\"title\">r</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(((uint64)pa % PGSIZE) != <span class=\"number\">0</span> || (<span class=\"keyword\">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class=\"line\">    panic(<span class=\"string\">&quot;kfree&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Fill with junk to catch dangling refs.</span></span><br><span class=\"line\">  <span class=\"built_in\">memset</span>(pa, <span class=\"number\">1</span>, PGSIZE);</span><br><span class=\"line\"></span><br><span class=\"line\">  r = (struct run*)pa;</span><br><span class=\"line\">  push_off();</span><br><span class=\"line\">  <span class=\"keyword\">int</span> c = cpuid();</span><br><span class=\"line\">  pop_off();</span><br><span class=\"line\">  acquire(&amp;kmem[c].lock);</span><br><span class=\"line\">  r-&gt;next = kmem[c].freelist;</span><br><span class=\"line\">  kmem[c].freelist = r;</span><br><span class=\"line\">  release(&amp;kmem[c].lock);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Buffer-cache\"><a href=\"#Buffer-cache\" class=\"headerlink\" title=\"Buffer cache\"></a>Buffer cache</h2><p>程序访问磁盘时首先会通过bget查看块缓存bcache中有没有所需的block，如果有就无需访问磁盘，仅仅产生内存间数据交换。如果没有需要访问磁盘并且把读取到的块代替bcache的某个buf（通过LRU）。</p>\n<p>xv6用了一个大锁bcache.lock保证bcache同时只有一个线程使用，毫无疑问这会导致大量的争用，这个lab要求修改bio.c的代码减少争用。</p>\n<p>思路化大锁为小锁，创建多个bucket，根据block的index把对应块hash到对应bucket中。这样每次bget时只需要获取对应bucket的锁，假如多个cpu同时进入bget，但blockno hash到了不同的bucket，这种情况是可以并行的。</p>\n<p>hints要求替换buf时用时间戳来实现LRU算法。</p>\n<blockquote>\n<p>bucket数最好是个质数减少hash冲突，总的buf数就是NBUCKET*BUCKETSZ。xv6原来的buf数是30，我这里增加了一点来尽量减少争用。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NBUCKET 13</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BUCKETSZ 8</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">extern</span> uint ticks;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bucket</span> &#123;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">spinlock</span> <span class=\"title\">lock</span>;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">buf</span> <span class=\"title\">bufs</span>[<span class=\"title\">BUCKETSZ</span>];</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>binit初始化所有bucket的锁</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">binit</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  initlock(&amp;bcache.lock, <span class=\"string\">&quot;bcache&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; NBUCKET; i++) &#123;</span><br><span class=\"line\">    initlock(&amp;bcache.buckets[i].lock, <span class=\"string\">&quot;bcache.bucket&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; BUCKETSZ; j++)</span><br><span class=\"line\">      initsleeplock(&amp;bcache.buckets[i].bufs[j].lock, <span class=\"string\">&quot;buffer&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>bget首先根据blockno获取对应bucket的锁，如果cache中存在这个块，就更新timestamp，并且refcnt++表示当前多了一个线程对这个buf感兴趣。<br>如果没有对应块，从bucket中选取一个timestamp最小的（LRU）来替换这个块。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> struct buf*</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">bget</span><span class=\"params\">(uint dev, uint blockno)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> k = blockno % NBUCKET;</span><br><span class=\"line\">  acquire(&amp;bcache.buckets[k].lock);</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">bucket</span>* <span class=\"title\">bkt</span> =</span> &amp;bcache.buckets[k];</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">buf</span>* <span class=\"title\">b</span>;</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (b = &amp;bkt-&gt;bufs[<span class=\"number\">0</span>]; b &lt; (struct buf*)&amp;bkt-&gt;bufs[<span class=\"number\">0</span>] + BUCKETSZ; b++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno) &#123;</span><br><span class=\"line\">      b-&gt;timestamp = ticks; </span><br><span class=\"line\">      b-&gt;refcnt++;</span><br><span class=\"line\">      release(&amp;bcache.buckets[k].lock);</span><br><span class=\"line\">      acquiresleep(&amp;b-&gt;lock);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  uint last = <span class=\"number\">-1</span>;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">buf</span>* <span class=\"title\">ret</span> =</span> b;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (b = &amp;bkt-&gt;bufs[<span class=\"number\">0</span>]; b &lt; (struct buf*)&amp;bkt-&gt;bufs[<span class=\"number\">0</span>] + BUCKETSZ; b++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (b-&gt;timestamp &lt; last &amp;&amp; b-&gt;refcnt == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      last = b-&gt;timestamp;</span><br><span class=\"line\">      ret = b;  </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ret-&gt;dev = dev;</span><br><span class=\"line\">  ret-&gt;blockno = blockno;</span><br><span class=\"line\">  ret-&gt;valid = <span class=\"number\">0</span>;</span><br><span class=\"line\">  ret-&gt;timestamp = ticks;</span><br><span class=\"line\">  ret-&gt;refcnt = <span class=\"number\">1</span>;</span><br><span class=\"line\">  release(&amp;bcache.buckets[k].lock);</span><br><span class=\"line\">  acquiresleep(&amp;ret-&gt;lock);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">  panic(<span class=\"string\">&quot;bget: no buffers&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>brelse不用再release大锁。<br>bpin和bunpin把锁改成对应bucket的锁即可。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">brelse</span><span class=\"params\">(struct buf *b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!holdingsleep(&amp;b-&gt;lock))</span><br><span class=\"line\">    panic(<span class=\"string\">&quot;brelse&quot;</span>);</span><br><span class=\"line\">  b-&gt;refcnt--;</span><br><span class=\"line\">  releasesleep(&amp;b-&gt;lock);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">bpin</span><span class=\"params\">(struct buf *b)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> k = b-&gt;blockno % NBUCKET;</span><br><span class=\"line\">  acquire(&amp;bcache.buckets[k].lock);</span><br><span class=\"line\">  b-&gt;refcnt++;</span><br><span class=\"line\">  release(&amp;bcache.buckets[k].lock);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">bunpin</span><span class=\"params\">(struct buf *b)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> k = b-&gt;blockno % NBUCKET;</span><br><span class=\"line\">  acquire(&amp;bcache.buckets[k].lock);</span><br><span class=\"line\">  b-&gt;refcnt--;</span><br><span class=\"line\">  release(&amp;bcache.buckets[k].lock);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>bcache减少争用和kmem不一样，内存页面之间是没有区别的，因此kmem可以每个cpu一个锁，如果不考虑“偷取”，kmem可以达到0争用。但是bcache是所有cpu共享的，并且每个buf内容不一样不能随意分配，所以不可能做到0争用。</p>\n<p>但是由于bcachetest中，不同进程不会访问同一磁盘块，并且不会同时miss cache，所以争用发生的可能性不大，结果显示tot=0.（实际上这个lab只要求tot&lt;500）</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-79bc8d636b1fd85126eae88f8c6d2e73_720w.jpg\" alt=\"img\"></p>\n<p>这里实现LRU的方法是循环遍历每个buf查看timestamp，这样的效率还不如初始链表实现的做法。hints里要求我们使用timestamp且要删除初始链表，所以我觉得lab的要求其实是要实现bucket之间的“偷取”。当当前bucket需要找替代块的时候，应该要从所有的buf中找到timestamp最小的buf替换，而不是仅仅在当前bucket找。但是我的做法已经能通过测试，就没有改进了。</p>\n<h2 id=\"结果\"><a href=\"#结果\" class=\"headerlink\" title=\"结果\"></a>结果</h2><p><img src=\"https://pic3.zhimg.com/80/v2-4983007f0ba5e2221c5783a478477476_720w.jpg\" alt=\"img\"></p>\n<h2 id=\"心得\"><a href=\"#心得\" class=\"headerlink\" title=\"心得\"></a>心得</h2><p>第2个lab测试前最好先make clean。</p>\n"},{"title":"MIT6.S081 Lab9 FileSystem","date":"2021-11-05T04:00:00.000Z","_content":"\n## Large files\n\n这个实验要求扩展xv6文件大小，从268个block（12direct * 1+1single indirect * 256）扩展到65803个block（11derect * 1+1single indirect * 256+1double indirect * 256 * 256）。\n\n需要看懂bmap函数的作用，bmap接收一个inode和逻辑块号bn，通过寻址把bn映射为物理块号返回。\n\n> inode的addrs大小不变仍为13，direct缩小为11，最后一位改为double indirect，dinode同理。\n\n```c\nstatic uint\nbmap(struct inode *ip, uint bn)\n{\n  uint addr, *a;\n  struct buf *bp;\n\n  if(bn < NDIRECT){\n    if((addr = ip->addrs[bn]) == 0)\n      ip->addrs[bn] = addr = balloc(ip->dev);\n    return addr;\n  }\n  bn -= NDIRECT;\n\n  if(bn < NINDIRECT){\n    // Load indirect block, allocating if necessary.\n    if((addr = ip->addrs[NDIRECT]) == 0)\n      ip->addrs[NDIRECT] = addr = balloc(ip->dev);\n    bp = bread(ip->dev, addr);\n    a = (uint*)bp->data;\n    if((addr = a[bn]) == 0){\n      a[bn] = addr = balloc(ip->dev);\n      log_write(bp);\n    }\n    brelse(bp);\n    return addr;\n  }\n  bn -= NINDIRECT;\n  if (bn < NDBDIRECT) {\n    if ((addr = ip->addrs[NDIRECT + 1]) == 0)\n      ip->addrs[NDIRECT + 1] = addr = balloc(ip->dev);\n    bp = bread(ip->dev, addr);\n    a = (uint*)bp->data;\n    if ((addr = a[bn / NINDIRECT]) == 0) {\n      a[bn / NINDIRECT] = addr = balloc(ip->dev);\n      log_write(bp);\n    }\n    brelse(bp);\n    bp = bread(ip->dev, addr);\n    a = (uint*)bp->data;\n    if ((addr = a[bn % NINDIRECT]) == 0) {\n      a[bn % NINDIRECT] = addr = balloc(ip->dev);\n      log_write(bp);\n    }\n    brelse(bp);\n    return addr;\n  }\n  panic(\"bmap: out of range\");\n}\n```\n\n> 修改itrunc使得能够释放double indirect的块。\n\n```c\n\nvoid\nitrunc(struct inode *ip)\n{\n  int i, j;\n  struct buf *bp;\n  uint *a;\n\n  for(i = 0; i < NDIRECT; i++){\n    if(ip->addrs[i]){\n      bfree(ip->dev, ip->addrs[i]);\n      ip->addrs[i] = 0;\n    }\n  }\n\n  if(ip->addrs[NDIRECT]){\n    bp = bread(ip->dev, ip->addrs[NDIRECT]);\n    a = (uint*)bp->data;\n    for(j = 0; j < NINDIRECT; j++){\n      if(a[j])\n        bfree(ip->dev, a[j]);\n    }\n    brelse(bp);\n    bfree(ip->dev, ip->addrs[NDIRECT]);\n    ip->addrs[NDIRECT] = 0;\n  }\n  if (ip->addrs[NDIRECT + 1]) {\n    bp = bread(ip->dev, ip->addrs[NDIRECT + 1]);\n    a = (uint*)bp->data;\n    for(j = 0; j < NINDIRECT; j++) {\n      if (a[j]) {\n        uint addr, *data;\n        struct buf *bbp;\n        addr = a[j];\n        bbp = bread(ip->dev, addr);\n        data = (uint*)bbp->data;\n        for (int k = 0; k < NINDIRECT; k++) {\n          if (data[k])\n            bfree(ip->dev, data[k]);\n        }\n        brelse(bbp);\n        bfree(ip->dev, addr);\n      }\n    }\n    brelse(bp);\n    bfree(ip->dev, ip->addrs[NDIRECT + 1]);\n    ip->addrs[NDIRECT + 1] = 0;\n  }\n  ip->size = 0;\n  iupdate(ip);\n}\n```\n\n## Symbolic links\n\n硬链接就是几个不同的direntry拥有相同的inum。软链接是一个特殊的文件，文件内容是一个路径指向所链接的文件。\n\nxv6实现了硬链接，这个lab要求实现软链接。\n\n> 首先实现系统调用symlink来创建一个软链接文件。\n\n```c\nuint64\nsys_symlink(void) {\n  char target[MAXPATH], path[MAXPATH];\n  struct inode *ip;\n  if (argstr(0, target, MAXPATH) < 0 || argstr(1, path, MAXPATH) < 0) {\n    return -1;\n  }\n  begin_op();\n\n  if ((ip = create(path, T_SYMLINK, 0, 0)) == 0) {\n    end_op();\n    return -1;\n  }\n  writei(ip, 0, (uint64)target, 0, MAXPATH);\n  iunlockput(ip);\n  end_op();\n\n  return 0;\n}\n```\n\n> 修改系统调用open用来打开软链接文件。如果O_NOFOLLOW则直接返回这个软链接的inode。\n>\n> 否则返回它指向的文件的inode，如果指向的文件也是一个软链接，继续打开软链接指向的文件直到指向一个inode或形成环。\n>\n> 这里需要注意iunlock和iput的区别。iget/iput用于增加/减少ip的ref，用于表示inode cache中这个inode有多少个指针正在指向它，如果没有一个进程指向这个inode，则可以从cache中释放。\n>\n> ilock/iunlock用于给inode加锁保证线程同步。\n>\n> 一般的调用操作顺序是iget->ilock->iunlock->iput.在open系统调用中，如果成功找到一个ip，返回时只需要到iunlock即可，不需要iput，因为open文件表示这个进程正在使用这个inode。直到close才能iput。\n>\n> 另外注意有的函数中间会执行iget/ilock，例如namei成功调用时返回的ip是已经经过iget操作的。\n>\n> 任何不需要的inode（open操作失败，或者递归打开软链接）都应该iunlockput。\n\n```c\nuint64\nsys_open(void)\n{\n  char path[MAXPATH];\n  int fd, omode;\n  struct file *f;\n  struct inode *ip;\n  int n;\n\n  if((n = argstr(0, path, MAXPATH)) < 0 || argint(1, &omode) < 0)\n    return -1;\n\n  begin_op();\n\n  if(omode & O_CREATE){\n    ip = create(path, T_FILE, 0, 0);\n    if(ip == 0){\n      end_op();\n      return -1;\n    }\n  } else {\n    if((ip = namei(path)) == 0){\n      end_op();\n      return -1;\n    }\n    ilock(ip);\n    if(ip->type == T_DIR && omode != O_RDONLY){\n      iunlockput(ip);\n      end_op();\n      return -1;\n    }\n  }\n\n  if(ip->type == T_DEVICE && (ip->major < 0 || ip->major >= NDEV)){\n    iunlockput(ip);\n    end_op();\n    return -1;\n  }\n  int depth = 0;\n  if (ip->type == T_SYMLINK && !(omode&O_NOFOLLOW)) {\n    while (ip->type == T_SYMLINK && depth < 10) {\n      readi(ip, 0, (uint64)path, 0, MAXPATH);\n      iunlockput(ip);\n      if ((ip = namei(path)) == 0) {\n        end_op();\n        return -1;\n      }\n      ilock(ip);\n      depth++;\n    }\n    if (depth == 10) {\n      iunlockput(ip);\n      end_op();\n      return -1;\n    }\n  }\n  if((f = filealloc()) == 0 || (fd = fdalloc(f)) < 0){\n    if(f)\n      fileclose(f);\n    iunlockput(ip);\n    end_op();\n    return -1;\n  } \n  \n\n  if(ip->type == T_DEVICE){\n    f->type = FD_DEVICE;\n    f->major = ip->major;\n  } else {\n    f->type = FD_INODE;\n    f->off = 0;\n  }\n  f->ip = ip;\n  f->readable = !(omode & O_WRONLY);\n  f->writable = (omode & O_WRONLY) || (omode & O_RDWR);\n\n  if((omode & O_TRUNC) && ip->type == T_FILE){\n    itrunc(ip);\n  }\n\n  iunlock(ip);\n  end_op();\n\n  return fd;\n}\n```\n\n## 结果\n\n![](/images/1.png)\n","source":"_posts/MIT6.S081 Lab9.md","raw":"---\ntitle: MIT6.S081 Lab9 FileSystem\ndate: 2021-11-05 12:00:00\ntags: 6.S081\n---\n\n## Large files\n\n这个实验要求扩展xv6文件大小，从268个block（12direct * 1+1single indirect * 256）扩展到65803个block（11derect * 1+1single indirect * 256+1double indirect * 256 * 256）。\n\n需要看懂bmap函数的作用，bmap接收一个inode和逻辑块号bn，通过寻址把bn映射为物理块号返回。\n\n> inode的addrs大小不变仍为13，direct缩小为11，最后一位改为double indirect，dinode同理。\n\n```c\nstatic uint\nbmap(struct inode *ip, uint bn)\n{\n  uint addr, *a;\n  struct buf *bp;\n\n  if(bn < NDIRECT){\n    if((addr = ip->addrs[bn]) == 0)\n      ip->addrs[bn] = addr = balloc(ip->dev);\n    return addr;\n  }\n  bn -= NDIRECT;\n\n  if(bn < NINDIRECT){\n    // Load indirect block, allocating if necessary.\n    if((addr = ip->addrs[NDIRECT]) == 0)\n      ip->addrs[NDIRECT] = addr = balloc(ip->dev);\n    bp = bread(ip->dev, addr);\n    a = (uint*)bp->data;\n    if((addr = a[bn]) == 0){\n      a[bn] = addr = balloc(ip->dev);\n      log_write(bp);\n    }\n    brelse(bp);\n    return addr;\n  }\n  bn -= NINDIRECT;\n  if (bn < NDBDIRECT) {\n    if ((addr = ip->addrs[NDIRECT + 1]) == 0)\n      ip->addrs[NDIRECT + 1] = addr = balloc(ip->dev);\n    bp = bread(ip->dev, addr);\n    a = (uint*)bp->data;\n    if ((addr = a[bn / NINDIRECT]) == 0) {\n      a[bn / NINDIRECT] = addr = balloc(ip->dev);\n      log_write(bp);\n    }\n    brelse(bp);\n    bp = bread(ip->dev, addr);\n    a = (uint*)bp->data;\n    if ((addr = a[bn % NINDIRECT]) == 0) {\n      a[bn % NINDIRECT] = addr = balloc(ip->dev);\n      log_write(bp);\n    }\n    brelse(bp);\n    return addr;\n  }\n  panic(\"bmap: out of range\");\n}\n```\n\n> 修改itrunc使得能够释放double indirect的块。\n\n```c\n\nvoid\nitrunc(struct inode *ip)\n{\n  int i, j;\n  struct buf *bp;\n  uint *a;\n\n  for(i = 0; i < NDIRECT; i++){\n    if(ip->addrs[i]){\n      bfree(ip->dev, ip->addrs[i]);\n      ip->addrs[i] = 0;\n    }\n  }\n\n  if(ip->addrs[NDIRECT]){\n    bp = bread(ip->dev, ip->addrs[NDIRECT]);\n    a = (uint*)bp->data;\n    for(j = 0; j < NINDIRECT; j++){\n      if(a[j])\n        bfree(ip->dev, a[j]);\n    }\n    brelse(bp);\n    bfree(ip->dev, ip->addrs[NDIRECT]);\n    ip->addrs[NDIRECT] = 0;\n  }\n  if (ip->addrs[NDIRECT + 1]) {\n    bp = bread(ip->dev, ip->addrs[NDIRECT + 1]);\n    a = (uint*)bp->data;\n    for(j = 0; j < NINDIRECT; j++) {\n      if (a[j]) {\n        uint addr, *data;\n        struct buf *bbp;\n        addr = a[j];\n        bbp = bread(ip->dev, addr);\n        data = (uint*)bbp->data;\n        for (int k = 0; k < NINDIRECT; k++) {\n          if (data[k])\n            bfree(ip->dev, data[k]);\n        }\n        brelse(bbp);\n        bfree(ip->dev, addr);\n      }\n    }\n    brelse(bp);\n    bfree(ip->dev, ip->addrs[NDIRECT + 1]);\n    ip->addrs[NDIRECT + 1] = 0;\n  }\n  ip->size = 0;\n  iupdate(ip);\n}\n```\n\n## Symbolic links\n\n硬链接就是几个不同的direntry拥有相同的inum。软链接是一个特殊的文件，文件内容是一个路径指向所链接的文件。\n\nxv6实现了硬链接，这个lab要求实现软链接。\n\n> 首先实现系统调用symlink来创建一个软链接文件。\n\n```c\nuint64\nsys_symlink(void) {\n  char target[MAXPATH], path[MAXPATH];\n  struct inode *ip;\n  if (argstr(0, target, MAXPATH) < 0 || argstr(1, path, MAXPATH) < 0) {\n    return -1;\n  }\n  begin_op();\n\n  if ((ip = create(path, T_SYMLINK, 0, 0)) == 0) {\n    end_op();\n    return -1;\n  }\n  writei(ip, 0, (uint64)target, 0, MAXPATH);\n  iunlockput(ip);\n  end_op();\n\n  return 0;\n}\n```\n\n> 修改系统调用open用来打开软链接文件。如果O_NOFOLLOW则直接返回这个软链接的inode。\n>\n> 否则返回它指向的文件的inode，如果指向的文件也是一个软链接，继续打开软链接指向的文件直到指向一个inode或形成环。\n>\n> 这里需要注意iunlock和iput的区别。iget/iput用于增加/减少ip的ref，用于表示inode cache中这个inode有多少个指针正在指向它，如果没有一个进程指向这个inode，则可以从cache中释放。\n>\n> ilock/iunlock用于给inode加锁保证线程同步。\n>\n> 一般的调用操作顺序是iget->ilock->iunlock->iput.在open系统调用中，如果成功找到一个ip，返回时只需要到iunlock即可，不需要iput，因为open文件表示这个进程正在使用这个inode。直到close才能iput。\n>\n> 另外注意有的函数中间会执行iget/ilock，例如namei成功调用时返回的ip是已经经过iget操作的。\n>\n> 任何不需要的inode（open操作失败，或者递归打开软链接）都应该iunlockput。\n\n```c\nuint64\nsys_open(void)\n{\n  char path[MAXPATH];\n  int fd, omode;\n  struct file *f;\n  struct inode *ip;\n  int n;\n\n  if((n = argstr(0, path, MAXPATH)) < 0 || argint(1, &omode) < 0)\n    return -1;\n\n  begin_op();\n\n  if(omode & O_CREATE){\n    ip = create(path, T_FILE, 0, 0);\n    if(ip == 0){\n      end_op();\n      return -1;\n    }\n  } else {\n    if((ip = namei(path)) == 0){\n      end_op();\n      return -1;\n    }\n    ilock(ip);\n    if(ip->type == T_DIR && omode != O_RDONLY){\n      iunlockput(ip);\n      end_op();\n      return -1;\n    }\n  }\n\n  if(ip->type == T_DEVICE && (ip->major < 0 || ip->major >= NDEV)){\n    iunlockput(ip);\n    end_op();\n    return -1;\n  }\n  int depth = 0;\n  if (ip->type == T_SYMLINK && !(omode&O_NOFOLLOW)) {\n    while (ip->type == T_SYMLINK && depth < 10) {\n      readi(ip, 0, (uint64)path, 0, MAXPATH);\n      iunlockput(ip);\n      if ((ip = namei(path)) == 0) {\n        end_op();\n        return -1;\n      }\n      ilock(ip);\n      depth++;\n    }\n    if (depth == 10) {\n      iunlockput(ip);\n      end_op();\n      return -1;\n    }\n  }\n  if((f = filealloc()) == 0 || (fd = fdalloc(f)) < 0){\n    if(f)\n      fileclose(f);\n    iunlockput(ip);\n    end_op();\n    return -1;\n  } \n  \n\n  if(ip->type == T_DEVICE){\n    f->type = FD_DEVICE;\n    f->major = ip->major;\n  } else {\n    f->type = FD_INODE;\n    f->off = 0;\n  }\n  f->ip = ip;\n  f->readable = !(omode & O_WRONLY);\n  f->writable = (omode & O_WRONLY) || (omode & O_RDWR);\n\n  if((omode & O_TRUNC) && ip->type == T_FILE){\n    itrunc(ip);\n  }\n\n  iunlock(ip);\n  end_op();\n\n  return fd;\n}\n```\n\n## 结果\n\n![](/images/1.png)\n","slug":"MIT6.S081 Lab9","published":1,"updated":"2021-11-05T05:45:01.695Z","_id":"ckvlyb07f000a04v6a0ljck3g","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"Large-files\"><a href=\"#Large-files\" class=\"headerlink\" title=\"Large files\"></a>Large files</h2><p>这个实验要求扩展xv6文件大小，从268个block（12direct * 1+1single indirect * 256）扩展到65803个block（11derect * 1+1single indirect * 256+1double indirect * 256 * 256）。</p>\n<p>需要看懂bmap函数的作用，bmap接收一个inode和逻辑块号bn，通过寻址把bn映射为物理块号返回。</p>\n<blockquote>\n<p>inode的addrs大小不变仍为13，direct缩小为11，最后一位改为double indirect，dinode同理。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> uint</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">bmap</span><span class=\"params\">(struct inode *ip, uint bn)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  uint addr, *a;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">buf</span> *<span class=\"title\">bp</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(bn &lt; NDIRECT)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((addr = ip-&gt;addrs[bn]) == <span class=\"number\">0</span>)</span><br><span class=\"line\">      ip-&gt;addrs[bn] = addr = balloc(ip-&gt;dev);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> addr;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  bn -= NDIRECT;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(bn &lt; NINDIRECT)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Load indirect block, allocating if necessary.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>((addr = ip-&gt;addrs[NDIRECT]) == <span class=\"number\">0</span>)</span><br><span class=\"line\">      ip-&gt;addrs[NDIRECT] = addr = balloc(ip-&gt;dev);</span><br><span class=\"line\">    bp = bread(ip-&gt;dev, addr);</span><br><span class=\"line\">    a = (uint*)bp-&gt;data;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((addr = a[bn]) == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">      a[bn] = addr = balloc(ip-&gt;dev);</span><br><span class=\"line\">      log_write(bp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    brelse(bp);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> addr;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  bn -= NINDIRECT;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (bn &lt; NDBDIRECT) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((addr = ip-&gt;addrs[NDIRECT + <span class=\"number\">1</span>]) == <span class=\"number\">0</span>)</span><br><span class=\"line\">      ip-&gt;addrs[NDIRECT + <span class=\"number\">1</span>] = addr = balloc(ip-&gt;dev);</span><br><span class=\"line\">    bp = bread(ip-&gt;dev, addr);</span><br><span class=\"line\">    a = (uint*)bp-&gt;data;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((addr = a[bn / NINDIRECT]) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      a[bn / NINDIRECT] = addr = balloc(ip-&gt;dev);</span><br><span class=\"line\">      log_write(bp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    brelse(bp);</span><br><span class=\"line\">    bp = bread(ip-&gt;dev, addr);</span><br><span class=\"line\">    a = (uint*)bp-&gt;data;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((addr = a[bn % NINDIRECT]) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      a[bn % NINDIRECT] = addr = balloc(ip-&gt;dev);</span><br><span class=\"line\">      log_write(bp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    brelse(bp);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> addr;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  panic(<span class=\"string\">&quot;bmap: out of range&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>修改itrunc使得能够释放double indirect的块。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">itrunc</span><span class=\"params\">(struct inode *ip)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i, j;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">buf</span> *<span class=\"title\">bp</span>;</span></span><br><span class=\"line\">  uint *a;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; NDIRECT; i++)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(ip-&gt;addrs[i])&#123;</span><br><span class=\"line\">      bfree(ip-&gt;dev, ip-&gt;addrs[i]);</span><br><span class=\"line\">      ip-&gt;addrs[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(ip-&gt;addrs[NDIRECT])&#123;</span><br><span class=\"line\">    bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);</span><br><span class=\"line\">    a = (uint*)bp-&gt;data;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(j = <span class=\"number\">0</span>; j &lt; NINDIRECT; j++)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(a[j])</span><br><span class=\"line\">        bfree(ip-&gt;dev, a[j]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    brelse(bp);</span><br><span class=\"line\">    bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);</span><br><span class=\"line\">    ip-&gt;addrs[NDIRECT] = <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ip-&gt;addrs[NDIRECT + <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">    bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT + <span class=\"number\">1</span>]);</span><br><span class=\"line\">    a = (uint*)bp-&gt;data;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(j = <span class=\"number\">0</span>; j &lt; NINDIRECT; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (a[j]) &#123;</span><br><span class=\"line\">        uint addr, *data;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">buf</span> *<span class=\"title\">bbp</span>;</span></span><br><span class=\"line\">        addr = a[j];</span><br><span class=\"line\">        bbp = bread(ip-&gt;dev, addr);</span><br><span class=\"line\">        data = (uint*)bbp-&gt;data;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; NINDIRECT; k++) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (data[k])</span><br><span class=\"line\">            bfree(ip-&gt;dev, data[k]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        brelse(bbp);</span><br><span class=\"line\">        bfree(ip-&gt;dev, addr);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    brelse(bp);</span><br><span class=\"line\">    bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT + <span class=\"number\">1</span>]);</span><br><span class=\"line\">    ip-&gt;addrs[NDIRECT + <span class=\"number\">1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ip-&gt;size = <span class=\"number\">0</span>;</span><br><span class=\"line\">  iupdate(ip);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Symbolic-links\"><a href=\"#Symbolic-links\" class=\"headerlink\" title=\"Symbolic links\"></a>Symbolic links</h2><p>硬链接就是几个不同的direntry拥有相同的inum。软链接是一个特殊的文件，文件内容是一个路径指向所链接的文件。</p>\n<p>xv6实现了硬链接，这个lab要求实现软链接。</p>\n<blockquote>\n<p>首先实现系统调用symlink来创建一个软链接文件。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">uint64</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">sys_symlink</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">char</span> target[MAXPATH], path[MAXPATH];</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">inode</span> *<span class=\"title\">ip</span>;</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (argstr(<span class=\"number\">0</span>, target, MAXPATH) &lt; <span class=\"number\">0</span> || argstr(<span class=\"number\">1</span>, path, MAXPATH) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  begin_op();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((ip = create(path, T_SYMLINK, <span class=\"number\">0</span>, <span class=\"number\">0</span>)) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    end_op();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  writei(ip, <span class=\"number\">0</span>, (uint64)target, <span class=\"number\">0</span>, MAXPATH);</span><br><span class=\"line\">  iunlockput(ip);</span><br><span class=\"line\">  end_op();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>修改系统调用open用来打开软链接文件。如果O_NOFOLLOW则直接返回这个软链接的inode。</p>\n<p>否则返回它指向的文件的inode，如果指向的文件也是一个软链接，继续打开软链接指向的文件直到指向一个inode或形成环。</p>\n<p>这里需要注意iunlock和iput的区别。iget/iput用于增加/减少ip的ref，用于表示inode cache中这个inode有多少个指针正在指向它，如果没有一个进程指向这个inode，则可以从cache中释放。</p>\n<p>ilock/iunlock用于给inode加锁保证线程同步。</p>\n<p>一般的调用操作顺序是iget-&gt;ilock-&gt;iunlock-&gt;iput.在open系统调用中，如果成功找到一个ip，返回时只需要到iunlock即可，不需要iput，因为open文件表示这个进程正在使用这个inode。直到close才能iput。</p>\n<p>另外注意有的函数中间会执行iget/ilock，例如namei成功调用时返回的ip是已经经过iget操作的。</p>\n<p>任何不需要的inode（open操作失败，或者递归打开软链接）都应该iunlockput。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">uint64</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">sys_open</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">char</span> path[MAXPATH];</span><br><span class=\"line\">  <span class=\"keyword\">int</span> fd, omode;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">file</span> *<span class=\"title\">f</span>;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">inode</span> *<span class=\"title\">ip</span>;</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> n;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>((n = argstr(<span class=\"number\">0</span>, path, MAXPATH)) &lt; <span class=\"number\">0</span> || argint(<span class=\"number\">1</span>, &amp;omode) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  begin_op();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(omode &amp; O_CREATE)&#123;</span><br><span class=\"line\">    ip = create(path, T_FILE, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(ip == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">      end_op();</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((ip = namei(path)) == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">      end_op();</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ilock(ip);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(ip-&gt;type == T_DIR &amp;&amp; omode != O_RDONLY)&#123;</span><br><span class=\"line\">      iunlockput(ip);</span><br><span class=\"line\">      end_op();</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(ip-&gt;type == T_DEVICE &amp;&amp; (ip-&gt;major &lt; <span class=\"number\">0</span> || ip-&gt;major &gt;= NDEV))&#123;</span><br><span class=\"line\">    iunlockput(ip);</span><br><span class=\"line\">    end_op();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> depth = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ip-&gt;type == T_SYMLINK &amp;&amp; !(omode&amp;O_NOFOLLOW)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (ip-&gt;type == T_SYMLINK &amp;&amp; depth &lt; <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">      readi(ip, <span class=\"number\">0</span>, (uint64)path, <span class=\"number\">0</span>, MAXPATH);</span><br><span class=\"line\">      iunlockput(ip);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> ((ip = namei(path)) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        end_op();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      ilock(ip);</span><br><span class=\"line\">      depth++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (depth == <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">      iunlockput(ip);</span><br><span class=\"line\">      end_op();</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>((f = filealloc()) == <span class=\"number\">0</span> || (fd = fdalloc(f)) &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(f)</span><br><span class=\"line\">      fileclose(f);</span><br><span class=\"line\">    iunlockput(ip);</span><br><span class=\"line\">    end_op();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(ip-&gt;type == T_DEVICE)&#123;</span><br><span class=\"line\">    f-&gt;type = FD_DEVICE;</span><br><span class=\"line\">    f-&gt;major = ip-&gt;major;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    f-&gt;type = FD_INODE;</span><br><span class=\"line\">    f-&gt;off = <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  f-&gt;ip = ip;</span><br><span class=\"line\">  f-&gt;readable = !(omode &amp; O_WRONLY);</span><br><span class=\"line\">  f-&gt;writable = (omode &amp; O_WRONLY) || (omode &amp; O_RDWR);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>((omode &amp; O_TRUNC) &amp;&amp; ip-&gt;type == T_FILE)&#123;</span><br><span class=\"line\">    itrunc(ip);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  iunlock(ip);</span><br><span class=\"line\">  end_op();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> fd;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"结果\"><a href=\"#结果\" class=\"headerlink\" title=\"结果\"></a>结果</h2><p><img src=\"/images/1.png\"></p>\n","site":{"data":{"styles":"body {\n  background: url(\"/images/bg.jpg\");\n  background-repeat: no-repeat;\n  background-size: cover;\n  background-attachment: fixed;\n  background-position: 50% 50%;\n}\n.content-wrap {\n  opacity: 0.9;\n}\n.sidebar {\n  opacity: 0.9;\n}\n.header-inner {\n  background: rgba(255,255,255,0.85);\n}\n.popup {\n  opacity: 0.85;\n}\n.sidebar {\n  background-color: transparent;\n}\n","variables":""}},"excerpt":"","more":"<h2 id=\"Large-files\"><a href=\"#Large-files\" class=\"headerlink\" title=\"Large files\"></a>Large files</h2><p>这个实验要求扩展xv6文件大小，从268个block（12direct * 1+1single indirect * 256）扩展到65803个block（11derect * 1+1single indirect * 256+1double indirect * 256 * 256）。</p>\n<p>需要看懂bmap函数的作用，bmap接收一个inode和逻辑块号bn，通过寻址把bn映射为物理块号返回。</p>\n<blockquote>\n<p>inode的addrs大小不变仍为13，direct缩小为11，最后一位改为double indirect，dinode同理。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> uint</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">bmap</span><span class=\"params\">(struct inode *ip, uint bn)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  uint addr, *a;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">buf</span> *<span class=\"title\">bp</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(bn &lt; NDIRECT)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((addr = ip-&gt;addrs[bn]) == <span class=\"number\">0</span>)</span><br><span class=\"line\">      ip-&gt;addrs[bn] = addr = balloc(ip-&gt;dev);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> addr;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  bn -= NDIRECT;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(bn &lt; NINDIRECT)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Load indirect block, allocating if necessary.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>((addr = ip-&gt;addrs[NDIRECT]) == <span class=\"number\">0</span>)</span><br><span class=\"line\">      ip-&gt;addrs[NDIRECT] = addr = balloc(ip-&gt;dev);</span><br><span class=\"line\">    bp = bread(ip-&gt;dev, addr);</span><br><span class=\"line\">    a = (uint*)bp-&gt;data;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((addr = a[bn]) == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">      a[bn] = addr = balloc(ip-&gt;dev);</span><br><span class=\"line\">      log_write(bp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    brelse(bp);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> addr;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  bn -= NINDIRECT;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (bn &lt; NDBDIRECT) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((addr = ip-&gt;addrs[NDIRECT + <span class=\"number\">1</span>]) == <span class=\"number\">0</span>)</span><br><span class=\"line\">      ip-&gt;addrs[NDIRECT + <span class=\"number\">1</span>] = addr = balloc(ip-&gt;dev);</span><br><span class=\"line\">    bp = bread(ip-&gt;dev, addr);</span><br><span class=\"line\">    a = (uint*)bp-&gt;data;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((addr = a[bn / NINDIRECT]) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      a[bn / NINDIRECT] = addr = balloc(ip-&gt;dev);</span><br><span class=\"line\">      log_write(bp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    brelse(bp);</span><br><span class=\"line\">    bp = bread(ip-&gt;dev, addr);</span><br><span class=\"line\">    a = (uint*)bp-&gt;data;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((addr = a[bn % NINDIRECT]) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">      a[bn % NINDIRECT] = addr = balloc(ip-&gt;dev);</span><br><span class=\"line\">      log_write(bp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    brelse(bp);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> addr;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  panic(<span class=\"string\">&quot;bmap: out of range&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>修改itrunc使得能够释放double indirect的块。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">itrunc</span><span class=\"params\">(struct inode *ip)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i, j;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">buf</span> *<span class=\"title\">bp</span>;</span></span><br><span class=\"line\">  uint *a;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; NDIRECT; i++)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(ip-&gt;addrs[i])&#123;</span><br><span class=\"line\">      bfree(ip-&gt;dev, ip-&gt;addrs[i]);</span><br><span class=\"line\">      ip-&gt;addrs[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(ip-&gt;addrs[NDIRECT])&#123;</span><br><span class=\"line\">    bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);</span><br><span class=\"line\">    a = (uint*)bp-&gt;data;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(j = <span class=\"number\">0</span>; j &lt; NINDIRECT; j++)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(a[j])</span><br><span class=\"line\">        bfree(ip-&gt;dev, a[j]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    brelse(bp);</span><br><span class=\"line\">    bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);</span><br><span class=\"line\">    ip-&gt;addrs[NDIRECT] = <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ip-&gt;addrs[NDIRECT + <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">    bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT + <span class=\"number\">1</span>]);</span><br><span class=\"line\">    a = (uint*)bp-&gt;data;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(j = <span class=\"number\">0</span>; j &lt; NINDIRECT; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (a[j]) &#123;</span><br><span class=\"line\">        uint addr, *data;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">buf</span> *<span class=\"title\">bbp</span>;</span></span><br><span class=\"line\">        addr = a[j];</span><br><span class=\"line\">        bbp = bread(ip-&gt;dev, addr);</span><br><span class=\"line\">        data = (uint*)bbp-&gt;data;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; NINDIRECT; k++) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (data[k])</span><br><span class=\"line\">            bfree(ip-&gt;dev, data[k]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        brelse(bbp);</span><br><span class=\"line\">        bfree(ip-&gt;dev, addr);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    brelse(bp);</span><br><span class=\"line\">    bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT + <span class=\"number\">1</span>]);</span><br><span class=\"line\">    ip-&gt;addrs[NDIRECT + <span class=\"number\">1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  ip-&gt;size = <span class=\"number\">0</span>;</span><br><span class=\"line\">  iupdate(ip);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Symbolic-links\"><a href=\"#Symbolic-links\" class=\"headerlink\" title=\"Symbolic links\"></a>Symbolic links</h2><p>硬链接就是几个不同的direntry拥有相同的inum。软链接是一个特殊的文件，文件内容是一个路径指向所链接的文件。</p>\n<p>xv6实现了硬链接，这个lab要求实现软链接。</p>\n<blockquote>\n<p>首先实现系统调用symlink来创建一个软链接文件。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">uint64</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">sys_symlink</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">char</span> target[MAXPATH], path[MAXPATH];</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">inode</span> *<span class=\"title\">ip</span>;</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (argstr(<span class=\"number\">0</span>, target, MAXPATH) &lt; <span class=\"number\">0</span> || argstr(<span class=\"number\">1</span>, path, MAXPATH) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  begin_op();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((ip = create(path, T_SYMLINK, <span class=\"number\">0</span>, <span class=\"number\">0</span>)) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    end_op();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  writei(ip, <span class=\"number\">0</span>, (uint64)target, <span class=\"number\">0</span>, MAXPATH);</span><br><span class=\"line\">  iunlockput(ip);</span><br><span class=\"line\">  end_op();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>修改系统调用open用来打开软链接文件。如果O_NOFOLLOW则直接返回这个软链接的inode。</p>\n<p>否则返回它指向的文件的inode，如果指向的文件也是一个软链接，继续打开软链接指向的文件直到指向一个inode或形成环。</p>\n<p>这里需要注意iunlock和iput的区别。iget/iput用于增加/减少ip的ref，用于表示inode cache中这个inode有多少个指针正在指向它，如果没有一个进程指向这个inode，则可以从cache中释放。</p>\n<p>ilock/iunlock用于给inode加锁保证线程同步。</p>\n<p>一般的调用操作顺序是iget-&gt;ilock-&gt;iunlock-&gt;iput.在open系统调用中，如果成功找到一个ip，返回时只需要到iunlock即可，不需要iput，因为open文件表示这个进程正在使用这个inode。直到close才能iput。</p>\n<p>另外注意有的函数中间会执行iget/ilock，例如namei成功调用时返回的ip是已经经过iget操作的。</p>\n<p>任何不需要的inode（open操作失败，或者递归打开软链接）都应该iunlockput。</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">uint64</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">sys_open</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">char</span> path[MAXPATH];</span><br><span class=\"line\">  <span class=\"keyword\">int</span> fd, omode;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">file</span> *<span class=\"title\">f</span>;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">inode</span> *<span class=\"title\">ip</span>;</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> n;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>((n = argstr(<span class=\"number\">0</span>, path, MAXPATH)) &lt; <span class=\"number\">0</span> || argint(<span class=\"number\">1</span>, &amp;omode) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  begin_op();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(omode &amp; O_CREATE)&#123;</span><br><span class=\"line\">    ip = create(path, T_FILE, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(ip == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">      end_op();</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((ip = namei(path)) == <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">      end_op();</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ilock(ip);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(ip-&gt;type == T_DIR &amp;&amp; omode != O_RDONLY)&#123;</span><br><span class=\"line\">      iunlockput(ip);</span><br><span class=\"line\">      end_op();</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(ip-&gt;type == T_DEVICE &amp;&amp; (ip-&gt;major &lt; <span class=\"number\">0</span> || ip-&gt;major &gt;= NDEV))&#123;</span><br><span class=\"line\">    iunlockput(ip);</span><br><span class=\"line\">    end_op();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> depth = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ip-&gt;type == T_SYMLINK &amp;&amp; !(omode&amp;O_NOFOLLOW)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (ip-&gt;type == T_SYMLINK &amp;&amp; depth &lt; <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">      readi(ip, <span class=\"number\">0</span>, (uint64)path, <span class=\"number\">0</span>, MAXPATH);</span><br><span class=\"line\">      iunlockput(ip);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> ((ip = namei(path)) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        end_op();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      ilock(ip);</span><br><span class=\"line\">      depth++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (depth == <span class=\"number\">10</span>) &#123;</span><br><span class=\"line\">      iunlockput(ip);</span><br><span class=\"line\">      end_op();</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>((f = filealloc()) == <span class=\"number\">0</span> || (fd = fdalloc(f)) &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(f)</span><br><span class=\"line\">      fileclose(f);</span><br><span class=\"line\">    iunlockput(ip);</span><br><span class=\"line\">    end_op();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(ip-&gt;type == T_DEVICE)&#123;</span><br><span class=\"line\">    f-&gt;type = FD_DEVICE;</span><br><span class=\"line\">    f-&gt;major = ip-&gt;major;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    f-&gt;type = FD_INODE;</span><br><span class=\"line\">    f-&gt;off = <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  f-&gt;ip = ip;</span><br><span class=\"line\">  f-&gt;readable = !(omode &amp; O_WRONLY);</span><br><span class=\"line\">  f-&gt;writable = (omode &amp; O_WRONLY) || (omode &amp; O_RDWR);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>((omode &amp; O_TRUNC) &amp;&amp; ip-&gt;type == T_FILE)&#123;</span><br><span class=\"line\">    itrunc(ip);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  iunlock(ip);</span><br><span class=\"line\">  end_op();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> fd;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"结果\"><a href=\"#结果\" class=\"headerlink\" title=\"结果\"></a>结果</h2><p><img src=\"/images/1.png\"></p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ckvlyb07c000404v6hrs81azk","tag_id":"ckvlyb07a000204v68j0j3ley","_id":"ckvlyb07e000704v6gnp2hk2p"},{"post_id":"ckvlyb075000004v671br5m5j","tag_id":"ckvlyb07a000204v68j0j3ley","_id":"ckvlyb07f000904v6h2t95t43"},{"post_id":"ckvlyb07c000504v63jyt3ysm","tag_id":"ckvlyb07a000204v68j0j3ley","_id":"ckvlyb07g000c04v65jfl5i4q"},{"post_id":"ckvlyb07e000804v68j6jh9cg","tag_id":"ckvlyb07a000204v68j0j3ley","_id":"ckvlyb07g000d04v63emc8fa3"},{"post_id":"ckvlyb079000104v6cqgvb9hp","tag_id":"ckvlyb07a000204v68j0j3ley","_id":"ckvlyb07g000e04v62ttt21bo"},{"post_id":"ckvlyb07f000a04v6a0ljck3g","tag_id":"ckvlyb07a000204v68j0j3ley","_id":"ckvlyb07g000f04v6eobwh7gu"},{"post_id":"ckvlyb07b000304v68u19hmg9","tag_id":"ckvlyb07a000204v68j0j3ley","_id":"ckvlyb07g000g04v6bjj837vz"}],"Tag":[{"name":"6.S081","_id":"ckvlyb07a000204v68j0j3ley"}]}}