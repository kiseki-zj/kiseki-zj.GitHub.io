<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"kiseki-zj.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="&quot;开心就好啦&quot;">
<meta property="og:type" content="website">
<meta property="og:title" content="KISEKI">
<meta property="og:url" content="https://kiseki-zj.github.io/index.html">
<meta property="og:site_name" content="KISEKI">
<meta property="og:description" content="&quot;开心就好啦&quot;">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Kiseki">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://kiseki-zj.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>KISEKI</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">KISEKI</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kiseki-zj.github.io/2021/12/15/cs144/cs144/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="Kiseki">
      <meta itemprop="description" content=""开心就好啦"">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KISEKI">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/15/cs144/cs144/" class="post-title-link" itemprop="url">CS144：用户态TCP协议栈</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-12-15 12:00:00 / 修改时间：14:58:10" itemprop="dateCreated datePublished" datetime="2021-12-15T12:00:00+08:00">2021-12-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a target="_blank" rel="noopener" href="https://cs144.github.io/">CS144: Introduction to Computer Networking</a>是斯坦福的计算机网络课，本文完成了Lab0~4，实现了一个用户态的TCP用户栈。我是做完MIT的操作系统lab6.s081（<a href="https://kiseki-zj.github.io/2021/04/03/MIT6.S081%20Lab3/">lab笔记</a>)开的这个坑，感觉cs144要比6.s081稍微难一点，做之前建议先熟悉一下c++。</p>
<h2 id="Lab-0"><a href="#Lab-0" class="headerlink" title="Lab 0"></a>Lab 0</h2><h3 id="Writing-webget"><a href="#Writing-webget" class="headerlink" title="Writing webget"></a>Writing webget</h3><p>代码提供了操作系统socket的封装TCPSocket，实验要求使用这个类向指定IP发送HTTP请求并获取对应的资源。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_URL</span><span class="params">(<span class="keyword">const</span> string &amp;host, <span class="keyword">const</span> string &amp;path)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Your code here.</span></span><br><span class="line">    <span class="comment">//CS144TCPSocket fd&#123;&#125;;</span></span><br><span class="line">    TCPSocket fd;</span><br><span class="line">    <span class="function">Address <span class="title">addr</span><span class="params">(host, <span class="string">&quot;http&quot;</span>)</span></span>;</span><br><span class="line">    fd.<span class="built_in">connect</span>(addr);</span><br><span class="line">    string str = <span class="string">&quot;GET &quot;</span> + path + <span class="string">&quot; HTTP/2.1\r\nHost: &quot;</span> + host + <span class="string">&quot;\r\nConnection: close\r\n\r\n&quot;</span>;</span><br><span class="line">    fd.<span class="built_in">write</span>(str);</span><br><span class="line">    fd.<span class="built_in">shutdown</span>(SHUT_WR);</span><br><span class="line">    <span class="keyword">while</span> (!fd.<span class="built_in">eof</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; fd.<span class="built_in">read</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//fd.wait_until_closed();</span></span><br><span class="line">    fd.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// You will need to connect to the &quot;http&quot; service on</span></span><br><span class="line">    <span class="comment">// the computer whose name is in the &quot;host&quot; string,</span></span><br><span class="line">    <span class="comment">// then request the URL path given in the &quot;path&quot; string.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Then you&#x27;ll need to print out everything the server sends back,</span></span><br><span class="line">    <span class="comment">// (not just one call to read() -- everything) until you reach</span></span><br><span class="line">    <span class="comment">// the &quot;eof&quot; (end of file).</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="An-in-memory-reliable-byte-stream"><a href="#An-in-memory-reliable-byte-stream" class="headerlink" title="An in-memory reliable byte stream"></a>An in-memory reliable byte stream</h3><p>TCP连接双方本质上是对一个有序字节流（in-order byte stream）进行读写，类似一个队列。对于TCP的某一方，接收器从队列的一头读，对方的发送器从另一头写。并且要求这个队列是带容量的，队列满了之后写端不能再写。</p>
<blockquote>
<p>byte_stream.hh</p>
<p>用deque实现有序字节流，endinput标志字节流写端是否写完（EOF）。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ByteStream</span> &#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Your code here -- add private members as necessary.</span></span><br><span class="line">    std::deque&lt;<span class="keyword">char</span>&gt; buffer;</span><br><span class="line">    <span class="keyword">size_t</span> cap;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">    <span class="keyword">size_t</span> totwr;</span><br><span class="line">    <span class="keyword">size_t</span> totrd;</span><br><span class="line">    <span class="keyword">bool</span> endinput;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>byte_stream.cc</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">ByteStream::<span class="built_in">ByteStream</span>(<span class="keyword">const</span> <span class="keyword">size_t</span> capacity) : </span><br><span class="line">    <span class="built_in">buffer</span>(),</span><br><span class="line">    <span class="built_in">cap</span>(capacity),</span><br><span class="line">    <span class="built_in">size</span>(<span class="number">0</span>),</span><br><span class="line">    <span class="built_in">totwr</span>(<span class="number">0</span>),</span><br><span class="line">    <span class="built_in">totrd</span>(<span class="number">0</span>),</span><br><span class="line">    <span class="built_in">endinput</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">ByteStream::write</span><span class="params">(<span class="keyword">const</span> string &amp;data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> wrs = <span class="built_in">min</span>(<span class="built_in">remaining_capacity</span>(), data.<span class="built_in">length</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; wrs; ++i) &#123;</span><br><span class="line">        buffer.<span class="built_in">push_back</span>(data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    size += wrs;</span><br><span class="line">    totwr += wrs;</span><br><span class="line">    <span class="keyword">return</span> &#123;wrs&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param[in] len bytes will be copied from the output side of the buffer</span></span><br><span class="line"><span class="function">string <span class="title">ByteStream::peek_output</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> len)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    string res&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">        res += buffer.<span class="built_in">at</span>(i);</span><br><span class="line">    <span class="keyword">return</span> &#123;res&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param[in] len bytes will be removed from the output side of the buffer</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ByteStream::pop_output</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> len)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">        buffer.<span class="built_in">pop_front</span>();</span><br><span class="line">    size -= len;</span><br><span class="line">    totrd += len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! Read (i.e., copy and then pop) the next &quot;len&quot; bytes of the stream</span></span><br><span class="line"><span class="comment">//! \param[in] len bytes will be popped and returned</span></span><br><span class="line"><span class="comment">//! \returns a string</span></span><br><span class="line"><span class="function">std::string <span class="title">ByteStream::read</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    string res&#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">buffer_empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> l = <span class="built_in">min</span>(len, size);</span><br><span class="line">        res += <span class="built_in">peek_output</span>(l);</span><br><span class="line">        <span class="built_in">pop_output</span>(l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;res&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Lab-1"><a href="#Lab-1" class="headerlink" title="Lab 1"></a>Lab 1</h2><p>TCP协议对传输的每一个字节编址来保证有序传输，但是因为接收器收到的字节流碎片可能有重复，缺失，重叠等，所以这个lab要求实现一个流重组器（stream reassembler）保证写入bytestream的数据有序。</p>
<blockquote>
<p>stream_reassembler.hh</p>
<p>_substr结构体表示字节流碎片，assembler是一个set用于保存收到的字节流碎片。</p>
<p>merge_substr()用于把处理过的字节流碎片加入到set中。执行完后set里保存的是按index排序的一段一段的子碎片。</p>
<p>push_substring()收到字节流碎片，然后执行merge_substr()，然后看set中第一段能否write到bytestream里。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StreamReassembler</span> &#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Your code here -- add private members as necessary.</span></span><br><span class="line"></span><br><span class="line">    ByteStream _output;  <span class="comment">//!&lt; The reassembled in-order byte stream</span></span><br><span class="line">    <span class="keyword">size_t</span> _capacity;    <span class="comment">//!&lt; The maximum number of bytes</span></span><br><span class="line">    <span class="keyword">size_t</span> _nAssembled;   <span class="comment">//first unassembled = _nAsssembled</span></span><br><span class="line">    <span class="keyword">size_t</span> _nUnassembled;  <span class="comment">//size of set</span></span><br><span class="line">    <span class="keyword">bool</span> _eof;  <span class="comment">//判断eof段有无全部写入set</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">substr</span>&#123;</span></span><br><span class="line">      <span class="keyword">size_t</span> index;</span><br><span class="line">      std::string data;</span><br><span class="line">      <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> _substr&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> index &lt; rhs.index;</span><br><span class="line">      &#125;</span><br><span class="line">      _substr(<span class="keyword">size_t</span> _index, std::string&amp; _data):<span class="built_in">index</span>(_index), <span class="built_in">data</span>(_data) &#123;&#125;</span><br><span class="line">      _substr(<span class="keyword">size_t</span> _index, <span class="keyword">const</span> std::string&amp; _data):<span class="built_in">index</span>(_index), <span class="built_in">data</span>(_data) &#123;&#125;</span><br><span class="line">    &#125;<span class="keyword">substr_t</span>;</span><br><span class="line">    std::set&lt;<span class="keyword">substr_t</span>&gt; assembler&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge_substr</span><span class="params">(<span class="keyword">size_t</span> index, std::string&amp; data)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>stream_reassembler.cc</p>
<p>merge_substr考虑了好多种情况，比较冗长，懒得重构了。。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StreamReassembler::push_substring</span><span class="params">(<span class="keyword">const</span> string &amp;data, <span class="keyword">const</span> <span class="keyword">size_t</span> index, <span class="keyword">const</span> <span class="keyword">bool</span> eof)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//data非法，直接return的情况</span></span><br><span class="line">    <span class="keyword">if</span> (index + data.<span class="built_in">size</span>() &lt;= _nAssembled) &#123;</span><br><span class="line">        <span class="keyword">if</span> (eof) _output.<span class="built_in">end_input</span>();</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= _nAssembled - _output.<span class="built_in">buffer_size</span>() + _capacity) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (data.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (eof) _output.<span class="built_in">end_input</span>();</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//data合法，取可用区间</span></span><br><span class="line">    <span class="keyword">size_t</span> _firstIndex = _nAssembled - _output.<span class="built_in">buffer_size</span>();</span><br><span class="line">    <span class="keyword">size_t</span> resIndex = index;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; _nAssembled) &#123;</span><br><span class="line">        resIndex = _nAssembled;</span><br><span class="line">    &#125;</span><br><span class="line">    string resData = data.<span class="built_in">substr</span>(resIndex - index, _firstIndex + _capacity - resIndex);<span class="comment">//substr长度自动截断</span></span><br><span class="line">    <span class="keyword">if</span> (eof &amp;&amp; resIndex + resData.<span class="built_in">size</span>() == index + data.<span class="built_in">size</span>())</span><br><span class="line">        _eof = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_substr</span>(resIndex, resData);<span class="comment">//把resData合并到set里</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; &quot;after push:&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">    for (auto it = assembler.begin(); it != assembler.end(); it++) &#123;</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; &quot;[ &quot; &lt;&lt; it-&gt;index &lt;&lt; &quot;, &quot; &lt;&lt; it-&gt;index + it-&gt;data.size() -1 &lt;&lt; &quot;]&quot; &lt;&lt; endl; </span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; &quot;------------------------------&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//在set里找第一个substr， 看能否write</span></span><br><span class="line">    set&lt;<span class="keyword">substr_t</span>&gt;::iterator it = assembler.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">if</span> (it-&gt;index == _nAssembled) &#123; <span class="comment">//可以write</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; &quot;---------write------------&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; &quot;write &quot; &lt;&lt; it-&gt;data.size() &lt;&lt; &quot;bytes&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; &quot;has writen:[ 0 , &quot; &lt;&lt; _nAssembled + it-&gt;data.size() -1 &lt;&lt; &quot;]&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; &quot;--------------------------&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">        <span class="keyword">size_t</span> bytes_writen = _output.<span class="built_in">write</span>(it-&gt;data);</span><br><span class="line">        _nUnassembled -= it-&gt;data.<span class="built_in">size</span>(); </span><br><span class="line">        assembler.<span class="built_in">erase</span>(it);</span><br><span class="line">        _nAssembled += bytes_writen;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (_eof &amp;&amp; _nUnassembled == <span class="number">0</span>)</span><br><span class="line">        _output.<span class="built_in">end_input</span>();</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StreamReassembler::merge_substr</span><span class="params">(<span class="keyword">size_t</span> index, string&amp; data)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">substr_t</span> <span class="title">substr</span><span class="params">(index, data)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (assembler.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        assembler.<span class="built_in">insert</span>(substr);</span><br><span class="line">        _nUnassembled += substr.data.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    set&lt;<span class="keyword">substr_t</span>&gt;::iterator it = assembler.<span class="built_in">lower_bound</span>(substr);</span><br><span class="line">    <span class="keyword">if</span> (it == assembler.<span class="built_in">end</span>()) &#123;                               <span class="comment">//情况1：substr后面没有可以merge的</span></span><br><span class="line">        set&lt;<span class="keyword">substr_t</span>&gt;::iterator f_it = --it;</span><br><span class="line">        <span class="keyword">if</span> (index + data.<span class="built_in">size</span>() &lt;= f_it-&gt;index + f_it-&gt;data.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; f_it-&gt;index + f_it-&gt;data.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            assembler.<span class="built_in">insert</span>(substr);</span><br><span class="line">            _nUnassembled += substr.data.<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">size_t</span> len = f_it-&gt;data.<span class="built_in">size</span>();</span><br><span class="line">            string _ = f_it-&gt;data + data.<span class="built_in">substr</span>(f_it-&gt;index + f_it-&gt;data.<span class="built_in">size</span>() - index);</span><br><span class="line">            _nUnassembled += _.<span class="built_in">size</span>() - len;</span><br><span class="line">            <span class="keyword">size_t</span> _index = f_it-&gt;index;</span><br><span class="line">            assembler.<span class="built_in">erase</span>(f_it);</span><br><span class="line">            assembler.<span class="built_in">insert</span>(<span class="built_in">substr_t</span>(_index, _));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (it == assembler.<span class="built_in">begin</span>()) &#123;                     <span class="comment">//情况2：substr前面没有可以merge的</span></span><br><span class="line">        <span class="keyword">if</span> (index + data.<span class="built_in">size</span>() &lt; it-&gt;index) &#123;</span><br><span class="line">            assembler.<span class="built_in">insert</span>(<span class="built_in">substr_t</span>(index, data));</span><br><span class="line">            _nUnassembled += data.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (it != assembler.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index + data.<span class="built_in">size</span>() &gt; it-&gt;index + it-&gt;data.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                _nUnassembled -= it-&gt;data.<span class="built_in">size</span>();</span><br><span class="line">                assembler.<span class="built_in">erase</span>(it++);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (index + data.<span class="built_in">size</span>() &lt; it-&gt;index) &#123;</span><br><span class="line">                    assembler.<span class="built_in">insert</span>(<span class="built_in">substr_t</span>(index, data));</span><br><span class="line">                    _nUnassembled += data.<span class="built_in">size</span>();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    string _data = data + it-&gt;data.<span class="built_in">substr</span>(index + data.<span class="built_in">size</span>() - it-&gt;index);</span><br><span class="line">                    _nUnassembled -= it-&gt;data.<span class="built_in">size</span>();</span><br><span class="line">                    assembler.<span class="built_in">erase</span>(it);</span><br><span class="line">                    assembler.<span class="built_in">insert</span>(<span class="built_in">substr_t</span>(index, _data));</span><br><span class="line">                    _nUnassembled += _data.<span class="built_in">size</span>();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            assembler.<span class="built_in">insert</span>(<span class="built_in">substr_t</span>(index, data));</span><br><span class="line">            _nUnassembled += data.<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;                                                              <span class="comment">//情况3：substr前后都有可以merge的，因为每一段都不重复，所以substr后面可能多个merge，substr前面最多一个merge</span></span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (it != assembler.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index + data.<span class="built_in">size</span>() &gt; it-&gt;index + it-&gt;data.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                _nUnassembled -= it-&gt;data.<span class="built_in">size</span>();</span><br><span class="line">                assembler.<span class="built_in">erase</span>(it++);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (index + data.<span class="built_in">size</span>() &lt; it-&gt;index) &#123;</span><br><span class="line">                    assembler.<span class="built_in">insert</span>(<span class="built_in">substr_t</span>(index, data));</span><br><span class="line">                    _nUnassembled += data.<span class="built_in">size</span>();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    string _data = data + it-&gt;data.<span class="built_in">substr</span>(index + data.<span class="built_in">size</span>() - it-&gt;index);</span><br><span class="line">                    _nUnassembled -= it-&gt;data.<span class="built_in">size</span>();</span><br><span class="line">                    assembler.<span class="built_in">erase</span>(it);</span><br><span class="line">                    assembler.<span class="built_in">insert</span>(<span class="built_in">substr_t</span>(index, _data));</span><br><span class="line">                    _nUnassembled += _data.<span class="built_in">size</span>();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            assembler.<span class="built_in">insert</span>(<span class="built_in">substr_t</span>(index, data));</span><br><span class="line">            _nUnassembled += data.<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        it = assembler.<span class="built_in">lower_bound</span>(<span class="built_in">substr_t</span>(index, <span class="string">&quot;&quot;</span>));</span><br><span class="line">        set&lt;<span class="keyword">substr_t</span>&gt;::iterator f_it = it;</span><br><span class="line">        f_it--;</span><br><span class="line">        <span class="keyword">if</span> (f_it-&gt;index + f_it-&gt;data.<span class="built_in">size</span>() &lt; index) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (f_it-&gt;index + f_it-&gt;data.<span class="built_in">size</span>() &lt; it-&gt;index + it-&gt;data.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                string _data = f_it-&gt;data.<span class="built_in">substr</span>(<span class="number">0</span>, index - f_it-&gt;index) + it-&gt;data;</span><br><span class="line">                <span class="keyword">substr_t</span> _(f_it-&gt;index, _data);</span><br><span class="line">                _nUnassembled -= f_it-&gt;data.<span class="built_in">size</span>();</span><br><span class="line">                assembler.<span class="built_in">erase</span>(f_it);</span><br><span class="line">                _nUnassembled -= it-&gt;data.<span class="built_in">size</span>();</span><br><span class="line">                assembler.<span class="built_in">erase</span>(it);</span><br><span class="line">                _nUnassembled += _data.<span class="built_in">size</span>();</span><br><span class="line">                assembler.<span class="built_in">insert</span>(_);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                _nUnassembled -= it-&gt;data.<span class="built_in">size</span>();</span><br><span class="line">                assembler.<span class="built_in">erase</span>(it);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Lab-2"><a href="#Lab-2" class="headerlink" title="Lab 2"></a>Lab 2</h2><h3 id="Translating-between-64-bit-indexes-and-32-bit-seqnos"><a href="#Translating-between-64-bit-indexes-and-32-bit-seqnos" class="headerlink" title="Translating between 64-bit indexes and 32-bit seqnos"></a>Translating between 64-bit indexes and 32-bit seqnos</h3><p>字节的序号分seqno,absolute seqno和stream index，区别在讲义里写的很清楚了：</p>
<p><img src="/_posts/cs144/1.png" alt="1"></p>
<p>wrap和unwrap在seqno和绝对seqno间进行转换，注意seqno是32位的，在传输过程中可能出现循环重复，所以unwrap传入一个最近获取的absolute seqno checkpoint来指定该seqno对应哪个区间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">WrappingInt32 <span class="title">wrap</span><span class="params">(<span class="keyword">uint64_t</span> n, WrappingInt32 isn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> m = n + isn.<span class="built_in">raw_value</span>();</span><br><span class="line">    <span class="keyword">uint32_t</span> k = m % (<span class="number">1ll</span> &lt;&lt; <span class="number">32</span>);</span><br><span class="line">    <span class="keyword">return</span> WrappingInt32&#123;k&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">unwrap</span><span class="params">(WrappingInt32 n, WrappingInt32 isn, <span class="keyword">uint64_t</span> checkpoint)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> m = n.<span class="built_in">raw_value</span>() - isn.<span class="built_in">raw_value</span>();</span><br><span class="line">    <span class="keyword">uint64_t</span> k = m;</span><br><span class="line">    <span class="comment">//ballpark:[k-2^31, k+2^31);</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (checkpoint &lt; k)</span><br><span class="line">        <span class="keyword">return</span> &#123;k&#125;;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> &#123;k + (((((checkpoint - k) &gt;&gt; <span class="number">31</span>) + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) &lt;&lt; <span class="number">32</span>)&#125;;<span class="comment">//0--&gt;0, 1--&gt;0, 2--&gt;1, 3--&gt;2, 4--&gt;2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TCP-Receiver"><a href="#TCP-Receiver" class="headerlink" title="TCP Receiver"></a>TCP Receiver</h3><p>TCP传输过程中，实际上双方是要维护4个值来保证可靠传输和流量控制：1.己方接收窗口剩余大小 2.己方已经确认的字节 3.对方接收窗口大小 4.对方已经确认的字节。TCP协议实际上就是在发送和接受端获取更新这4个值填入到TCP头部。</p>
<p>对于任一方来说，接收器接受到某个TCP segment_recv时，会将其通过reassembler写入到有序字节流bytestream中，这个过程结束后，可以更新1，2两个值。之后发送器会根据segment_recv中给出的3，4两个值来控制需要发送的segment_send的data段的大小和index，然后将之前接收器更新的1，2两个值写入segment_send的header发送出去。</p>
<p>从这个流程来看，receiver要比sender简单许多，实际上就是在收到segment时写入reassembler并更新1，2两个值即可。</p>
<blockquote>
<p>tcp_receiver.hh</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TCPReceiver</span> &#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">TCPStates</span> &#123;</span></span><br><span class="line">        LISTEN = <span class="number">0</span>,</span><br><span class="line">        SYN_RECV = <span class="number">1</span>,</span><br><span class="line">        FIN_RECV = <span class="number">2</span></span><br><span class="line">    &#125;;</span><br><span class="line">    TCPStates _state;</span><br><span class="line">    WrappingInt32 _isn;</span><br><span class="line">    <span class="comment">//! Our data structure for re-assembling bytes.</span></span><br><span class="line">    StreamReassembler _reassembler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! The maximum number of bytes we&#x27;ll store.</span></span><br><span class="line">    <span class="keyword">size_t</span> _capacity;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tcp_receiver.cc</p>
<p>ackno和window_size返回接收器维护的值2和值1.</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPReceiver::segment_received</span><span class="params">(<span class="keyword">const</span> TCPSegment &amp;seg)</span> </span>&#123;</span><br><span class="line">    TCPHeader _header = seg.<span class="built_in">header</span>();</span><br><span class="line">    Buffer _payload = seg.<span class="built_in">payload</span>();</span><br><span class="line">    </span><br><span class="line">    WrappingInt32 _seqno(_header.seqno);</span><br><span class="line">    <span class="keyword">uint64_t</span> _index;</span><br><span class="line">    <span class="keyword">bool</span> eof = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (_header.syn) &#123;</span><br><span class="line">        _isn = <span class="built_in">WrappingInt32</span>(_header.seqno);</span><br><span class="line">        _state = SYN_RECV;</span><br><span class="line">        _index = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> _index = <span class="built_in">unwrap</span>(_seqno, _isn, _reassembler.<span class="built_in">firstunassembled</span>()) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (_header.fin) &#123;</span><br><span class="line">        eof = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _reassembler.<span class="built_in">push_substring</span>(_payload.<span class="built_in">copy</span>(), _index, eof);</span><br><span class="line">    <span class="keyword">if</span> (_reassembler.<span class="built_in">stream_out</span>().<span class="built_in">input_ended</span>())</span><br><span class="line">        _state = FIN_RECV;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">optional&lt;WrappingInt32&gt; <span class="title">TCPReceiver::ackno</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (_state == LISTEN) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (_state == FIN_RECV)</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="built_in">wrap</span>(_reassembler.<span class="built_in">firstunassembled</span>()+<span class="number">2</span>, _isn)&#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="built_in">wrap</span>(_reassembler.<span class="built_in">firstunassembled</span>()+<span class="number">1</span>, _isn)&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">TCPReceiver::window_size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> &#123;_reassembler.<span class="built_in">stream_out</span>().<span class="built_in">remaining_capacity</span>()&#125;; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Lab-3"><a href="#Lab-3" class="headerlink" title="Lab 3"></a>Lab 3</h2><h3 id="TCP-Sender"><a href="#TCP-Sender" class="headerlink" title="TCP Sender"></a>TCP Sender</h3><p>根据上一节所描述的，Sender根据值3和值4来控制写入data段的大小和index。</p>
<p>ack_received()更新值3和值4，fill_window()通过send_segment()把数据报发送出去。</p>
<p>发送出去的segment会写入_segment_out和segment_outstanding， 后者用于指示正在“飞行”途中的数据段，如果某个数据段被ack了，该数据段就会从segment_outstanding中pop出来。</p>
<p>另一个重点是定时器，如果某个数据段在outstanding中过了很长时间(rto)还没有被ack，说明这一段可能丢失了需要重发，如果某一段重发次数过多，说明网络出现了问题，就需要关闭TCP连接。</p>
<p>每次定时器超时，都需要将rto翻倍。ack_received中，若值4若有更新，说明刚发的数据报被接收到了，定时器就要重置，并且需要判断outstanding是否为空，如果为空定时器就关闭，每次通过send_segment发送新的数据报（不是重发outstanding中的数据报）时，定时器打开并重置时间。</p>
<blockquote>
<p>tcp_sender</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPSender::fill_window</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_sendsyn) &#123;</span><br><span class="line">        TCPSegment _seg;</span><br><span class="line">        _seg.<span class="built_in">header</span>().seqno = _isn;</span><br><span class="line">        _seg.<span class="built_in">header</span>().syn = <span class="literal">true</span>;</span><br><span class="line">        _sendsyn = <span class="literal">false</span>;</span><br><span class="line">        _synsent = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">send_segment</span>(_seg);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">size_t</span> _cansend;</span><br><span class="line">    <span class="keyword">size_t</span> win;</span><br><span class="line">    <span class="keyword">if</span> (_window_size == <span class="number">0</span>) &#123;</span><br><span class="line">        win = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> win = _window_size;</span><br><span class="line">    <span class="keyword">if</span> (win &lt; _next_seqno - _ackno)</span><br><span class="line">        _cansend = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> _cansend = win - (_next_seqno - _ackno);</span><br><span class="line">    <span class="keyword">while</span> (_cansend &gt; <span class="number">0</span> &amp;&amp; !_finsent) &#123;</span><br><span class="line">        string _payload = _stream.<span class="built_in">read</span>(<span class="built_in">min</span>(_cansend, TCPConfig::MAX_PAYLOAD_SIZE));</span><br><span class="line">        TCPSegment _seg;</span><br><span class="line">        _seg.<span class="built_in">payload</span>() = <span class="built_in">Buffer</span>(std::<span class="built_in">move</span>(_payload));</span><br><span class="line">        _seg.<span class="built_in">header</span>().seqno = <span class="built_in">wrap</span>(_next_seqno, _isn);</span><br><span class="line">        <span class="keyword">if</span> (_stream.<span class="built_in">eof</span>() &amp;&amp; _seg.<span class="built_in">length_in_sequence_space</span>() &lt; _cansend) &#123;</span><br><span class="line">            _seg.<span class="built_in">header</span>().fin = <span class="literal">true</span>;</span><br><span class="line">            _finsent = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (_seg.<span class="built_in">length_in_sequence_space</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">send_segment</span>(_seg);</span><br><span class="line">        _cansend = win - (_next_seqno - _ackno);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param ackno The remote receiver&#x27;s ackno (acknowledgment number)</span></span><br><span class="line"><span class="comment">//! \param window_size The remote receiver&#x27;s advertised window size</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TCPSender::ack_received</span><span class="params">(<span class="keyword">const</span> WrappingInt32 ackno, <span class="keyword">const</span> <span class="keyword">uint16_t</span> window_size)</span> </span>&#123;</span><br><span class="line">    _window_size = window_size;</span><br><span class="line">    <span class="keyword">uint64_t</span> ack = <span class="built_in">unwrap</span>(ackno, _isn, _ackno);</span><br><span class="line">    <span class="keyword">if</span> (ack &gt; _next_seqno) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (_ackno &lt; ack) &#123;</span><br><span class="line">        _ackno = ack;</span><br><span class="line">        _rto = _initial_retransmission_timeout;</span><br><span class="line">        _consecutive_retran_count = <span class="number">0</span>;</span><br><span class="line">        _timer_count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (!_segment_outstanding.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TCPHeader _header = _segment_outstanding.<span class="built_in">front</span>().<span class="built_in">header</span>();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">unwrap</span>(_header.seqno, _isn, _ackno) + _segment_outstanding.<span class="built_in">front</span>().<span class="built_in">length_in_sequence_space</span>() &lt;= _ackno) &#123;</span><br><span class="line">            _bytes_in_flight -= _segment_outstanding.<span class="built_in">front</span>().<span class="built_in">length_in_sequence_space</span>();</span><br><span class="line">            _segment_outstanding.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (_segment_outstanding.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        _timer_started = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fill_window</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param[in] ms_since_last_tick the number of milliseconds since the last call to this method</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPSender::tick</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> ms_since_last_tick)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (_timer_started == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    _timer_count += ms_since_last_tick;</span><br><span class="line">    <span class="keyword">if</span> (_timer_count &gt;= _rto) &#123;</span><br><span class="line">        TCPSegment _firstseg = _segment_outstanding.<span class="built_in">front</span>();</span><br><span class="line">        _segments_out.<span class="built_in">push</span>(_firstseg);</span><br><span class="line">        _consecutive_retran_count++;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">unwrap</span>(_firstseg.<span class="built_in">header</span>().seqno, _isn, _ackno) - _ackno + _firstseg.<span class="built_in">length_in_sequence_space</span>() &lt;= _window_size)</span><br><span class="line">            _rto *= <span class="number">2</span>;        <span class="comment">// double rto</span></span><br><span class="line">        _timer_started = <span class="number">1</span>;</span><br><span class="line">        _timer_count = <span class="number">0</span>; <span class="comment">//reset timer</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">TCPSender::consecutive_retransmissions</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> &#123;_consecutive_retran_count&#125;; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPSender::send_empty_segment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TCPSegment _seg;</span><br><span class="line">    _seg.<span class="built_in">header</span>().seqno = <span class="built_in">next_seqno</span>();</span><br><span class="line">    _segments_out.<span class="built_in">push</span>(_seg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPSender::send_segment</span><span class="params">(TCPSegment&amp; seg)</span> </span>&#123;</span><br><span class="line">    _next_seqno += seg.<span class="built_in">length_in_sequence_space</span>();</span><br><span class="line">    _segments_out.<span class="built_in">push</span>(seg);</span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">length_in_sequence_space</span>() != <span class="number">0</span>) &#123;</span><br><span class="line">        _segment_outstanding.<span class="built_in">push</span>(seg);</span><br><span class="line">    &#125;</span><br><span class="line">    _bytes_in_flight += seg.<span class="built_in">length_in_sequence_space</span>();</span><br><span class="line">    <span class="keyword">if</span> (_timer_started == <span class="number">0</span>) &#123;</span><br><span class="line">        _timer_started = <span class="number">1</span>;</span><br><span class="line">        _timer_count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Lab-4"><a href="#Lab-4" class="headerlink" title="Lab 4"></a>Lab 4</h2><h3 id="TCP-Connection"><a href="#TCP-Connection" class="headerlink" title="TCP Connection"></a>TCP Connection</h3><p>这个lab将之前的发送器和接收器结合起来，组成一个完整的TCP端，感觉比较难，主要要搞清楚两个方面：一是接发数据段时函数的执行流程，二是TCP状态的转换，重点是关闭连接。</p>
<p>TCP某一方本质上在串行执行收-发-收-发…的流程，不考虑syn和fin的特殊情况，在收到某一个数据报时，该数据报头部会包含值3和值4，把数据报传入receiver后会得到值1和值2。接下来进行发的动作，数据报包含header和payload，sender会通过值3和值4填写合适大小的payload，tcpconnection类需要把值1和值2填写到header中，这样一个完整的数据报就合成好了，通过push_segments发送出去。这是大概的处理流程，中间有很多细节，例如发送数据报时如果没有数据，也要发送一个空数据报来作为ack报文，这些细节可以通过测试用例完善。</p>
<p>比较复杂的是关闭连接的操作，对于任一方，满足以下4个条件可以表示连接可以clean shutdown：</p>
<p>1.接收字节流已经把字节全部组成完毕，并且input_ended。</p>
<p>2.app已经向发送字节流发送了EOF，并且这些字节已经全部发送了出去（即发送了fin）。</p>
<p>3.发送端发送的所有字节（包括fin）已经全部被对方ack。</p>
<p>4.保证对方满足条件3。</p>
<p>对于主动关闭的一方，条件2对应四次握手中的第一步：发送fin，条件3对应第二步：收到ack，条件1对应第三步：收到fin并发送ack，而满足条件4，需要在第三步收到fin，发送ack之后等待足够长（10*rto）的时间来保证对方没有重发任何报文，如果足够长时间内对方没有发送任何数据包，说明对方已经收到我的最后一个ack。</p>
<p>对于被动关闭的一方，在接收到对方对我方fin报文的ack之后，就可以直接关闭无需等待，这是为什么？看起来”接收到对方对我方fin报文的ack”这件事仅仅代表满足条件3，但实际上，由于tcp的累计确认性质，它包含了一个隐含前提，即“对方的确收到了我的fin以及之前的所有报文”，当然也包括我方对对方所有字节的ack。因此也满足条件4.</p>
<p>另外是如何定义“主动关闭”？实际上只要在发送fin报文之前没有收到对方的fin报文都算主动关闭，因此可能会产生双方都是主动关闭，都需要经过linger time的情况，也就是tcp状态中的closing状态。例如双方几乎同时发送了fin报文，或者一方先发送fin，但报文丢失了，在重发之前对方app close了socket，如果实在想不通可以看看下图。</p>
<p><img src="/_posts/cs144/2.png" alt="2"></p>
<blockquote>
<p>tcp_connection.cc</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPConnection::segment_received</span><span class="params">(<span class="keyword">const</span> TCPSegment &amp;seg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> send_empty = <span class="literal">false</span>;</span><br><span class="line">    _time_since_last_recv = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">active</span>()) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">header</span>().rst == <span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">unclean_shutdown</span>();</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">header</span>().ack) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!_sender.<span class="built_in">syn_sent</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            _sender.<span class="built_in">ack_received</span>(seg.<span class="built_in">header</span>().ackno, seg.<span class="built_in">header</span>().win);</span><br><span class="line">    &#125;</span><br><span class="line">    _receiver.<span class="built_in">segment_received</span>(seg);</span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">header</span>().syn &amp;&amp; !_sender.<span class="built_in">syn_sent</span>()) &#123;</span><br><span class="line">        <span class="built_in">connect</span>();</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">header</span>().fin) &#123;</span><br><span class="line">        <span class="comment">//if (!_sender.fin_sent())</span></span><br><span class="line">        <span class="comment">//    _sender.fill_window();</span></span><br><span class="line">        <span class="keyword">if</span> (!_sender.<span class="built_in">fin_sent</span>()) &#123;</span><br><span class="line">            _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        send_empty = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (seg.<span class="built_in">length_in_sequence_space</span>()) &#123;</span><br><span class="line">        send_empty = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (send_empty) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>())</span><br><span class="line">            _sender.<span class="built_in">send_empty_segment</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">push_segments</span>();</span><br><span class="line">    <span class="built_in">check_shutdown</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TCPConnection::active</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> &#123;_active&#125;; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">TCPConnection::write</span><span class="params">(<span class="keyword">const</span> string &amp;data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> sz = _sender.<span class="built_in">stream_in</span>().<span class="built_in">write</span>(data);</span><br><span class="line">    <span class="keyword">return</span> &#123;sz&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param[in] ms_since_last_tick number of milliseconds since the last call to this method</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPConnection::tick</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> ms_since_last_tick)</span> </span>&#123;</span><br><span class="line">    _sender._sendsyn = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">active</span>()) <span class="keyword">return</span>;</span><br><span class="line">    _time_since_last_recv += ms_since_last_tick;</span><br><span class="line">    _sender.<span class="built_in">tick</span>(ms_since_last_tick);</span><br><span class="line">    <span class="keyword">if</span> (_sender.<span class="built_in">consecutive_retransmissions</span>() &gt; TCPConfig::MAX_RETX_ATTEMPTS) &#123;</span><br><span class="line">        _send_rst = <span class="literal">true</span>;</span><br><span class="line">        _sender.<span class="built_in">send_empty_segment</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">push_segments</span>();</span><br><span class="line">    <span class="built_in">check_shutdown</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPConnection::end_input_stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _sender.<span class="built_in">stream_in</span>().<span class="built_in">end_input</span>();</span><br><span class="line">    <span class="built_in">push_segments</span>();</span><br><span class="line">    <span class="built_in">check_shutdown</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPConnection::connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _sender._sendsyn = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">push_segments</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TCPConnection::~<span class="built_in">TCPConnection</span>() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">active</span>()) &#123;</span><br><span class="line">            cerr &lt;&lt; <span class="string">&quot;Warning: Unclean shutdown of TCPConnection\n&quot;</span>;</span><br><span class="line">            <span class="comment">//destruct when active</span></span><br><span class="line">            <span class="comment">//send rst</span></span><br><span class="line">            _send_rst = <span class="literal">true</span>;</span><br><span class="line">            _sender.<span class="built_in">send_empty_segment</span>();</span><br><span class="line">            <span class="built_in">push_segments</span>();</span><br><span class="line">            <span class="comment">// Your code here: need to send a RST segment to the peer</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">const</span> exception &amp;e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception destructing TCP FSM: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPConnection::unclean_shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _sender.<span class="built_in">stream_in</span>().<span class="built_in">set_error</span>();</span><br><span class="line">    _receiver.<span class="built_in">stream_out</span>().<span class="built_in">set_error</span>();</span><br><span class="line">    _active = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPConnection::push_segments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _sender.<span class="built_in">fill_window</span>();</span><br><span class="line">    <span class="keyword">while</span> (!_sender.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TCPSegment seg = _sender.<span class="built_in">segments_out</span>().<span class="built_in">front</span>();</span><br><span class="line">        <span class="keyword">if</span> (_send_rst) &#123;</span><br><span class="line">            seg.<span class="built_in">header</span>().rst = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">unclean_shutdown</span>();</span><br><span class="line">            _segments_out.<span class="built_in">push</span>(seg);</span><br><span class="line">            _sender.<span class="built_in">segments_out</span>().<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _sender.<span class="built_in">segments_out</span>().<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (_receiver.<span class="built_in">ackno</span>().<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">            seg.<span class="built_in">header</span>().ack = <span class="literal">true</span>;</span><br><span class="line">            seg.<span class="built_in">header</span>().ackno = _receiver.<span class="built_in">ackno</span>().<span class="built_in">value</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        seg.<span class="built_in">header</span>().win = _receiver.<span class="built_in">window_size</span>();</span><br><span class="line">        _segments_out.<span class="built_in">push</span>(seg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPConnection::check_shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//passive?</span></span><br><span class="line">    <span class="keyword">if</span> (_receiver.<span class="built_in">stream_out</span>().<span class="built_in">input_ended</span>() &amp;&amp; (!_sender.<span class="built_in">stream_in</span>().<span class="built_in">eof</span>()))</span><br><span class="line">        _linger_after_streams_finish = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//active close, prereq#1~#4</span></span><br><span class="line">    <span class="keyword">if</span> (_linger_after_streams_finish &amp;&amp; _receiver.<span class="built_in">stream_out</span>().<span class="built_in">eof</span>() &amp;&amp; _sender.<span class="built_in">stream_in</span>().<span class="built_in">eof</span>() &amp;&amp; _sender.<span class="built_in">fin_sent</span>() &amp;&amp; <span class="built_in">bytes_in_flight</span>()==<span class="number">0</span> &amp;&amp; _time_since_last_recv &gt;= <span class="number">10</span> * _cfg.rt_timeout)</span><br><span class="line">        _active = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//passive close, prereq#1~#3</span></span><br><span class="line">    <span class="keyword">if</span> (!_linger_after_streams_finish &amp;&amp; _receiver.<span class="built_in">stream_out</span>().<span class="built_in">eof</span>() &amp;&amp; _sender.<span class="built_in">stream_in</span>().<span class="built_in">eof</span>() &amp;&amp; _sender.<span class="built_in">fin_sent</span>() &amp;&amp; <span class="built_in">bytes_in_flight</span>() == <span class="number">0</span>)</span><br><span class="line">        _active = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1.最终通过了除webget的所有test，我使用的是WSL2，使用nat模式和主机连接。我爬了一下数据包，发现外网发送过来的syn在物理网卡上能够接收到，但不会传给wsl，我猜测是tun设备的ip不是wsl虚拟机的ip，导致nat表中找不到路由，之后我会把网络改成桥接模式再试一下。</p>
<p>2.lab0~4完成了一个用户态TCP协议栈，lab要求实现协议栈，而“用户态”是框架代码通过tun设备实现的，关于tun设备可以看陈硕大佬的这篇博客<a target="_blank" rel="noopener" href="https://blog.csdn.net/solstice/article/details/6579232">关于 TCP 并发连接的几个思考题与试验</a>。框架代码是用modern c++写的，也很有学习意义。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kiseki-zj.github.io/2021/11/17/MIT6.S081%20Lab10/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="Kiseki">
      <meta itemprop="description" content=""开心就好啦"">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KISEKI">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/17/MIT6.S081%20Lab10/" class="post-title-link" itemprop="url">MIT6.S081 Lab10 Mmap</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-11-17 12:00:00 / 修改时间：18:35:58" itemprop="dateCreated datePublished" datetime="2021-11-17T12:00:00+08:00">2021-11-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Mmap"><a href="#Mmap" class="headerlink" title="Mmap"></a>Mmap</h2><p>这个实验要求实现一个简易的mmap系统调用，因为所有测试里length都是页对齐的，所以根据hints来做还是挺简单的。</p>
<p>有一个问题是mmap返回的虚拟地址要怎么分配。最简单的想法是从p-&gt;sz开始，但是问题是这个地址不一定是页对齐的，并且如果在mmap后调用了sbrk，再调用munmap，虚拟地址就会产生空洞不连续了，会比较麻烦。</p>
<p>所以我选择在0x85000000处向上分配，选择这个地址是因为PHYSTOP是0x86400000，一共16块VMA，每个文件大小为268*1024B.PHYSTOP-16 * 268 * 1024 = 0x85FD0000.这个空间够用了。</p>
<blockquote>
<p>VMA数据结构</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VMA</span> &#123;</span></span><br><span class="line">  uint64 addr;</span><br><span class="line">  uint64 length;</span><br><span class="line">  <span class="keyword">int</span> prot;</span><br><span class="line">  <span class="keyword">int</span> flags;</span><br><span class="line">  <span class="keyword">int</span> fd;</span><br><span class="line">  <span class="keyword">int</span> offset;</span><br><span class="line">  <span class="keyword">int</span> valid;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>实现mmap。这里我分配的每个addr都是页对齐的。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64</span></span><br><span class="line"><span class="function"><span class="title">sys_mmap</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  uint64 length;</span><br><span class="line">  <span class="keyword">int</span> prot, flags, fd;</span><br><span class="line">  <span class="keyword">if</span> (argaddr(<span class="number">1</span>, &amp;length) &lt; <span class="number">0</span> || argint(<span class="number">2</span>, &amp;prot) &lt; <span class="number">0</span> || argint(<span class="number">3</span>, &amp;flags) &lt; <span class="number">0</span> || argint(<span class="number">4</span>, &amp;fd) &lt; <span class="number">0</span>) </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span> =</span> p-&gt;ofile[fd];</span><br><span class="line">  <span class="comment">// printf(&quot;ref before mmap=%d\n&quot;, file-&gt;ip-&gt;ref);</span></span><br><span class="line">  <span class="keyword">if</span> ((prot &amp; PROT_READ) &amp;&amp; !file-&gt;readable)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> ((flags &amp; MAP_SHARED) &amp;&amp; (prot &amp; PROT_WRITE) &amp;&amp; !file-&gt;writable)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  uint64 maxend = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; ++i)</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;vmas[i].valid &amp;&amp; p-&gt;vmas[i].addr+p-&gt;vmas[i].length &gt; maxend)</span><br><span class="line">      maxend = p-&gt;vmas[i].addr + p-&gt;vmas[i].length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!p-&gt;vmas[i].valid) &#123;</span><br><span class="line">      <span class="comment">//printf(&quot;fd = %d file-&gt;ip-&gt;inum = %d\n&quot;, fd, file-&gt;ip-&gt;inum);</span></span><br><span class="line">      p-&gt;vmas[i].addr = maxend==<span class="number">0</span>?MMAPBASE:PGROUNDUP(maxend);</span><br><span class="line">      p-&gt;vmas[i].length = length;</span><br><span class="line">      p-&gt;vmas[i].fd = fd;</span><br><span class="line">      p-&gt;vmas[i].f = file;</span><br><span class="line">      p-&gt;vmas[i].flags = flags;</span><br><span class="line">      p-&gt;vmas[i].offset = <span class="number">0</span>;</span><br><span class="line">      p-&gt;vmas[i].prot = prot;</span><br><span class="line">      p-&gt;vmas[i].valid = <span class="number">1</span>;</span><br><span class="line">      filedup(p-&gt;vmas[i].f);</span><br><span class="line">      <span class="comment">// printf(&quot;ref after mmap=%d\n&quot;, file-&gt;ip-&gt;ref);</span></span><br><span class="line">      <span class="keyword">return</span> p-&gt;vmas[i].addr;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在trap.c中实现lazy allocation</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (r_scause() == <span class="number">13</span> || r_scause() == <span class="number">15</span>) &#123;</span><br><span class="line">    uint64 va = r_stval();</span><br><span class="line">    <span class="keyword">if</span> (mmap_pgfault(p, va)&lt;<span class="number">0</span>) &#123;</span><br><span class="line">      p-&gt;killed = <span class="number">-1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mmap_pgfault</span><span class="params">(struct proc *p, uint64 va)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">VMA</span> *<span class="title">v</span> =</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;vmas[i].valid &amp;&amp; va &gt;= p-&gt;vmas[i].addr &amp;&amp; va &lt; p-&gt;vmas[i].addr+p-&gt;vmas[i].length) &#123;</span><br><span class="line">      v = &amp;p-&gt;vmas[i];</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (v == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  uint64 ka;</span><br><span class="line">  ka = (uint64)kalloc();</span><br><span class="line">  <span class="keyword">if</span> (ka == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">memset</span>((<span class="keyword">void</span>*)ka, <span class="number">0</span>, PGSIZE);</span><br><span class="line">  <span class="keyword">int</span> pte_prot = PTE_U | PTE_X;</span><br><span class="line">  <span class="keyword">if</span> (v-&gt;prot | PROT_READ)</span><br><span class="line">    pte_prot |= PTE_R;</span><br><span class="line">  <span class="keyword">if</span> (v-&gt;prot | PROT_WRITE)</span><br><span class="line">    pte_prot |= PTE_W;</span><br><span class="line">  <span class="keyword">if</span> (mappages(p-&gt;pagetable, PGROUNDDOWN(va), PGSIZE, ka, pte_prot) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    kfree((<span class="keyword">void</span>*)ka);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span> =</span> v-&gt;f;</span><br><span class="line">  <span class="comment">//printf(&quot;------%d\n&quot;, f-&gt;ip-&gt;inum);</span></span><br><span class="line">  idup(f-&gt;ip);</span><br><span class="line">  ilock(f-&gt;ip);</span><br><span class="line">  readi(f-&gt;ip, <span class="number">1</span>, PGROUNDDOWN(va), PGROUNDDOWN(va)-v-&gt;addr, PGSIZE);</span><br><span class="line">  iunlockput(f-&gt;ip);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>实现munmap。如果所有页都unmap掉了，对应文件引用计数-1</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64</span></span><br><span class="line"><span class="function"><span class="title">sys_munmap</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  uint64 addr, length;</span><br><span class="line">  <span class="keyword">if</span> (argaddr(<span class="number">0</span>, &amp;addr) &lt; <span class="number">0</span> || argaddr(<span class="number">1</span>, &amp;length) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; ++i) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">VMA</span> *<span class="title">v</span> =</span> &amp;p-&gt;vmas[i];</span><br><span class="line">    <span class="keyword">if</span> (v-&gt;valid &amp;&amp; addr &gt;= v-&gt;addr &amp;&amp; addr &lt;= v-&gt;addr+v-&gt;length) &#123;</span><br><span class="line">      <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (addr == v-&gt;addr &amp;&amp; addr+length == v-&gt;addr+v-&gt;length)</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (v-&gt;flags | MAP_SHARED) </span><br><span class="line">        filewrite(v-&gt;f, addr, length);</span><br><span class="line">      <span class="keyword">if</span> (walkaddr(p-&gt;pagetable, addr))</span><br><span class="line">        uvmunmap(p-&gt;pagetable, addr, length/PGSIZE, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        v-&gt;valid = <span class="number">0</span>;</span><br><span class="line">        v-&gt;f = filedel(v-&gt;f);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (addr == v-&gt;addr)</span><br><span class="line">          v-&gt;addr = addr + length;</span><br><span class="line">        v-&gt;length = v-&gt;length - length;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//filedel类似filedup</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct file*</span></span><br><span class="line"><span class="function"><span class="title">filedel</span><span class="params">(struct file *f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  acquire(&amp;ftable.lock);</span><br><span class="line">  <span class="keyword">if</span>(f-&gt;ref &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;filedel&quot;</span>);</span><br><span class="line">  f-&gt;ref--;</span><br><span class="line">  release(&amp;ftable.lock);</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>fork时子进程复制父进程的vma：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NOFILE; i++)</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ofile[i])</span><br><span class="line">      np-&gt;ofile[i] = filedup(p-&gt;ofile[i]);</span><br><span class="line">  np-&gt;cwd = idup(p-&gt;cwd);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;vmas[i].valid) &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">VMA</span> <span class="title">v</span> =</span> p-&gt;vmas[i];</span><br><span class="line">      np-&gt;vmas[i] = v;</span><br><span class="line">      filedup(v.f);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>exit时执行unmap类似的操作。这里虚拟地址可能会出现空洞，例如mmap分配了3页，只对第2页的地址进行了使用。这种情况下由于使用了lazy allocation，第1页和第3页并没有分配，也不会map，因此我逐页进行uvmunmap和filewrite。（其实在munmap里也应该这样做，但是测试数据比较弱没有考虑这种情况）。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> fd = <span class="number">0</span>; fd &lt; NOFILE; fd++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ofile[fd])&#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span> =</span> p-&gt;ofile[fd];</span><br><span class="line">      fileclose(f);</span><br><span class="line">      p-&gt;ofile[fd] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;vmas[i].valid) &#123;</span><br><span class="line">      p-&gt;vmas[i].valid = <span class="number">0</span>;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">VMA</span> *<span class="title">v</span> =</span> &amp;p-&gt;vmas[i];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> np = <span class="number">0</span>; np &lt; v-&gt;length/PGSIZE; ++np) &#123;</span><br><span class="line">        <span class="keyword">if</span> (walkaddr(p-&gt;pagetable, v-&gt;addr+np*PGSIZE)) &#123;</span><br><span class="line">          <span class="keyword">if</span> (v-&gt;flags | MAP_SHARED)</span><br><span class="line">            filewrite(v-&gt;f, v-&gt;addr+np*PGSIZE, PGSIZE);</span><br><span class="line">          uvmunmap(p-&gt;pagetable, v-&gt;addr+np*PGSIZE, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; </span><br><span class="line">      filedel(v-&gt;f);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="/images/2.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kiseki-zj.github.io/2021/11/05/MIT6.S081%20Lab9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="Kiseki">
      <meta itemprop="description" content=""开心就好啦"">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KISEKI">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/05/MIT6.S081%20Lab9/" class="post-title-link" itemprop="url">MIT6.S081 Lab9 FileSystem</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-11-05 12:00:00 / 修改时间：13:45:01" itemprop="dateCreated datePublished" datetime="2021-11-05T12:00:00+08:00">2021-11-05</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Large-files"><a href="#Large-files" class="headerlink" title="Large files"></a>Large files</h2><p>这个实验要求扩展xv6文件大小，从268个block（12direct * 1+1single indirect * 256）扩展到65803个block（11derect * 1+1single indirect * 256+1double indirect * 256 * 256）。</p>
<p>需要看懂bmap函数的作用，bmap接收一个inode和逻辑块号bn，通过寻址把bn映射为物理块号返回。</p>
<blockquote>
<p>inode的addrs大小不变仍为13，direct缩小为11，最后一位改为double indirect，dinode同理。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> uint</span></span><br><span class="line"><span class="function"><span class="title">bmap</span><span class="params">(struct inode *ip, uint bn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uint addr, *a;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NDIRECT)&#123;</span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[bn]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line">  bn -= NDIRECT;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(bn &lt; NINDIRECT)&#123;</span><br><span class="line">    <span class="comment">// Load indirect block, allocating if necessary.</span></span><br><span class="line">    <span class="keyword">if</span>((addr = ip-&gt;addrs[NDIRECT]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[NDIRECT] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">if</span>((addr = a[bn]) == <span class="number">0</span>)&#123;</span><br><span class="line">      a[bn] = addr = balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line">  bn -= NINDIRECT;</span><br><span class="line">  <span class="keyword">if</span> (bn &lt; NDBDIRECT) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((addr = ip-&gt;addrs[NDIRECT + <span class="number">1</span>]) == <span class="number">0</span>)</span><br><span class="line">      ip-&gt;addrs[NDIRECT + <span class="number">1</span>] = addr = balloc(ip-&gt;dev);</span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">if</span> ((addr = a[bn / NINDIRECT]) == <span class="number">0</span>) &#123;</span><br><span class="line">      a[bn / NINDIRECT] = addr = balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    bp = bread(ip-&gt;dev, addr);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">if</span> ((addr = a[bn % NINDIRECT]) == <span class="number">0</span>) &#123;</span><br><span class="line">      a[bn % NINDIRECT] = addr = balloc(ip-&gt;dev);</span><br><span class="line">      log_write(bp);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">  &#125;</span><br><span class="line">  panic(<span class="string">&quot;bmap: out of range&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>修改itrunc使得能够释放double indirect的块。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">itrunc</span><span class="params">(struct inode *ip)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, j;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line">  uint *a;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; NDIRECT; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;addrs[i])&#123;</span><br><span class="line">      bfree(ip-&gt;dev, ip-&gt;addrs[i]);</span><br><span class="line">      ip-&gt;addrs[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;addrs[NDIRECT])&#123;</span><br><span class="line">    bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; NINDIRECT; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(a[j])</span><br><span class="line">        bfree(ip-&gt;dev, a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);</span><br><span class="line">    ip-&gt;addrs[NDIRECT] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (ip-&gt;addrs[NDIRECT + <span class="number">1</span>]) &#123;</span><br><span class="line">    bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT + <span class="number">1</span>]);</span><br><span class="line">    a = (uint*)bp-&gt;data;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; NINDIRECT; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[j]) &#123;</span><br><span class="line">        uint addr, *data;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bbp</span>;</span></span><br><span class="line">        addr = a[j];</span><br><span class="line">        bbp = bread(ip-&gt;dev, addr);</span><br><span class="line">        data = (uint*)bbp-&gt;data;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; NINDIRECT; k++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (data[k])</span><br><span class="line">            bfree(ip-&gt;dev, data[k]);</span><br><span class="line">        &#125;</span><br><span class="line">        brelse(bbp);</span><br><span class="line">        bfree(ip-&gt;dev, addr);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">    bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT + <span class="number">1</span>]);</span><br><span class="line">    ip-&gt;addrs[NDIRECT + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ip-&gt;size = <span class="number">0</span>;</span><br><span class="line">  iupdate(ip);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Symbolic-links"><a href="#Symbolic-links" class="headerlink" title="Symbolic links"></a>Symbolic links</h2><p>硬链接就是几个不同的direntry拥有相同的inum。软链接是一个特殊的文件，文件内容是一个路径指向所链接的文件。</p>
<p>xv6实现了硬链接，这个lab要求实现软链接。</p>
<blockquote>
<p>首先实现系统调用symlink来创建一个软链接文件。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64</span></span><br><span class="line"><span class="function"><span class="title">sys_symlink</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> target[MAXPATH], path[MAXPATH];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line">  <span class="keyword">if</span> (argstr(<span class="number">0</span>, target, MAXPATH) &lt; <span class="number">0</span> || argstr(<span class="number">1</span>, path, MAXPATH) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  begin_op();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((ip = create(path, T_SYMLINK, <span class="number">0</span>, <span class="number">0</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  writei(ip, <span class="number">0</span>, (uint64)target, <span class="number">0</span>, MAXPATH);</span><br><span class="line">  iunlockput(ip);</span><br><span class="line">  end_op();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>修改系统调用open用来打开软链接文件。如果O_NOFOLLOW则直接返回这个软链接的inode。</p>
<p>否则返回它指向的文件的inode，如果指向的文件也是一个软链接，继续打开软链接指向的文件直到指向一个inode或形成环。</p>
<p>这里需要注意iunlock和iput的区别。iget/iput用于增加/减少ip的ref，用于表示inode cache中这个inode有多少个指针正在指向它，如果没有一个进程指向这个inode，则可以从cache中释放。</p>
<p>ilock/iunlock用于给inode加锁保证线程同步。</p>
<p>一般的调用操作顺序是iget-&gt;ilock-&gt;iunlock-&gt;iput.在open系统调用中，如果成功找到一个ip，返回时只需要到iunlock即可，不需要iput，因为open文件表示这个进程正在使用这个inode。直到close才能iput。</p>
<p>另外注意有的函数中间会执行iget/ilock，例如namei成功调用时返回的ip是已经经过iget操作的。</p>
<p>任何不需要的inode（open操作失败，或者递归打开软链接）都应该iunlockput。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64</span></span><br><span class="line"><span class="function"><span class="title">sys_open</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> path[MAXPATH];</span><br><span class="line">  <span class="keyword">int</span> fd, omode;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((n = argstr(<span class="number">0</span>, path, MAXPATH)) &lt; <span class="number">0</span> || argint(<span class="number">1</span>, &amp;omode) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  begin_op();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(omode &amp; O_CREATE)&#123;</span><br><span class="line">    ip = create(path, T_FILE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ip == <span class="number">0</span>)&#123;</span><br><span class="line">      end_op();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>((ip = namei(path)) == <span class="number">0</span>)&#123;</span><br><span class="line">      end_op();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ilock(ip);</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;type == T_DIR &amp;&amp; omode != O_RDONLY)&#123;</span><br><span class="line">      iunlockput(ip);</span><br><span class="line">      end_op();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;type == T_DEVICE &amp;&amp; (ip-&gt;major &lt; <span class="number">0</span> || ip-&gt;major &gt;= NDEV))&#123;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (ip-&gt;type == T_SYMLINK &amp;&amp; !(omode&amp;O_NOFOLLOW)) &#123;</span><br><span class="line">    <span class="keyword">while</span> (ip-&gt;type == T_SYMLINK &amp;&amp; depth &lt; <span class="number">10</span>) &#123;</span><br><span class="line">      readi(ip, <span class="number">0</span>, (uint64)path, <span class="number">0</span>, MAXPATH);</span><br><span class="line">      iunlockput(ip);</span><br><span class="line">      <span class="keyword">if</span> ((ip = namei(path)) == <span class="number">0</span>) &#123;</span><br><span class="line">        end_op();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ilock(ip);</span><br><span class="line">      depth++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (depth == <span class="number">10</span>) &#123;</span><br><span class="line">      iunlockput(ip);</span><br><span class="line">      end_op();</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>((f = filealloc()) == <span class="number">0</span> || (fd = fdalloc(f)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(f)</span><br><span class="line">      fileclose(f);</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125; </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;type == T_DEVICE)&#123;</span><br><span class="line">    f-&gt;type = FD_DEVICE;</span><br><span class="line">    f-&gt;major = ip-&gt;major;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    f-&gt;type = FD_INODE;</span><br><span class="line">    f-&gt;off = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  f-&gt;ip = ip;</span><br><span class="line">  f-&gt;readable = !(omode &amp; O_WRONLY);</span><br><span class="line">  f-&gt;writable = (omode &amp; O_WRONLY) || (omode &amp; O_RDWR);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((omode &amp; O_TRUNC) &amp;&amp; ip-&gt;type == T_FILE)&#123;</span><br><span class="line">    itrunc(ip);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  iunlock(ip);</span><br><span class="line">  end_op();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="/images/1.png"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kiseki-zj.github.io/2021/10/14/MIT6.S081%20Lab8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="Kiseki">
      <meta itemprop="description" content=""开心就好啦"">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KISEKI">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/14/MIT6.S081%20Lab8/" class="post-title-link" itemprop="url">MIT6.S081 Lab8 Locks</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-14 12:00:00" itemprop="dateCreated datePublished" datetime="2021-10-14T12:00:00+08:00">2021-10-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-11-05 12:49:44" itemprop="dateModified" datetime="2021-11-05T12:49:44+08:00">2021-11-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Memory-allocator"><a href="#Memory-allocator" class="headerlink" title="Memory allocator"></a>Memory allocator</h2><p>acquire一个spinlock的时候，如果锁已被占用线程会阻塞，这种锁的争用减弱了系统的并行度，减少了操作系统的效率。执行kalloctest，可以看到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ kalloctest</span><br><span class="line">start test1</span><br><span class="line">test1 results:</span><br><span class="line">--- lock kmem/bcache stats</span><br><span class="line">lock: kmem: #fetch-and-add 83375 #acquire() 433015</span><br><span class="line">lock: bcache: #fetch-and-add 0 #acquire() 1260</span><br><span class="line">--- top 5 contended locks:</span><br><span class="line">lock: kmem: #fetch-and-add 83375 #acquire() 433015</span><br><span class="line">lock: proc: #fetch-and-add 23737 #acquire() 130718</span><br><span class="line">lock: virtio_disk: #fetch-and-add 11159 #acquire() 114</span><br><span class="line">lock: proc: #fetch-and-add 5937 #acquire() 130786</span><br><span class="line">lock: proc: #fetch-and-add 4080 #acquire() 130786</span><br><span class="line">tot= 83375</span><br><span class="line">test1 FAIL</span><br></pre></td></tr></table></figure>

<p>acquire阻塞时对kmem锁的询问达到了83375次。这个lab要求重写分配物理内存的代码，减少锁的争用。</p>
<p>思路是每个cpu分配一个freelist和一个锁，每次cpu执行kalloc或kfree时访问对应的cpu锁，这样cpu之间并行分配内存时就不会争用锁。</p>
<p>另外，当某个cpu的freelist为空时要从别的cpu的freelist里“偷取”可用的物理内存，保证这个过程不会发生死锁。</p>
<p>最开始的想法是平分每个物理页面，根据页面index来分配给对应的cpu，free时根据index还给对应的cpu的freelist。这样做结果也是正确的，但问题是NCPU是cpu的最大值固定为8，实际使用的cpu数不一定为8，make qemu时用了3个hart。</p>
<p>实际上不用这么做，因为只有cpu0会执行kinit以及freerange，一开始把所有物理内存分给cpu0即可。这样别的cpu执行kalloc时会从cpu0“偷取”物理内存，kfree时直接还给这个cpu的freelist，即谁分配就退还给谁。而且不存在的cpu对应的freelist一直为空。</p>
<blockquote>
<p>数据结构和kinit</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">freelist</span>;</span></span><br><span class="line">&#125; kmem[NCPU];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">kinit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NCPU; i++) &#123;</span><br><span class="line">    initlock(&amp;kmem[i].lock, <span class="string">&quot;kmem&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  freerange(end, (<span class="keyword">void</span>*)PHYSTOP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>kalloc时先获取对应cpu的锁，如果freelist为空，则循环所有cpu偷取可用内存，这一步也需要加锁。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">kalloc</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line">  <span class="keyword">int</span> c;</span><br><span class="line">  push_off();</span><br><span class="line">  c = cpuid();</span><br><span class="line">  pop_off();</span><br><span class="line">  acquire(&amp;kmem[c].lock);</span><br><span class="line">  r = kmem[c].freelist;</span><br><span class="line">  <span class="keyword">if</span>(r) &#123;</span><br><span class="line">    kmem[c].freelist = r-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NCPU; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i == c) <span class="keyword">continue</span>;</span><br><span class="line">      acquire(&amp;kmem[i].lock);</span><br><span class="line">      <span class="keyword">if</span> (kmem[i].freelist) &#123;</span><br><span class="line">        r = kmem[i].freelist;</span><br><span class="line">        kmem[i].freelist = r-&gt;next;</span><br><span class="line">        release(&amp;kmem[i].lock);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;kmem[i].lock);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    <span class="built_in">memset</span>((<span class="keyword">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">  release(&amp;kmem[c].lock);</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在freelist不为空的情况下不会产生锁的争用，因为只用到了本cpu的锁；但是如果需要偷取内存，就可能产生锁的争用。但由于“偷取时对应cpu正好需要kalloc”这件事概率不高，并且acquire和release之间距离比较近，所以产生争用的可能性不大，因此kalloctest时输出的tot为0.</p>
<p>如果在偷取时acquire和release之间加上 for (int i = 0;i &lt; 1000000; i++);可以看到结果是产生了争用的。</p>
<p><img src="https://pic2.zhimg.com/80/v2-89c3ed41f875fec6da034537d125bda5_720w.jpg" alt="img"></p>
<blockquote>
<p>kfree把内存还给当前cpu。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">kfree</span><span class="params">(<span class="keyword">void</span> *pa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="keyword">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  r = (struct run*)pa;</span><br><span class="line">  push_off();</span><br><span class="line">  <span class="keyword">int</span> c = cpuid();</span><br><span class="line">  pop_off();</span><br><span class="line">  acquire(&amp;kmem[c].lock);</span><br><span class="line">  r-&gt;next = kmem[c].freelist;</span><br><span class="line">  kmem[c].freelist = r;</span><br><span class="line">  release(&amp;kmem[c].lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Buffer-cache"><a href="#Buffer-cache" class="headerlink" title="Buffer cache"></a>Buffer cache</h2><p>程序访问磁盘时首先会通过bget查看块缓存bcache中有没有所需的block，如果有就无需访问磁盘，仅仅产生内存间数据交换。如果没有需要访问磁盘并且把读取到的块代替bcache的某个buf（通过LRU）。</p>
<p>xv6用了一个大锁bcache.lock保证bcache同时只有一个线程使用，毫无疑问这会导致大量的争用，这个lab要求修改bio.c的代码减少争用。</p>
<p>思路化大锁为小锁，创建多个bucket，根据block的index把对应块hash到对应bucket中。这样每次bget时只需要获取对应bucket的锁，假如多个cpu同时进入bget，但blockno hash到了不同的bucket，这种情况是可以并行的。</p>
<p>hints要求替换buf时用时间戳来实现LRU算法。</p>
<blockquote>
<p>bucket数最好是个质数减少hash冲突，总的buf数就是NBUCKET*BUCKETSZ。xv6原来的buf数是30，我这里增加了一点来尽量减少争用。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NBUCKET 13</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUCKETSZ 8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> uint ticks;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bucket</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">bufs</span>[<span class="title">BUCKETSZ</span>];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>binit初始化所有bucket的锁</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">binit</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  initlock(&amp;bcache.lock, <span class="string">&quot;bcache&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NBUCKET; i++) &#123;</span><br><span class="line">    initlock(&amp;bcache.buckets[i].lock, <span class="string">&quot;bcache.bucket&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; BUCKETSZ; j++)</span><br><span class="line">      initsleeplock(&amp;bcache.buckets[i].bufs[j].lock, <span class="string">&quot;buffer&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>bget首先根据blockno获取对应bucket的锁，如果cache中存在这个块，就更新timestamp，并且refcnt++表示当前多了一个线程对这个buf感兴趣。<br>如果没有对应块，从bucket中选取一个timestamp最小的（LRU）来替换这个块。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct buf*</span></span><br><span class="line"><span class="function"><span class="title">bget</span><span class="params">(uint dev, uint blockno)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> k = blockno % NBUCKET;</span><br><span class="line">  acquire(&amp;bcache.buckets[k].lock);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">bucket</span>* <span class="title">bkt</span> =</span> &amp;bcache.buckets[k];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span>* <span class="title">b</span>;</span></span><br><span class="line">  <span class="keyword">for</span> (b = &amp;bkt-&gt;bufs[<span class="number">0</span>]; b &lt; (struct buf*)&amp;bkt-&gt;bufs[<span class="number">0</span>] + BUCKETSZ; b++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno) &#123;</span><br><span class="line">      b-&gt;timestamp = ticks; </span><br><span class="line">      b-&gt;refcnt++;</span><br><span class="line">      release(&amp;bcache.buckets[k].lock);</span><br><span class="line">      acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  uint last = <span class="number">-1</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span>* <span class="title">ret</span> =</span> b;</span><br><span class="line">  <span class="keyword">for</span> (b = &amp;bkt-&gt;bufs[<span class="number">0</span>]; b &lt; (struct buf*)&amp;bkt-&gt;bufs[<span class="number">0</span>] + BUCKETSZ; b++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b-&gt;timestamp &lt; last &amp;&amp; b-&gt;refcnt == <span class="number">0</span>) &#123;</span><br><span class="line">      last = b-&gt;timestamp;</span><br><span class="line">      ret = b;  </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ret-&gt;dev = dev;</span><br><span class="line">  ret-&gt;blockno = blockno;</span><br><span class="line">  ret-&gt;valid = <span class="number">0</span>;</span><br><span class="line">  ret-&gt;timestamp = ticks;</span><br><span class="line">  ret-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line">  release(&amp;bcache.buckets[k].lock);</span><br><span class="line">  acquiresleep(&amp;ret-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">  panic(<span class="string">&quot;bget: no buffers&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>brelse不用再release大锁。<br>bpin和bunpin把锁改成对应bucket的锁即可。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">brelse</span><span class="params">(struct buf *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))</span><br><span class="line">    panic(<span class="string">&quot;brelse&quot;</span>);</span><br><span class="line">  b-&gt;refcnt--;</span><br><span class="line">  releasesleep(&amp;b-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">bpin</span><span class="params">(struct buf *b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> k = b-&gt;blockno % NBUCKET;</span><br><span class="line">  acquire(&amp;bcache.buckets[k].lock);</span><br><span class="line">  b-&gt;refcnt++;</span><br><span class="line">  release(&amp;bcache.buckets[k].lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">bunpin</span><span class="params">(struct buf *b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> k = b-&gt;blockno % NBUCKET;</span><br><span class="line">  acquire(&amp;bcache.buckets[k].lock);</span><br><span class="line">  b-&gt;refcnt--;</span><br><span class="line">  release(&amp;bcache.buckets[k].lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>bcache减少争用和kmem不一样，内存页面之间是没有区别的，因此kmem可以每个cpu一个锁，如果不考虑“偷取”，kmem可以达到0争用。但是bcache是所有cpu共享的，并且每个buf内容不一样不能随意分配，所以不可能做到0争用。</p>
<p>但是由于bcachetest中，不同进程不会访问同一磁盘块，并且不会同时miss cache，所以争用发生的可能性不大，结果显示tot=0.（实际上这个lab只要求tot&lt;500）</p>
<p><img src="https://pic4.zhimg.com/80/v2-79bc8d636b1fd85126eae88f8c6d2e73_720w.jpg" alt="img"></p>
<p>这里实现LRU的方法是循环遍历每个buf查看timestamp，这样的效率还不如初始链表实现的做法。hints里要求我们使用timestamp且要删除初始链表，所以我觉得lab的要求其实是要实现bucket之间的“偷取”。当当前bucket需要找替代块的时候，应该要从所有的buf中找到timestamp最小的buf替换，而不是仅仅在当前bucket找。但是我的做法已经能通过测试，就没有改进了。</p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="https://pic3.zhimg.com/80/v2-4983007f0ba5e2221c5783a478477476_720w.jpg" alt="img"></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>第2个lab测试前最好先make clean。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kiseki-zj.github.io/2021/10/12/MIT6.S081%20Lab7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="Kiseki">
      <meta itemprop="description" content=""开心就好啦"">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KISEKI">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/12/MIT6.S081%20Lab7/" class="post-title-link" itemprop="url">MIT6.S081 Lab7 Multithreading</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-12 12:00:00" itemprop="dateCreated datePublished" datetime="2021-10-12T12:00:00+08:00">2021-10-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-11-05 12:49:44" itemprop="dateModified" datetime="2021-11-05T12:49:44+08:00">2021-11-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Uthread-switching-between-threads"><a href="#Uthread-switching-between-threads" class="headerlink" title="Uthread: switching between threads"></a>Uthread: switching between threads</h2><p>这个lab要求完善一个用户态线程库，比较简单</p>
<blockquote>
<p>首先创建线程时把context的ra设置为传入的函数地址，这样第一次scheduler到这个线程可以返回到执行函数。<br>注意stack是从上往下增长的，所以sp的值初始化为对应stack的顶部。<br>实际上thread[0].stack是没有用到的，因为main线程一直使用的都是进程分配好的栈区域，其他stack被分配在data段。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> </span></span><br><span class="line"><span class="function"><span class="title">thread_create</span><span class="params">(<span class="keyword">void</span> (*func)())</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">thread</span> *<span class="title">t</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (t = all_thread; t &lt; all_thread + MAX_THREAD; t++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (t-&gt;state == FREE) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  t-&gt;state = RUNNABLE;</span><br><span class="line">  <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">  t-&gt;context.ra = (uint64)func;</span><br><span class="line">  t-&gt;context.sp = (uint64)t-&gt;<span class="built_in">stack</span>+STACK_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>sheduler函数中，找到一个RUNNABLE的线程就进行切换</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (current_thread != next_thread) &#123;         <span class="comment">/* switch threads?  */</span></span><br><span class="line">    next_thread-&gt;state = RUNNING;</span><br><span class="line">    t = current_thread;</span><br><span class="line">    current_thread = next_thread;</span><br><span class="line">    <span class="comment">/* YOUR CODE HERE</span></span><br><span class="line"><span class="comment">     * Invoke thread_switch to switch from t to next_thread:</span></span><br><span class="line"><span class="comment">     * thread_switch(??, ??);</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    thread_switch((uint64)(&amp;t-&gt;context), (uint64)(&amp;current_thread-&gt;context));</span><br><span class="line">  &#125; <span class="keyword">else</span></span><br><span class="line">    next_thread = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>thread_switch代码和swtch一样</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">thread_switch:</span><br><span class="line">	/* YOUR CODE HERE */</span><br><span class="line">        sd ra, 0(a0)</span><br><span class="line">        sd sp, 8(a0)</span><br><span class="line">        sd s0, 16(a0)</span><br><span class="line">        sd s1, 24(a0)</span><br><span class="line">        sd s2, 32(a0)</span><br><span class="line">        sd s3, 40(a0)</span><br><span class="line">        sd s4, 48(a0)</span><br><span class="line">        sd s5, 56(a0)</span><br><span class="line">        sd s6, 64(a0)</span><br><span class="line">        sd s7, 72(a0)</span><br><span class="line">        sd s8, 80(a0)</span><br><span class="line">        sd s9, 88(a0)</span><br><span class="line">        sd s10, 96(a0)</span><br><span class="line">        sd s11, 104(a0)</span><br><span class="line"></span><br><span class="line">        ld ra, 0(a1)</span><br><span class="line">        ld sp, 8(a1)</span><br><span class="line">        ld s0, 16(a1)</span><br><span class="line">        ld s1, 24(a1)</span><br><span class="line">        ld s2, 32(a1)</span><br><span class="line">        ld s3, 40(a1)</span><br><span class="line">        ld s4, 48(a1)</span><br><span class="line">        ld s5, 56(a1)</span><br><span class="line">        ld s6, 64(a1)</span><br><span class="line">        ld s7, 72(a1)</span><br><span class="line">        ld s8, 80(a1)</span><br><span class="line">        ld s9, 88(a1)</span><br><span class="line">        ld s10, 96(a1)</span><br><span class="line">        ld s11, 104(a1)</span><br><span class="line">	</span><br><span class="line">	ret    /* return to ra */</span><br></pre></td></tr></table></figure>

<p>另外需要定义struct context并作为thread类的一个成员变量</p>
<h2 id="Using-threads"><a href="#Using-threads" class="headerlink" title="Using threads"></a>Using threads</h2><p>这个lab展示了如何使用linux pthread线程库。程序定义了一个链式哈希表并向其中put 10000个kv数据对。创建多个线程执行put操作时，效率会有所提高但会产生miss的情况，也就是一些key并没有成功写入hash table。原因是线程对hash table的操作没有加锁。例如线程t1要对其中某个链表进行e1的头插，当执行完 e-&gt;next = n后切换到线程t2，线程t2同样要对该链表进行e2的头插，也运行到e-&gt;next = n。</p>
<p>这时候有两种情况：t1先执行 *p = e，这样就丢失了e2这个数据；t2先执行 *p = e;，这样会丢失e1.所以需要对共享数据加锁。最简单的方法是对整个hash table加锁，每次put前都需要acquire这个锁，但这样效率很低，所有put操作相当于都串行操作了。hints告诉我们实际上只要对hash table的每个bucket加锁就行，因为不同bucket的插入操作彼此互不影响。</p>
<p>代码的话比较简单，主要是熟悉pthread库的mutex锁的使用。</p>
<blockquote>
<p>lock定义了每个bucket的锁，put时加锁即可。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> lock[NBUCKET];</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">static</span> </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = key % NBUCKET;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// is the key already present?</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">entry</span> *<span class="title">e</span> =</span> <span class="number">0</span>;</span><br><span class="line">  pthread_mutex_lock(&amp;lock[i]);</span><br><span class="line">  <span class="keyword">for</span> (e = table[i]; e != <span class="number">0</span>; e = e-&gt;next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (e-&gt;key == key)</span><br><span class="line">      <span class="keyword">break</span>;i</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(e)&#123;</span><br><span class="line">    <span class="comment">// update the existing key.</span></span><br><span class="line">    e-&gt;value = value;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// the new is new.</span></span><br><span class="line">    insert(key, value, &amp;table[i], table[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_mutex_unlock(&amp;lock[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Barrier"><a href="#Barrier" class="headerlink" title="Barrier"></a>Barrier</h2><p>程序开始创建了多个线程，要求每个线程都运行到barrier函数就sleep，直到所有线程都到达barrier函数才能被wakeup。这个lab也比较简单，主要是熟悉pthread的条件变量，本质上和xv6的sleep&amp;wakeup一样。</p>
<blockquote>
<p>barrier_mutex用来保护条件变量nthread，当nthread满足条件后wakeup所有等待barrier_cond这个channel的线程。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> </span></span><br><span class="line"><span class="function"><span class="title">barrier</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// YOUR CODE HERE</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Block until all threads have called barrier() and</span></span><br><span class="line">  <span class="comment">// then increment bstate.round.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  pthread_mutex_lock(&amp;bstate.barrier_mutex);</span><br><span class="line">  bstate.nthread++;</span><br><span class="line">  <span class="keyword">if</span> (bstate.nthread == nthread) &#123;</span><br><span class="line">    bstate.nthread = <span class="number">0</span>;</span><br><span class="line">    bstate.round++;</span><br><span class="line">    pthread_cond_broadcast(&amp;bstate.barrier_cond);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    pthread_cond_wait(&amp;bstate.barrier_cond, &amp;bstate.barrier_mutex);</span><br><span class="line">  &#125;</span><br><span class="line">  pthread_mutex_unlock(&amp;bstate.barrier_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>结果</p>
<p><img src="https://pic2.zhimg.com/80/v2-0e04ba414726a4cb23de4791fb4f4ca9_720w.jpg" alt="img"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kiseki-zj.github.io/2021/10/09/MIT6.S081%20Lab6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="Kiseki">
      <meta itemprop="description" content=""开心就好啦"">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KISEKI">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/09/MIT6.S081%20Lab6/" class="post-title-link" itemprop="url">MIT6.S081 Lab6 Cow</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-09 12:00:00" itemprop="dateCreated datePublished" datetime="2021-10-09T12:00:00+08:00">2021-10-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-11-05 12:49:44" itemprop="dateModified" datetime="2021-11-05T12:49:44+08:00">2021-11-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="COW-fork"><a href="#COW-fork" class="headerlink" title="COW fork"></a><strong>COW fork</strong></h2><p>fork的时候xv6会为子进程立刻分配所需的物理内存，并把父进程的用户内存复制过去。这样造成了时空上的浪费。写时复制指的是fork时不立刻分配物理内存，而是父子进程共用父进程的地址空间。</p>
<p>实现这个功能主要要实现3个部分：</p>
<p>1.fork时将子进程地址空间逐页map到和父进程一样的地址空间，并且把父子进程页表项设置为不可写。</p>
<p>2.当某个进程要写一个COW map的不可写页时，此时这个进程就不能和其他进程共享这一页了，需要另外开辟新的物理内存并map，这一部分通过处理page fault实现。</p>
<p>3.注意物理页free的时机，如果某一物理页被多个进程共享，那么即使其中某一个进程不再使用它，它也不能被free。当最后一个使用它的进程free这一页时才真正释放。</p>
<p>第一个部分在uvmcopy函数中实现，fork会调用uvmcopy来把父进程地址空间复制给子进程：</p>
<blockquote>
<p>在原uvmcopy的基础上删除了分配内存的过程。逐页地，把父进程的物理地址map到子进程的页表中去。<br>注意flag的设置，要把PTE_W位清除，并且set了flag中的保留位，用于指明这是一个由于COW fork而导致无法write的页。这是有必要的，因为操作系统不能保证用户程序不是恶意的，用户程序可能写一个它本不该写的页，如果不判断是否为COW map的页，到pagefault处理完用户程序就变得能够写这个页，这是不安全的。pte的flag如下图。<br>incref用于增加pa对应页的ref count，下面会说</p>
</blockquote>
<p><img src="https://pic2.zhimg.com/80/v2-707f039c178ba7db7fa04330baa66541_720w.jpg" alt="img"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">uvmcopy</span><span class="params">(<span class="keyword">pagetable_t</span> old, <span class="keyword">pagetable_t</span> <span class="keyword">new</span>, uint64 sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">pte_t</span> *pte;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line">  uint flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: pte should exist&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: page not present&quot;</span>);</span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line">    flags = PTE_FLAGS(*pte);</span><br><span class="line">    flags = (flags &amp; ~PTE_W) | PTE_RESERVE;</span><br><span class="line">    *pte = (~(*pte ^ ~PTE_W)) | PTE_RESERVE;</span><br><span class="line">    <span class="keyword">if</span> (mappages(<span class="keyword">new</span>, i, PGSIZE, (uint64)pa, flags) != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">    incref(pa);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  err:</span><br><span class="line">   uvmunmap(<span class="keyword">new</span>, <span class="number">0</span>, i / PGSIZE, <span class="number">1</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>第二部分实现物理内存的分配，有两种情况会导致写共享页：用户程序主动写和内核缓存复制到用户空间（如read系统调用）。第一种情况需要在usertrap中处理pagefault：</p>
<blockquote>
<p>首先判断用户要写的这一页是否为COWmap页，如果不是则杀死进程，然后分配物理内存并map</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">... </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (r_scause() == <span class="number">15</span>) &#123;</span><br><span class="line">      uint64 va = r_stval();</span><br><span class="line">      <span class="keyword">pte_t</span> *pte = walk(p-&gt;pagetable, va, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (!(PTE_FLAGS(*pte)&amp;PTE_RESERVE)) &#123;</span><br><span class="line">        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        va = PGROUNDDOWN(va);</span><br><span class="line">        uint64 ka = (uint64)kalloc();</span><br><span class="line">        <span class="keyword">if</span> (ka == <span class="number">0</span>) &#123;</span><br><span class="line">          p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          uint flags = PTE_FLAGS(*pte);</span><br><span class="line">          flags = flags &amp; ~PTE_RESERVE;</span><br><span class="line">          uint64 pa = walkaddr(p-&gt;pagetable, va);</span><br><span class="line">          memmove((<span class="keyword">void</span>*)ka, (<span class="keyword">void</span>*)pa, PGSIZE);</span><br><span class="line">          uvmunmap(p-&gt;pagetable, va, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">          mappages(p-&gt;pagetable, va, <span class="number">1</span>, ka, flags | PTE_W); </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>第二种情况在copyout中实现，和上面差不多：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">copyout</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable, uint64 dstva, <span class="keyword">char</span> *src, uint64 len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uint64 n, va0, pa0;</span><br><span class="line">  <span class="keyword">if</span> (dstva &gt; MAXVA - len) <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">  <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    va0 = PGROUNDDOWN(dstva);</span><br><span class="line">    <span class="keyword">pte_t</span>* pte = walk(pagetable, va0, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pte == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(PTE_FLAGS(*pte) &amp; PTE_W)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!(PTE_FLAGS(*pte) &amp; PTE_RESERVE)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      uint64 va = va0;</span><br><span class="line">      uint64 ka = (uint64)kalloc();</span><br><span class="line">      <span class="keyword">if</span> (ka == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        uint flags = PTE_FLAGS(*pte);</span><br><span class="line">        flags = flags &amp; ~PTE_RESERVE;</span><br><span class="line">        uint64 pa = walkaddr(pagetable, va);</span><br><span class="line">        <span class="keyword">if</span> (pa == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        memmove((<span class="keyword">void</span>*)ka, (<span class="keyword">void</span>*)pa, PGSIZE);</span><br><span class="line">        uvmunmap(pagetable, va, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        mappages(pagetable, va, <span class="number">1</span>, ka, flags | PTE_W); </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pa0 = walkaddr(pagetable, va0);</span><br><span class="line">    <span class="keyword">if</span>(pa0 == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    n = PGSIZE - (dstva - va0);</span><br><span class="line">    <span class="keyword">if</span>(n &gt; len)</span><br><span class="line">      n = len;</span><br><span class="line">    memmove((<span class="keyword">void</span> *)(pa0 + (dstva - va0)), src, n);</span><br><span class="line"></span><br><span class="line">    len -= n;</span><br><span class="line">    src += n;</span><br><span class="line">    dstva = va0 + PGSIZE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后是free物理页面的问题，我们需要一个数据结构保存每个页面的引用次数ref count，当一个页面引用次数到达0时才可真正释放，数据结构设置在kalloc.c中：</p>
<blockquote>
<p>因为最大进程数NPROC为64，所以用1个字节保存引用数足以。每个页面用右移12位的页面序号作为index。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">uint8 refcount[PHYSTOP / PGSIZE];</span><br><span class="line">...</span><br><span class="line">void incref(uint64 va) &#123;</span><br><span class="line">  refcount[va/PGSIZE]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>每次调用kfree时先减引用数，引用数为0再真正释放：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">kfree</span><span class="params">(<span class="keyword">void</span> *pa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(((uint64)pa % PGSIZE) != <span class="number">0</span> || (<span class="keyword">char</span>*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)</span><br><span class="line">    panic(<span class="string">&quot;kfree&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill with junk to catch dangling refs.</span></span><br><span class="line">  <span class="keyword">if</span> (--refcount[(uint64)pa / PGSIZE] &gt; <span class="number">0</span>) </span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  <span class="built_in">memset</span>(pa, <span class="number">1</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  r = (struct run*)pa;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r-&gt;next = kmem.freelist;</span><br><span class="line">  kmem.freelist = r;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>初始化的时候在freerange把refcount设置为0（这里设置为1再kfree就变成0了）。每次kalloc即初次分配时把refcount设置为1：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">freerange</span><span class="params">(<span class="keyword">void</span> *pa_start, <span class="keyword">void</span> *pa_end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *p;</span><br><span class="line">  p = (<span class="keyword">char</span>*)PGROUNDUP((uint64)pa_start);</span><br><span class="line">  <span class="keyword">for</span>(; p + PGSIZE &lt;= (<span class="keyword">char</span>*)pa_end; p += PGSIZE)</span><br><span class="line">  &#123;</span><br><span class="line">    refcount[(uint64)p / PGSIZE] = <span class="number">1</span>;</span><br><span class="line">    kfree(p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *</span></span><br><span class="line"><span class="function"><span class="title">kalloc</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;kmem.lock);</span><br><span class="line">  r = kmem.freelist;</span><br><span class="line">  <span class="keyword">if</span>(r)</span><br><span class="line">    kmem.freelist = r-&gt;next;</span><br><span class="line">  release(&amp;kmem.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(r) &#123;</span><br><span class="line">    <span class="built_in">memset</span>((<span class="keyword">char</span>*)r, <span class="number">5</span>, PGSIZE); <span class="comment">// fill with junk</span></span><br><span class="line">    refcount[(uint64)r / PGSIZE] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">void</span>*)r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="https://pic4.zhimg.com/80/v2-16198edaae5d2659e976b78ef9dfe693_720w.jpg" alt="img"></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>debug的时候可以在lab3 vmprint基础上输出一下flag以及对应的refcount查看有没有错误。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kiseki-zj.github.io/2021/04/24/MIT6.S081%20Lab5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="Kiseki">
      <meta itemprop="description" content=""开心就好啦"">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KISEKI">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/24/MIT6.S081%20Lab5/" class="post-title-link" itemprop="url">MIT6.S081 Lab5 Lazy Allocation</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-24 12:00:00" itemprop="dateCreated datePublished" datetime="2021-04-24T12:00:00+08:00">2021-04-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-11-05 12:49:44" itemprop="dateModified" datetime="2021-11-05T12:49:44+08:00">2021-11-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="实验前准备"><a href="#实验前准备" class="headerlink" title="实验前准备"></a>实验前准备</h2><blockquote>
<p>阅读xv6 book chapter5，尤其是page fault的部分</p>
</blockquote>
<h2 id="Eliminate-allocation-from-sbrk"><a href="#Eliminate-allocation-from-sbrk" class="headerlink" title="Eliminate allocation from sbrk()"></a>Eliminate allocation from sbrk()</h2><p>lazy allocation就是在用户程序通过sbrk系统调用申请内存空间时，并不当场给它分配内存，而仅仅是增加p-&gt;sz。当用户程序使用申请的内存时会产生page fault而trap到内核态，此时再分配内存。</p>
<p>第一个实验就是把sbrk中分配内存的过程去掉，观察产生的结果：</p>
<p><img src="https://pic2.zhimg.com/80/v2-caf0f6b5fd4f81ed375c9cfd9eb89da9_720w.jpg" alt="img"></p>
<p>这里去掉了分配内存的部分，增加了proc的sz</p>
<p><img src="https://pic3.zhimg.com/80/v2-0b9bf1ec112ed8cf8508f97fff8fbff2_720w.jpg" alt="img"></p>
<p>之后运行xv6，执行echo hi会产生page fault。这是因为执行echo hi时系统会使用sbrk分配一些内存，当访问到这一部分内存时，由于我们修改了的sbrk并没有真正分配物理内存，就会导致访问的页面不存在。</p>
<p>这里的输出包含一些信息：</p>
<blockquote>
<p>这里输出了SCAUSE寄存器内容，我们可以看到它的值是15，表明这是一个store page fault。<br>产生page fault的进程pid是3<br>我们还可以看到SEPC寄存器的值，是0x12a4，表明产生page fault的指令的地址。<br>最后还可以看到出错的虚拟内存地址，也就是STVAL寄存器的内容，是0x4008。</p>
</blockquote>
<p>产生page fault后看到有个panic。这是因为产生页面中断后，内核的做法会杀死当前进程（在usertrap（）中）。进程退出的时候需要free页表，free页表首先会把页表对应项unmap再free物理内存。unmap的时候是从虚拟地址0到p-&gt;sz逐页unmap的，在我们修改的sbrk函数中增加了p-&gt;sz，对应的内存并没有分配并map。因此在uvmunmap的逻辑中就会panic。</p>
<h2 id="Lazy-allocation"><a href="#Lazy-allocation" class="headerlink" title="Lazy allocation"></a>Lazy allocation</h2><p>在trap.c中加上处理page fault的逻辑，使得echo hi能够正常运行。</p>
<p>比较简单，仿照课程视频的就行：</p>
<blockquote>
<p>在usertrap中处理page fault，如果kalloc失败或者访问的地址va不合法，杀死进程</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (r_scause() == <span class="number">13</span> || r_scause() == <span class="number">15</span>) &#123;</span><br><span class="line">    uint64 va = r_stval();</span><br><span class="line">    uint64 ka = (uint64)kalloc();</span><br><span class="line">    <span class="keyword">if</span> (ka == <span class="number">0</span>) &#123;</span><br><span class="line">      p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(isValid(p, va) == <span class="number">0</span>) &#123;</span><br><span class="line">      kfree((<span class="keyword">void</span>*)ka);</span><br><span class="line">      p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">memset</span>((<span class="keyword">void</span>*)ka, <span class="number">0</span>, PGSIZE);</span><br><span class="line">      <span class="keyword">if</span> (mappages(p-&gt;pagetable, PGROUNDDOWN(va), PGSIZE, ka, PTE_U | PTE_R | PTE_W) != <span class="number">0</span>) &#123;</span><br><span class="line">        kfree((<span class="keyword">void</span>*)ka);</span><br><span class="line">        p-&gt;killed = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>判断va是否合法：如果va大于sz或者访问了guard page，则不合法。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isValid</span><span class="params">(struct proc *p, uint64 va)</span> </span>&#123;</span><br><span class="line">  uint64 stackbase = PGROUNDDOWN(p-&gt;trapframe-&gt;sp);</span><br><span class="line">  <span class="keyword">if</span> (va &gt;= p-&gt;sz || (va &lt; stackbase+PGSIZE)) </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>处理unmap的panic：如果某一页并没有分配或并没有map，那么可以跳过这一页而不是panic</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">for</span>(a = va; a &lt; va + npages*PGSIZE; a += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(pagetable, a, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      <span class="comment">//panic(&quot;uvmunmap: walk&quot;);</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      <span class="comment">//panic(&quot;uvmunmap: not mapped&quot;);</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>(PTE_FLAGS(*pte) == PTE_V)</span><br><span class="line">      panic(<span class="string">&quot;uvmunmap: not a leaf&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(do_free)&#123;</span><br><span class="line">      uint64 pa = PTE2PA(*pte);</span><br><span class="line">      kfree((<span class="keyword">void</span>*)pa);</span><br><span class="line">    &#125;</span><br><span class="line">    *pte = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="Lazytests-and-Usertests"><a href="#Lazytests-and-Usertests" class="headerlink" title="Lazytests and Usertests"></a>Lazytests and Usertests</h2><p>完善lazy allocation，保证：</p>
<p>1.处理sbrk的负数参数</p>
<p>2.如果va大于sz，杀死进程</p>
<p>3.在fork中正确处理父进程到子进程的复制过程</p>
<p>4.处理这样一种情况：系统调用（比如write）传入的虚拟地址对应的内存并没有被分配。</p>
<p>5.物理内存不足时杀死进程</p>
<p>6.处理va在user stack以下的情况</p>
<p>其中2，5，6在上一个实验中已经完成了。isValid函数即处理了2和6。</p>
<blockquote>
<p>sys_sbrk()中处理负数参数的情况<br>如果传入的n为负数，则把p-&gt;sz+n到p-&gt;sz的地址范围都dealloc<br>这里加上了两个判断，传入sbrk的参数不合法（即sz+n大于trapframe或小于user stack），sbrk失败，返回-1.<br>之前修改过unmap的部分，dealloc的时候如果某一页不存在，不会panic而是会跳过这一页。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64</span></span><br><span class="line"><span class="function"><span class="title">sys_sbrk</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> addr;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  addr = myproc()-&gt;sz;</span><br><span class="line">  uint64 stackbase = PGROUNDDOWN(p-&gt;trapframe-&gt;sp);</span><br><span class="line">  <span class="keyword">if</span>(argint(<span class="number">0</span>, &amp;n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    p-&gt;sz += n;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;sz &gt; MAXVA<span class="number">-2</span>*PGSIZE)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;sz &lt; stackbase+PGSIZE-n) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> p-&gt;sz = uvmdealloc(p-&gt;pagetable, p-&gt;sz, p-&gt;sz + n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在fork时会调用uvmcopy复制一份父进程的内存，在lazy allocation中可能0-&gt;sz中有部分没有真正分配，在uvmcopy中就会导致panic。累次uvmunmap，修改uvmcopy使得在页面不存在时跳过这一页。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      <span class="comment">//panic(&quot;uvmcopy: pte should exist&quot;);</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      <span class="comment">//panic(&quot;uvmcopy: page not present&quot;);</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line">    flags = PTE_FLAGS(*pte);</span><br><span class="line">    <span class="keyword">if</span>((mem = kalloc()) == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    memmove(mem, (<span class="keyword">char</span>*)pa, PGSIZE);</span><br><span class="line">    <span class="keyword">if</span>(mappages(<span class="keyword">new</span>, i, PGSIZE, (uint64)mem, flags) != <span class="number">0</span>)&#123;</span><br><span class="line">      kfree(mem);</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>处理第4种情况，即系统调用（比如write）传入的虚拟地址对应的内存并没有被分配。<br>首先搞清楚函数执行流程，在调用write后系统trap到内核态，执行copyin来把用户程序va处的内容复制到内核空间，此时若va处并未分配内存，walkaddr会返回0导致系统调用失败。因此我们要做的就是在walkaddr中分配内存。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64</span></span><br><span class="line"><span class="function"><span class="title">walkaddr</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable, uint64 va)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">pte_t</span> *pte;</span><br><span class="line">  uint64 pa;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="keyword">if</span>(va &gt;= MAXVA)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  pte = walk(pagetable, va, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(pte == <span class="number">0</span> || (*pte &amp; PTE_V) == <span class="number">0</span>) &#123;</span><br><span class="line">    uint64 ka = (uint64)kalloc();</span><br><span class="line">    <span class="keyword">if</span> (ka == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (isValid(p, va) == <span class="number">0</span>) &#123;</span><br><span class="line">      kfree((<span class="keyword">void</span>*)ka);              <span class="comment">//注意这里也要kfree，不然会导致内存泄漏</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">memset</span>((<span class="keyword">void</span>*)ka, <span class="number">0</span>, PGSIZE);</span><br><span class="line">      <span class="keyword">if</span> (mappages(p-&gt;pagetable, PGROUNDDOWN(va), PGSIZE, ka, PTE_U | PTE_R | PTE_W) != <span class="number">0</span>) &#123;</span><br><span class="line">        kfree((<span class="keyword">void</span>*)ka);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> ka;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>((*pte &amp; PTE_U) == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  pa = PTE2PA(*pte);</span><br><span class="line">  <span class="keyword">return</span> pa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p><img src="https://pic2.zhimg.com/80/v2-4625c42a0a109262f033de943e938a39_720w.jpg" alt="img"></p>
<h2 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h2><p>usertests失败的时候可以看看test代码是怎么写的从而定位错误。</p>
<p>测试usertests前记得make clean一下，不然会导致部分test创建文件失败。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kiseki-zj.github.io/2021/04/16/MIT6.S081%20Lab4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="Kiseki">
      <meta itemprop="description" content=""开心就好啦"">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KISEKI">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/16/MIT6.S081%20Lab4/" class="post-title-link" itemprop="url">MIT6.S081 Lab4 Traps</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-16 12:00:00" itemprop="dateCreated datePublished" datetime="2021-04-16T12:00:00+08:00">2021-04-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-11-05 12:49:44" itemprop="dateModified" datetime="2021-11-05T12:49:44+08:00">2021-11-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="实验前准备"><a href="#实验前准备" class="headerlink" title="实验前准备"></a>实验前准备</h2><blockquote>
<p>阅读trap.c，trampoline.s</p>
</blockquote>
<h2 id="RISC-V-assembly"><a href="#RISC-V-assembly" class="headerlink" title="RISC-V assembly"></a>RISC-V assembly</h2><p>回答几个问题，阅读call.c和它的汇编代码理解函数的calling conventions即可</p>
<blockquote>
<p>call.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/param.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x+<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> g(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, f(<span class="number">8</span>)+<span class="number">1</span>, <span class="number">13</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>call.asm</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">int g(int x) &#123;</span><br><span class="line">   0:	1141                	addi	sp,sp,-16</span><br><span class="line">   2:	e422                	sd	s0,8(sp)</span><br><span class="line">   4:	0800                	addi	s0,sp,16</span><br><span class="line">  return x+3;</span><br><span class="line">&#125;</span><br><span class="line">   6:	250d                	addiw	a0,a0,3</span><br><span class="line">   8:	6422                	ld	s0,8(sp)</span><br><span class="line">   a:	0141                	addi	sp,sp,16</span><br><span class="line">   c:	8082                	ret</span><br><span class="line"></span><br><span class="line">000000000000000e &lt;f&gt;:</span><br><span class="line"></span><br><span class="line">int f(int x) &#123;</span><br><span class="line">   e:	1141                	addi	sp,sp,-16</span><br><span class="line">  10:	e422                	sd	s0,8(sp)</span><br><span class="line">  12:	0800                	addi	s0,sp,16</span><br><span class="line">  return g(x);</span><br><span class="line">&#125;</span><br><span class="line">  14:	250d                	addiw	a0,a0,3</span><br><span class="line">  16:	6422                	ld	s0,8(sp)</span><br><span class="line">  18:	0141                	addi	sp,sp,16</span><br><span class="line">  1a:	8082                	ret</span><br><span class="line"></span><br><span class="line">000000000000001c &lt;main&gt;:</span><br><span class="line"></span><br><span class="line">void main(void) &#123;</span><br><span class="line">  1c:	1141                	addi	sp,sp,-16</span><br><span class="line">  1e:	e406                	sd	ra,8(sp)</span><br><span class="line">  20:	e022                	sd	s0,0(sp)</span><br><span class="line">  22:	0800                	addi	s0,sp,16</span><br><span class="line">  printf(&quot;%d %d\n&quot;, f(8)+1, 13);</span><br><span class="line">  24:	4635                	li	a2,13</span><br><span class="line">  26:	45b1                	li	a1,12</span><br><span class="line">  28:	00000517          	auipc	a0,0x0</span><br><span class="line">  2c:	7b850513          	addi	a0,a0,1976 # 7e0 &lt;malloc+0xea&gt;</span><br><span class="line">  30:	00000097          	auipc	ra,0x0</span><br><span class="line">  34:	608080e7          	jalr	1544(ra) # 638 &lt;printf&gt;</span><br><span class="line">  exit(0);</span><br><span class="line">  38:	4501                	li	a0,0</span><br><span class="line">  3a:	00000097          	auipc	ra,0x0</span><br><span class="line">  3e:	276080e7          	jalr	630(ra) # 2b0 &lt;exit&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Q1.哪个寄存器保存函数参数，例如哪个保存参数13?</p>
</blockquote>
<p>A：a0，a1，a2…保存传入的参数，13保存在a2中</p>
<blockquote>
<p>Q2.哪里调用了函数f和g？</p>
</blockquote>
<p>A：没有调用，编译器把两个函数内联了。</p>
<blockquote>
<p>Q3.函数printf的地址？</p>
</blockquote>
<p>A：观察汇编代码有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">30:	00000097          	auipc	ra,0x0</span><br><span class="line">34:	608080e7          	jalr	1544(ra) # 638 &lt;printf&gt;</span><br></pre></td></tr></table></figure>

<p>auipc的作用是把立即数左移12位，低12位补0，和pc相加赋给指定寄存器。这里立即数是0，指定寄存器是ra，即ra=pc=0x30=48。jalr作用是跳转到立即数+指定寄存器处并且把ra的值+8。因此jalr会跳转到1544+48=1592=0x638处，观察汇编代码发现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0000000000000638 &lt;printf&gt;:</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">printf(const char *fmt, ...)</span><br><span class="line">&#123;</span><br><span class="line"> 638:	711d                	addi	sp,sp,-96</span><br><span class="line"> 63a:	ec06                	sd	ra,24(sp)</span><br><span class="line"> 63c:	e822                	sd	s0,16(sp)</span><br><span class="line"> 63e:	1000                	addi	s0,sp,32</span><br><span class="line"> 640:	e40c                	sd	a1,8(s0)</span><br><span class="line"> 642:	e810                	sd	a2,16(s0)</span><br></pre></td></tr></table></figure>

<p>确实在0x638</p>
<blockquote>
<p>Q4.在printf之后ra的值？</p>
</blockquote>
<p>A.如上述，为0x30+8=0x38，用gdb也可以看到</p>
<p><img src="https://pic1.zhimg.com/80/v2-7f3932002f682a177fe484725656a190_720w.jpg" alt="img"></p>
<p>执行完jalr后ra从0x30变为0x38</p>
<blockquote>
<p>Q5.运行以下代码，输出是什么？这个输出基于riscv是小端保存，如果是大端保存，怎么设置i才能获得相同输出？</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0x00646c72</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;H%x Wo%s&quot;</span>, <span class="number">57616</span>, &amp;i);</span><br></pre></td></tr></table></figure>

<p>A：输出为HE110 World</p>
<p>因为riscv为小端存储，从&amp;i开始字节分别为0x72，0x6c，0x64， 0x00.分别对应’r’,’l’,’d’，’0’的ascii码，0x00作为字符串结束标志。</p>
<p>57616=0xE110</p>
<p>i应该设置为0x726c6400</p>
<blockquote>
<p>Q6.运行printf(“x=%d y=%d”, 3);在y=后面输出什么？为什么会这样？</p>
</blockquote>
<p>A：输出y=1。取决于寄存器a2（第3个参数）的值。</p>
<h2 id="Backtrace"><a href="#Backtrace" class="headerlink" title="Backtrace"></a>Backtrace</h2><p>要求完成一个backtrace函数，在系统调用sys_sleep里调用这个函数，使其从下往上逐一输出内核栈各个stackframe的ra的值。</p>
<p>主要是弄懂调用函数的stack frame的结构，如下图：</p>
<p><img src="https://pic4.zhimg.com/80/v2-4351f298147c4da1f1b72aef8db25093_720w.jpg" alt="img"></p>
<p>sp指向当前frame底部（栈是从上往下增长），fp指向当前frame顶部。栈顶部保存了函数返回地址ra以及上个frame的fp。具体可以看任意一个函数的汇编代码：</p>
<p><img src="https://pic4.zhimg.com/80/v2-03e9232fd2cdaa8b6cae56499e39ac6b_720w.jpg" alt="img"></p>
<p>一个函数在开始执行时会把ra，s0（即fp）的值压栈，然后保存一些寄存器的值，如果参数过多也会把参数保存在栈里，还会保存局部变量。</p>
<p>backtrace的实现比较简单，模拟函数返回的步骤，输出ra（fp-8），然后找到上一个frame的fp（fp-16），以此类推。注意要求只输出内核态的frame信息，fp如果跳出内核栈的范围到了用户空间循环就要停止了。</p>
<blockquote>
<p>backtrace()</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrace</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  uint64 fp = r_fp();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    uint64 *ra_addr = (uint64*)(fp - <span class="number">8</span>);</span><br><span class="line">    uint64 *fp_addr = (uint64*)(fp - <span class="number">16</span>);</span><br><span class="line">    fp = *fp_addr;</span><br><span class="line">    <span class="comment">//printf(&quot;fp=%p\n&quot;, *fp_addr);</span></span><br><span class="line">    <span class="keyword">if</span> (PGROUNDUP(fp) != p-&gt;kstack+PGSIZE) </span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, *ra_addr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Alarm"><a href="#Alarm" class="headerlink" title="Alarm"></a>Alarm</h2><p>实现系统调用sigalarm(n, fn)，执行这个系统调用之后，用户程序在执行的时候能够每隔n个ticks执行一次用户态函数fn。</p>
<p>riscv收到timer trap的情况有两种，在用户态收到trap和在内核态收到trap，分别会执行usertrap和kerneltrap处理函数。实验要求是在用户态收到n个ticks后执行函数，不用修改kerneltrap的代码。</p>
<p>实验分两个步骤。test0要求程序执行了fn即可，不用管控制流有没有正常返回以及寄存器的值是否变动，test1和test2要求程序在执行fn后能够通过编写的系统调用sigreturn返回到产生trap的用户代码处，并且程序上下文没有改变。</p>
<blockquote>
<p>proc.h<br>给struct添加几个部分，包括需要执行的用户态函数p-&gt;handler，执行函数的间隔p-&gt;interval，距离上一次执行handler后已经产生的tick数p-&gt;tick（在allocproc处初始化为0）。<br>然后是用户态产生trap时的所有寄存器的值。由于执行handler时可能改变某些寄存器，再返回到原先的代码处时需要恢复现场。<br>p-&gt;flag用于判断当前时钟中断是否是在执行handler时产生的，如果是，则不需要执行handler。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">struct proc &#123;</span><br><span class="line">  struct spinlock lock;</span><br><span class="line"></span><br><span class="line">  // p-&gt;lock must be held when using these:</span><br><span class="line">  enum procstate state;        // Process state</span><br><span class="line">  struct proc *parent;         // Parent process</span><br><span class="line">  void *chan;                  // If non-zero, sleeping on chan</span><br><span class="line">  int killed;                  // If non-zero, have been killed</span><br><span class="line">  int xstate;                  // Exit status to be returned to parent&#x27;s wait</span><br><span class="line">  int pid;                     // Process ID</span><br><span class="line"></span><br><span class="line">  // these are private to the process, so p-&gt;lock need not be held.</span><br><span class="line">  uint64 kstack;               // Virtual address of kernel stack</span><br><span class="line">  uint64 sz;                   // Size of process memory (bytes)</span><br><span class="line">  pagetable_t pagetable;       // User page table</span><br><span class="line">  struct trapframe *trapframe; // data page for trampoline.S</span><br><span class="line">  struct context context;      // swtch() here to run process</span><br><span class="line">  struct file *ofile[NOFILE];  // Open files</span><br><span class="line">  struct inode *cwd;           // Current directory</span><br><span class="line">  char name[16];               // Process name (debugging)</span><br><span class="line">  int interval;</span><br><span class="line">  uint64 handler;</span><br><span class="line">  int tick;</span><br><span class="line">  uint64 u_epc;</span><br><span class="line">  uint64 u_ra;</span><br><span class="line">  uint64 u_sp;</span><br><span class="line">  uint64 u_gp;</span><br><span class="line">  uint64 u_tp;</span><br><span class="line">  uint64 u_t0;</span><br><span class="line">  uint64 u_t1;</span><br><span class="line">  uint64 u_t2;</span><br><span class="line">  uint64 u_s0;</span><br><span class="line">  uint64 u_s1;</span><br><span class="line">  uint64 u_a0;</span><br><span class="line">  uint64 u_a1;</span><br><span class="line">  uint64 u_a2;</span><br><span class="line">  uint64 u_a3;</span><br><span class="line">  uint64 u_a4;</span><br><span class="line">  uint64 u_a5;</span><br><span class="line">  uint64 u_a6;</span><br><span class="line">  uint64 u_a7;</span><br><span class="line">  uint64 u_s2;</span><br><span class="line">  uint64 u_s3;</span><br><span class="line">  uint64 u_s4;</span><br><span class="line">  uint64 u_s5;</span><br><span class="line">  uint64 u_s6;</span><br><span class="line">  uint64 u_s7;</span><br><span class="line">  uint64 u_s8;</span><br><span class="line">  uint64 u_s9;</span><br><span class="line">  uint64 u_s10;</span><br><span class="line">  uint64 u_s11;</span><br><span class="line">  uint64 u_t3;</span><br><span class="line">  uint64 u_t4;</span><br><span class="line">  uint64 u_t5;</span><br><span class="line">  uint64 u_t6;</span><br><span class="line">  uint64 flag;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在kernel目录新建alarm.c用于编写所需的两个系统调用。<br>sigalarm在调用时设置好proc的inteval以及handler的值，注意传入的函数地址也可以为0（因为在用户空间，代码段从虚拟地址0开始）。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64 <span class="title">sys_sigalarm</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> itv;</span><br><span class="line">    uint64 handler;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">    argint(<span class="number">0</span>, &amp;itv);</span><br><span class="line">    argaddr(<span class="number">1</span>, &amp;handler);</span><br><span class="line">    p-&gt;interval = itv;</span><br><span class="line">    p-&gt;handler = handler;</span><br><span class="line">    p-&gt;flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>usertrap()：<br>在每次产生时钟中断时p-&gt;tick加1，然后判断是否等于intervel。如果不等于就当成普通的时钟中断处理，如果等于并且当前用户态代码不在执行handler（flag==0）则执行以下操作：<br>把所有寄存器的值保存，把trampframe-&gt;epc的值设置为handler，这样一来在usertrapret时就会把epc设置为handler的第一句代码处，userret（trampoline.S）时执行sret就会返回到handler，从而执行handler。记住把flag设为1.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(which_dev == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">//printf(&quot;ticks=%d\n&quot;, ticks);</span></span><br><span class="line">    p-&gt;tick++;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;tick == p-&gt;interval) &#123;</span><br><span class="line">      <span class="keyword">if</span> (p-&gt;flag == <span class="number">0</span>) &#123;</span><br><span class="line">        p-&gt;u_epc = p-&gt;trapframe-&gt;epc;</span><br><span class="line">        p-&gt;u_ra = p-&gt;trapframe-&gt;ra;</span><br><span class="line">        p-&gt;u_sp = p-&gt;trapframe-&gt;sp;</span><br><span class="line">        p-&gt;u_gp = p-&gt;trapframe-&gt;gp;</span><br><span class="line">        p-&gt;u_tp = p-&gt;trapframe-&gt;tp;</span><br><span class="line">        p-&gt;u_t0 = p-&gt;trapframe-&gt;t0;</span><br><span class="line">        p-&gt;u_t1 = p-&gt;trapframe-&gt;t1;</span><br><span class="line">        p-&gt;u_t2 = p-&gt;trapframe-&gt;t2;</span><br><span class="line">        p-&gt;u_s0 = p-&gt;trapframe-&gt;s0;</span><br><span class="line">        p-&gt;u_s1 = p-&gt;trapframe-&gt;s1;</span><br><span class="line">        p-&gt;u_a0 = p-&gt;trapframe-&gt;a0;</span><br><span class="line">        p-&gt;u_a1 = p-&gt;trapframe-&gt;a1;</span><br><span class="line">        p-&gt;u_a2 = p-&gt;trapframe-&gt;a2;</span><br><span class="line">        p-&gt;u_a3 = p-&gt;trapframe-&gt;a3;</span><br><span class="line">        p-&gt;u_a4 = p-&gt;trapframe-&gt;a4;</span><br><span class="line">        p-&gt;u_a5 = p-&gt;trapframe-&gt;a5;</span><br><span class="line">        p-&gt;u_a6 = p-&gt;trapframe-&gt;a6;</span><br><span class="line">        p-&gt;u_a7 = p-&gt;trapframe-&gt;a7;</span><br><span class="line">        p-&gt;u_s2 = p-&gt;trapframe-&gt;s2;</span><br><span class="line">        p-&gt;u_s3 = p-&gt;trapframe-&gt;s3;</span><br><span class="line">        p-&gt;u_s4 = p-&gt;trapframe-&gt;s4;</span><br><span class="line">        p-&gt;u_s5 = p-&gt;trapframe-&gt;s5;</span><br><span class="line">        p-&gt;u_s6 = p-&gt;trapframe-&gt;s6;</span><br><span class="line">        p-&gt;u_s7 = p-&gt;trapframe-&gt;s7;</span><br><span class="line">        p-&gt;u_s8 = p-&gt;trapframe-&gt;s8;</span><br><span class="line">        p-&gt;u_s9 = p-&gt;trapframe-&gt;s9;</span><br><span class="line">        p-&gt;u_s10 = p-&gt;trapframe-&gt;s10;</span><br><span class="line">        p-&gt;u_s11 = p-&gt;trapframe-&gt;s11;</span><br><span class="line">        p-&gt;u_t3 = p-&gt;trapframe-&gt;t3;</span><br><span class="line">        p-&gt;u_t4 = p-&gt;trapframe-&gt;t4;</span><br><span class="line">        p-&gt;u_t5 = p-&gt;trapframe-&gt;t5;</span><br><span class="line">        p-&gt;u_t6 = p-&gt;trapframe-&gt;t6;</span><br><span class="line">      </span><br><span class="line">        p-&gt;trapframe-&gt;epc = (uint64)p-&gt;handler;</span><br><span class="line">        p-&gt;flag = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      p-&gt;tick = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    yield();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>sigreturn()：在handler最后调用，保证控制流返回到产生trap的那句用户态代码处。<br>把trapframe-&gt;epc设置为time trap时保存的epc值，这样保证返回到正确的代码处。<br>恢复所有保存的寄存器。<br>handler里也会执行系统调用从而陷入内核态，trapframe会重新进行保存，所以不能保证handler函数的执行过程中进程的trampframe不会产生改变，但p-&gt;u_只有在时钟中断时并且tick=interval时（即进入handler之前）才会进行修改，因此可以保证返回到正确的上下文。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64 <span class="title">sys_sigreturn</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span>* <span class="title">p</span> =</span> myproc();</span><br><span class="line">    p-&gt;trapframe-&gt;epc = p-&gt;u_epc;</span><br><span class="line">    p-&gt;trapframe-&gt;ra = p-&gt;u_ra;</span><br><span class="line">    p-&gt;trapframe-&gt;sp = p-&gt;u_sp;</span><br><span class="line">    p-&gt;trapframe-&gt;gp = p-&gt;u_gp;</span><br><span class="line">    p-&gt;trapframe-&gt;tp = p-&gt;u_tp;</span><br><span class="line">    p-&gt;trapframe-&gt;t0 = p-&gt;u_t0;</span><br><span class="line">    p-&gt;trapframe-&gt;t1 = p-&gt;u_t1;</span><br><span class="line">    p-&gt;trapframe-&gt;t2 = p-&gt;u_t2;</span><br><span class="line">    p-&gt;trapframe-&gt;s0 = p-&gt;u_s0;</span><br><span class="line">    p-&gt;trapframe-&gt;s1 = p-&gt;u_s1;</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = p-&gt;u_a0;</span><br><span class="line">    p-&gt;trapframe-&gt;a1 = p-&gt;u_a1;</span><br><span class="line">    p-&gt;trapframe-&gt;a2 = p-&gt;u_a2;</span><br><span class="line">    p-&gt;trapframe-&gt;a3 = p-&gt;u_a3;</span><br><span class="line">    p-&gt;trapframe-&gt;a4 = p-&gt;u_a4;</span><br><span class="line">    p-&gt;trapframe-&gt;a5 = p-&gt;u_a5;</span><br><span class="line">    p-&gt;trapframe-&gt;a6 = p-&gt;u_a6;</span><br><span class="line">    p-&gt;trapframe-&gt;a7 = p-&gt;u_a7;</span><br><span class="line">    p-&gt;trapframe-&gt;s2 = p-&gt;u_s2;</span><br><span class="line">    p-&gt;trapframe-&gt;s3 = p-&gt;u_s3;</span><br><span class="line">    p-&gt;trapframe-&gt;s4 = p-&gt;u_s4;</span><br><span class="line">    p-&gt;trapframe-&gt;s5 = p-&gt;u_s5;</span><br><span class="line">    p-&gt;trapframe-&gt;s6 = p-&gt;u_s6;</span><br><span class="line">    p-&gt;trapframe-&gt;s7 = p-&gt;u_s7;</span><br><span class="line">    p-&gt;trapframe-&gt;s8 = p-&gt;u_s8;</span><br><span class="line">    p-&gt;trapframe-&gt;s9 = p-&gt;u_s9;</span><br><span class="line">    p-&gt;trapframe-&gt;s10 = p-&gt;u_s10;</span><br><span class="line">    p-&gt;trapframe-&gt;s11 = p-&gt;u_s11;</span><br><span class="line">    p-&gt;trapframe-&gt;t3 = p-&gt;u_t3;</span><br><span class="line">    p-&gt;trapframe-&gt;t4 = p-&gt;u_t4;</span><br><span class="line">    p-&gt;trapframe-&gt;t5 = p-&gt;u_t5;</span><br><span class="line">    p-&gt;trapframe-&gt;t6 = p-&gt;u_t6;</span><br><span class="line">    p-&gt;flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是部分核心代码，其他的就是把sigalarm和sigreturn注册成系统调用，编写makefile等，不再赘述。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://kiseki-zj.github.io/2021/04/03/MIT6.S081%20Lab3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.JPG">
      <meta itemprop="name" content="Kiseki">
      <meta itemprop="description" content=""开心就好啦"">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KISEKI">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/03/MIT6.S081%20Lab3/" class="post-title-link" itemprop="url">MIT6.S081 Lab3 Pgtbl</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-03 12:00:00" itemprop="dateCreated datePublished" datetime="2021-04-03T12:00:00+08:00">2021-04-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-11-05 12:49:44" itemprop="dateModified" datetime="2021-11-05T12:49:44+08:00">2021-11-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="实验前准备"><a href="#实验前准备" class="headerlink" title="实验前准备"></a>实验前准备</h3><blockquote>
<p>阅读vm.c,proc.c,exec.c,看明白xv6怎么初始化内核页表以及怎么实现内存isolation的.阅读trap.c,trampoline.S,明白用户程序陷入内核态以及从内核态返回用户态的过程.<br>阅读xv6book chapter3&amp;chapter4.</p>
</blockquote>
<h3 id="Print-a-page-table"><a href="#Print-a-page-table" class="headerlink" title="Print a page table"></a>Print a page table</h3><p>第一个实验要求实现一个函数vmprint(pagetable_t pagetable),输出页表的内容.其实就是仿照walk模拟硬件翻译的过程,中间把页表项的值输出就可以了.比较简单:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _vmprint(<span class="keyword">pagetable_t</span> pagetable, uint64 depth) &#123;</span><br><span class="line">  <span class="keyword">if</span> (depth == <span class="number">1</span>) </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;page table %p\n&quot;</span>, pagetable);</span><br><span class="line">  <span class="keyword">if</span> (depth == <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">512</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">pte_t</span> pte = pagetable[i];</span><br><span class="line">    <span class="keyword">if</span> (pte &amp; PTE_V) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;..&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; depth; j++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; ..&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d: pte %p pa %p\n&quot;</span>, i, pte, PTE2PA(pte));</span><br><span class="line">      _vmprint((<span class="keyword">pagetable_t</span>)PTE2PA(pte), depth+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vmprint</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable)</span> </span>&#123;</span><br><span class="line">  _vmprint(pagetable, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个实验主要是为了后面实验debug用.</p>
<h3 id="A-kernel-page-table-per-process"><a href="#A-kernel-page-table-per-process" class="headerlink" title="A kernel page table per process"></a>A kernel page table per process</h3><p>xv6为每个进程分配了一个用户页表,在用户态时使用的是当前进程的pagetable,当陷入内核态时会把satp切换为全局的内核页表kernel_pagetable (trampoline.S 78行).kernel_pagetable使用了direct map,把虚拟内存直接map到物理内存,同时也初始化了一些设备地址(kvminit()).如下图</p>
<p><img src="https://pic1.zhimg.com/80/v2-d992e535c19abc307ea2230979f5c53c_720w.jpg" alt="img"></p>
<p>当用户程序调用系统调用传入一个地址时需要在内核态进行翻译获得物理地址.举个例子,程序使用write系统调用传入一个buf,这个buf本质是一个地址,假设为a,它对应的物理地址是b.那么系统陷入到内核态后,由于此时的页表是kernel_pagetable而不是用户的pagetable,kernel_pagetable并没有地址a的对应关系,因此需要通过walk模拟MMU来获得a在用户pagetable中的物理地址即b.</p>
<p>这个实验和下一个实验就是要求为每个进程分配一个kpagetable,当用户陷入内核态时切换到kpagetable而不是全局的kernel_pagetable.这个kpagetable的内容要求有3个:</p>
<p>1.内容和kernel_pagetable基本一样使得在内核态时能够使用内核的代码和数据</p>
<p>2.在trampoline下面是进程的内核栈,kpagetable只能把本进程对应的内核栈map好.其他进程的不能map</p>
<p>3.最重要的一点,由于进程的va从0开始且连续增长,我们在kpagetable中也要保存进程va和pa的对应关系,这样在内核态时可以直接使用用户空间的虚拟地址.以上述例子来说,内核态可以直接使用地址a,因为硬件会自动把a翻译为物理地址b.</p>
<p>这个实验要求完成前两点,下个实验要求完成第3点.</p>
<blockquote>
<p>proc.h</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pagetable_t</span> kpagetable;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>allocproc() 加入初始化kpagetable的过程,proc_kernel_kvminit()类似kvminit把物理内存和设备以及trampoline的地址map好.<br>kprocinit()用来map本进程的内核栈</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// An empty user page table.</span></span><br><span class="line">  p-&gt;pagetable = proc_pagetable(p);</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pagetable == <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//lab3 step2</span></span><br><span class="line"></span><br><span class="line">  p-&gt;kpagetable = proc_kernel_kvminit(p);</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;kpagetable == <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(p);</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  kprocinit(p);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>proc_kernel_kvminit()<br>这里面的proc_kvmmap和kvmmap一样,只不过加了参数指定pagetable</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pagetable_t</span></span></span><br><span class="line"><span class="function"><span class="title">proc_kernel_kvminit</span><span class="params">(struct proc *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">pagetable_t</span> pagetable;</span><br><span class="line">  pagetable = (<span class="keyword">pagetable_t</span>) kalloc();</span><br><span class="line">  <span class="built_in">memset</span>(pagetable, <span class="number">0</span>, PGSIZE);</span><br><span class="line">  <span class="comment">// uart registers</span></span><br><span class="line">  proc_kvmmap(pagetable, UART0, UART0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">  <span class="comment">// virtio mmio disk interface</span></span><br><span class="line">  proc_kvmmap(pagetable, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// CLINT</span></span><br><span class="line">  proc_kvmmap(pagetable, CLINT, CLINT, <span class="number">0x10000</span>, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// PLIC</span></span><br><span class="line">  proc_kvmmap(pagetable, PLIC, PLIC, <span class="number">0x400000</span>, PTE_R | PTE_W);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel text executable and read-only.</span></span><br><span class="line">  proc_kvmmap(pagetable, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// map kernel data and the physical RAM we&#x27;ll make use of.</span></span><br><span class="line">  proc_kvmmap(pagetable, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);</span><br><span class="line">  <span class="comment">// map the trampoline for trap entry/exit to</span></span><br><span class="line">  <span class="comment">// the highest virtual address in the kernel.</span></span><br><span class="line">  proc_kvmmap(pagetable, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);</span><br><span class="line">  <span class="keyword">return</span> pagetable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>void kprocinit(struct proc *p)<br>内核栈物理内存在procinit()时就已经alloc好了,所以只要在页表里map一下就行</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kprocinit</span><span class="params">(struct proc *p)</span> </span>&#123;</span><br><span class="line">  uint64 va = KSTACK((<span class="keyword">int</span>) (p - proc));</span><br><span class="line">  uint64 pa = kvmpa(va);</span><br><span class="line">  <span class="comment">//printf(&quot;p-&gt;kstack = %p\n&quot;, KSTACK((int) (p - proc)));</span></span><br><span class="line">  proc_kvmmap(p-&gt;kpagetable, (uint64)va, (uint64)pa, PGSIZE, PTE_R | PTE_W);</span><br><span class="line">  p-&gt;kstack = va;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>freeproc()<br>加入free kpagetable的过程,首先把用户空间的地址都unmap掉(这是第三个实验要做的),然后proc_free_kpagetable用来free页表.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">freeproc</span><span class="params">(struct proc *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;trapframe)</span><br><span class="line">    kfree((<span class="keyword">void</span>*)p-&gt;trapframe);</span><br><span class="line">  p-&gt;trapframe = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;pagetable)</span><br><span class="line">    proc_freepagetable(p-&gt;pagetable, p-&gt;sz);</span><br><span class="line"></span><br><span class="line">  uvmunmap(p-&gt;kpagetable, <span class="number">0</span>, PGROUNDUP(p-&gt;sz) / PGSIZE, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">//lab3 step2</span></span><br><span class="line">  <span class="keyword">if</span> (p-&gt;kpagetable)</span><br><span class="line">    proc_free_kpagetable(p);</span><br><span class="line">  p-&gt;pagetable = <span class="number">0</span>;</span><br><span class="line">  p-&gt;kpagetable = <span class="number">0</span>;</span><br><span class="line">  p-&gt;sz = <span class="number">0</span>;</span><br><span class="line">  p-&gt;pid = <span class="number">0</span>;</span><br><span class="line">  p-&gt;parent = <span class="number">0</span>;</span><br><span class="line">  p-&gt;name[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  p-&gt;chan = <span class="number">0</span>;</span><br><span class="line">  p-&gt;killed = <span class="number">0</span>;</span><br><span class="line">  p-&gt;xstate = <span class="number">0</span>;</span><br><span class="line">  p-&gt;state = UNUSED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>kuvmunmap和uvmunmap相比去掉了panic,这是因为第三个实验map用户地址时会把底层某些地址覆盖掉,然后如果再unmap掉部分虚拟地址,就会导致中间有的地址unmap.比如UART0是0x1000000,如果用户虚拟地址增长到了0x1001000,再sbrk(-1000)删除一页,这样0x1000000-&gt;0x1001000这部分页表是空的,此时freeproc执行kuvmunmap(p-&gt;kpagetable, UART0, 1, 0)时就会出现not mapped的panic.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">proc_free_kpagetable</span><span class="params">(struct proc *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  kuvmunmap(p-&gt;kpagetable, TRAMPOLINE, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  kuvmunmap(p-&gt;kpagetable, KSTACK((<span class="keyword">int</span>) (p - proc)), <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  kuvmunmap(p-&gt;kpagetable, UART0, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  kuvmunmap(p-&gt;kpagetable, VIRTIO0, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  kuvmunmap(p-&gt;kpagetable, CLINT, <span class="number">0x10000</span> / PGSIZE, <span class="number">0</span>);</span><br><span class="line">  kuvmunmap(p-&gt;kpagetable, PLIC, <span class="number">0x400000</span> / PGSIZE, <span class="number">0</span>);</span><br><span class="line">  kuvmunmap(p-&gt;kpagetable, KERNBASE, (uint64)(etext-KERNBASE) / PGSIZE, <span class="number">0</span>);</span><br><span class="line">  kuvmunmap(p-&gt;kpagetable, (uint64)etext, (PHYSTOP-(uint64)etext) / PGSIZE, <span class="number">0</span>);</span><br><span class="line">  freewalk(p-&gt;kpagetable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>scheduler()<br>切换进程前切换到对应的kpagetable,某进程退出后回到scheduler使用全局kernel_pagetable</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">      acquire(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state == RUNNABLE) &#123;</span><br><span class="line">        <span class="comment">// Switch to chosen process.  It is the process&#x27;s job</span></span><br><span class="line">        <span class="comment">// to release its lock and then reacquire it</span></span><br><span class="line">        <span class="comment">// before jumping back to us.</span></span><br><span class="line">        p-&gt;state = RUNNING;</span><br><span class="line">        c-&gt;proc = p;</span><br><span class="line">        <span class="comment">//lab3 step2</span></span><br><span class="line">        w_satp(MAKE_SATP(p-&gt;kpagetable));</span><br><span class="line">        sfence_vma();</span><br><span class="line"></span><br><span class="line">        swtch(&amp;c-&gt;context, &amp;p-&gt;context);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Process is done running for now.</span></span><br><span class="line">        <span class="comment">// It should have changed its p-&gt;state before coming back.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//lab3 step2</span></span><br><span class="line">        w_satp(MAKE_SATP(kernel_pagetable));</span><br><span class="line">        sfence_vma();</span><br><span class="line"></span><br><span class="line">        c-&gt;proc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        found = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Simplify-copyin-copyinstr"><a href="#Simplify-copyin-copyinstr" class="headerlink" title="Simplify copyin/copyinstr"></a>Simplify copyin/copyinstr</h3><p>这个实验要完成第3个条件,在kpagetable把用户空间的虚拟地址也map好.hints已经告诉我们在exec(),fork(),growproc()里修改kpagetable就可以了,因为只有这些函数会修改用户pagetable.</p>
<blockquote>
<p>exec()<br>这里的逻辑就是把kpagetable底部用户空间的部分先全部unmap掉,再把用户pagetable的内容通过kuvmcopy复制到kpagetable里<br>之所以unmap时不需要free掉物理内存,是因为下面proc_freepagetable(oldpagetable, oldsz)把原先的pagetable释放掉同时free了对应的物理内存.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">oldpagetable = p-&gt;pagetable;</span><br><span class="line">  p-&gt;pagetable = pagetable;</span><br><span class="line">  p-&gt;sz = sz;</span><br><span class="line">  p-&gt;trapframe-&gt;epc = elf.entry;  <span class="comment">// initial program counter = main</span></span><br><span class="line">  p-&gt;trapframe-&gt;sp = sp; <span class="comment">// initial stack pointer</span></span><br><span class="line">  <span class="comment">//lab3 step3</span></span><br><span class="line">  uvmunmap(p-&gt;kpagetable, <span class="number">0</span>, PGROUNDUP(oldsz) / PGSIZE, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (kuvmcopy(p, sz, PTE_R|PTE_W|PTE_X) != <span class="number">0</span>) &#123;</span><br><span class="line">    panic(<span class="string">&quot;kuvmcopy&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  w_satp(MAKE_SATP(p-&gt;kpagetable));</span><br><span class="line">  sfence_vma();</span><br><span class="line">  proc_freepagetable(oldpagetable, oldsz);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>kuvmcopy()<br>把进程new的pagetable底部(即不包含trampoline和trapframe)复制给kpagetable<br>函数mappages_remap和mappages相比去掉了remap的panic,理由在step2里提到了,kpagetable在map时可能需要覆盖某些设备的地址.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kuvmcopy</span><span class="params">(struct proc *<span class="keyword">new</span>, uint64 sz, <span class="keyword">int</span> perm)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">pte_t</span> *pte;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line">  <span class="keyword">pagetable_t</span> newpg = <span class="keyword">new</span>-&gt;pagetable;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(newpg, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: pte should exist&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: page not present&quot;</span>);</span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line">    <span class="keyword">if</span>(mappages_remap(<span class="keyword">new</span>-&gt;kpagetable, i, PGSIZE, pa, perm) != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err:</span><br><span class="line">  uvmunmap(<span class="keyword">new</span>-&gt;kpagetable, <span class="number">0</span>, i / PGSIZE, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>fork()<br>同理把fork出来的子进程的用户pagetable复制给kpagetable,注意flag不能有PTE_U,因为cpu在suprivisor模式时不能访问设置PTE_U的页</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// Copy user memory from parent to child.</span></span><br><span class="line">  <span class="keyword">if</span>(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(np);</span><br><span class="line">    release(&amp;np-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(kuvmcopy(np, p-&gt;sz, PTE_R|PTE_W|PTE_X) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    freeproc(np);</span><br><span class="line">    release(&amp;np-&gt;lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>growproc()<br>这个稍微麻烦一点,用户空间增长n时要同时在pagetable和kpagetable进行map,同理n&lt;0也要.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">growproc</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uint sz;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="comment">//lab3 step3</span></span><br><span class="line"></span><br><span class="line">  uint oldsz;</span><br><span class="line">  oldsz = sz = p-&gt;sz;</span><br><span class="line">  <span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    sz = kuvmalloc(p, sz, sz + n);</span><br><span class="line">    <span class="keyword">if</span>( sz == <span class="number">0</span> ) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sz &gt; PLIC) &#123;</span><br><span class="line">      kuvmdealloc(p, sz, oldsz);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      sz = kuvmdealloc(p, sz, sz + n);</span><br><span class="line">  &#125; </span><br><span class="line">  p-&gt;sz = sz;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>kuvmalloc()<br>和uvmalloc相比加入了给kpagetable进行map的过程,注意在mappages_remap返回-1的时候要不仅要free物理内存,还要把之前mappages()时用户pagetable给unmap掉,一直过不去sbrkfail这个test的原因就是这个.<br>具体来说,比如内存还剩100,kuvmalloc分配第99页后不会触发mem=0,但是执行mappages会把物理内存剩的最后一页用于分配页表,此时执行mappages_remap就会失败(因为没有物理内存了),在这个逻辑下是不应该分配这个第99页的.如果直接执行kuvmdealloc会把用户pagetable第99页的map关系保留下来,导致最后freeproc时panic leaf map.</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64</span></span><br><span class="line"><span class="function"><span class="title">kuvmalloc</span><span class="params">(struct proc *p, uint64 oldsz, uint64 newsz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *mem;</span><br><span class="line">  uint64 a;</span><br><span class="line">  <span class="keyword">pagetable_t</span> pagetable = p-&gt;pagetable;</span><br><span class="line">  <span class="keyword">pagetable_t</span> kpagetable = p-&gt;kpagetable;</span><br><span class="line">  <span class="keyword">if</span>(newsz &lt; oldsz)</span><br><span class="line">    <span class="keyword">return</span> oldsz;</span><br><span class="line">  oldsz = PGROUNDUP(oldsz);</span><br><span class="line">  <span class="keyword">for</span>(a = oldsz; a &lt; newsz; a += PGSIZE)&#123;</span><br><span class="line">    mem = kalloc();</span><br><span class="line">    <span class="keyword">if</span>(mem == <span class="number">0</span>)&#123;</span><br><span class="line">      kuvmdealloc(p, a, oldsz);    </span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);    </span><br><span class="line">    <span class="keyword">if</span>(mappages(pagetable, a, PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R|PTE_U) != <span class="number">0</span>)&#123;</span><br><span class="line">      kfree(mem);</span><br><span class="line">      kuvmdealloc(p, a, oldsz);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mappages_remap(kpagetable, a, PGSIZE, (uint64)mem, PTE_W|PTE_X|PTE_R) != <span class="number">0</span>) &#123;</span><br><span class="line">      kfree(mem);</span><br><span class="line">      uvmunmap(pagetable, a, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">      kuvmdealloc(p, a, oldsz);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newsz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>kuvmdealloc()<br>仿照uvmdealloc就行</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64</span></span><br><span class="line"><span class="function"><span class="title">kuvmdealloc</span><span class="params">(struct proc *p, uint64 oldsz, uint64 newsz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">pagetable_t</span> pagetable = p-&gt;pagetable;</span><br><span class="line">  <span class="keyword">pagetable_t</span> kpagetable = p-&gt;kpagetable;</span><br><span class="line">  <span class="keyword">if</span>(newsz &gt;= oldsz)</span><br><span class="line">    <span class="keyword">return</span> oldsz;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(PGROUNDUP(newsz) &lt; PGROUNDUP(oldsz))&#123;</span><br><span class="line">    <span class="keyword">int</span> npages = (PGROUNDUP(oldsz) - PGROUNDUP(newsz)) / PGSIZE;</span><br><span class="line">    uvmunmap(pagetable, PGROUNDUP(newsz), npages, <span class="number">1</span>);</span><br><span class="line">    kuvmunmap(kpagetable, PGROUNDUP(newsz), npages, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newsz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p><img src="https://pic3.zhimg.com/80/v2-d0566e3093b15954bdaedd4d1fcdf192_720w.jpg" alt="img"></p>
<h3 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h3><p>主要是要先看懂几个重要函数的作用,弄懂陷入内核态和返回用户态的过程,理解内核页表和用户页表的内存分布,搞清楚实验目的是什么.接下来就是耐心debug了,如果usertests某些测试一直通不过可以看一下这个test做了些什么,以此定位哪里的代码可能出错.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Kiseki"
      src="/images/touxiang.JPG">
  <p class="site-author-name" itemprop="name">Kiseki</p>
  <div class="site-description" itemprop="description">"开心就好啦"</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/kiseki-zj" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;kiseki-zj" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">null </a>
  </div>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kiseki</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
